{
    "Closure-8": {
        "Buggy Function": "private boolean canBeRedeclared(Node n, Scope s) {\nif (!NodeUtil.isExprAssign(n)) {\nreturn false;\n}\nNode assign = n.getFirstChild();\nNode lhs = assign.getFirstChild();\n\nif (!lhs.isName()) {\nreturn false;\n}\n\nVar var = s.getVar(lhs.getString());\nreturn var != null &&\n  var.getScope() == s && !blacklistedVars.contains(var);\n}\n}",
        "Inducing Changes": "diff --git a/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java b/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java\nindex 76361f5..6728a35 100644\n--- a/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java\n+++ b/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java\n@@ -20,6 +20,7 @@\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n@@ -69,13 +70,19 @@\n      * Variable declaration that any following var nodes should be\n      * collapsed into\n      */\n-    final Node firstVarNode;\n+    final Node startNode;\n+\n+    /**\n+     * Last node (non-inclusive) of the chain of nodes to collapse.\n+     */\n+    final Node endNode;\n \n     /** Parent of the nodes to the collapse */\n     final Node parent;\n \n-    Collapse(Node firstVarNode, Node parent) {\n-      this.firstVarNode = firstVarNode;\n+    Collapse(Node startNode, Node endNode, Node parent) {\n+      this.startNode = startNode;\n+      this.endNode = endNode;\n       this.parent = parent;\n     }\n   }\n@@ -110,15 +117,20 @@\n   }\n \n   /**\n-   * Gathers all of the variable declarations that should be collapsed into one.\n+   * Gathers all of the variable declarations / assignments that should be\n+   * collapsed into one.\n+   *\n    * We do not do the collapsing as we go since node traversal would be affected\n    * by the changes we are making to the parse tree.\n    */\n   private class GatherCollapses extends AbstractPostOrderCallback {\n \n+    // TODO(user): This is purely a subtree peep hole optimization. We\n+    // can rewrite this so it no longer have a sperate gather and merge stage.\n+\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       // Only care about var nodes\n-      if (n.getType() != Token.VAR) return;\n+      if (n.getType() != Token.VAR && !canBeRedeclared(n, t.getScope())) return;\n \n       // If we've already looked at this node, skip it\n       if (nodesToCollapse.contains(n)) return;\n@@ -129,36 +141,82 @@\n \n       Node varNode = n;\n \n+      boolean hasVar = n.getType() == Token.VAR;\n+\n       // Find variable declarations that follow this one (if any)\n       n = n.getNext();\n \n       boolean hasNodesToCollapse = false;\n-      while (n != null && n.getType() == Token.VAR) {\n+\n+      while (n != null &&\n+          (n.getType() == Token.VAR || canBeRedeclared(n, t.getScope()))) {\n+\n+        if (NodeUtil.isVar(n)) {\n+          hasVar = true;\n+        }\n+\n         nodesToCollapse.add(n);\n         hasNodesToCollapse = true;\n \n         n = n.getNext();\n       }\n \n-      if (hasNodesToCollapse) {\n+      if (hasNodesToCollapse && hasVar) {\n         nodesToCollapse.add(varNode);\n-        collapses.add(new Collapse(varNode, parent));\n+        collapses.add(new Collapse(varNode, n, parent));\n       }\n-\n     }\n   }\n \n+  private boolean canBeRedeclared(Node n, Scope s) {\n+    if (!NodeUtil.isExprAssign(n)) {\n+      return false;\n+    }\n+    Node assign = n.getFirstChild();\n+    Node lhs = assign.getFirstChild();\n+\n+    if (!NodeUtil.isName(lhs)) {\n+      return false;\n+    }\n+\n+    return s.isDeclared(lhs.getString(), false);\n+  }\n+\n   private void applyCollapses() {\n     for (Collapse collapse : collapses) {\n-      Node first = collapse.firstVarNode;\n-      while (first.getNext() != null &&\n-          first.getNext().getType() == Token.VAR) {\n-        Node next = collapse.parent.removeChildAfter(first);\n \n-        // Move all children of the next var node into the first one.\n-        first.addChildrenToBack(next.removeChildren());\n+      Node var = new Node(Token.VAR);\n+      var.copyInformationFrom(collapse.startNode);\n+      collapse.parent.addChildBefore(var, collapse.startNode);\n+\n+      boolean redeclaration = false;\n+      for (Node n = collapse.startNode; n != collapse.endNode;) {\n+        Node next = n.getNext();\n+\n+        Preconditions.checkState(var.getNext() == n);\n+        collapse.parent.removeChildAfter(var);\n+\n+        if (NodeUtil.isVar(n)) {\n+          while(n.hasChildren()) {\n+            var.addChildToBack(n.removeFirstChild());\n+          }\n+        } else {\n+          Node assign = n.getFirstChild();\n+          Node lhs = assign.getFirstChild();\n+          Preconditions.checkState(NodeUtil.isName(lhs));\n+          Node rhs = assign.getLastChild();\n+          lhs.addChildToBack(rhs.detachFromParent());\n+          var.addChildToBack(lhs.detachFromParent());\n+          redeclaration = true;\n+        }\n+        n = next;\n+      }\n+\n+      if (redeclaration) {\n+        JSDocInfo info = new JSDocInfo();\n+        info.addSuppression(\"duplicate\");\n+        var.setJSDocInfo(info);\n       }\n     }\n   }\n-\n }\n\n"
    },
    "Closure-10": {
        "Buggy Function": "  static boolean mayBeString(Node n, boolean recurse) {\n    if (recurse) {\n      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n    } else {\n      return mayBeStringHelper(n);\n    }\n  }",
        "Inducing Changes": "diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex 615cec4..bfc4ba8 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -1075,12 +1075,47 @@\n   }\n \n   /**\n+   * Apply the supplied predicate against the potential\n+   * all possible result of the expression.\n+   */\n+  static boolean valueCheck(Node n, Predicate<Node> p) {\n+    switch (n.getType()) {\n+      case Token.ASSIGN:\n+      case Token.COMMA:\n+        return valueCheck(n.getLastChild(), p);\n+      case Token.AND:\n+      case Token.OR:\n+        return valueCheck(n.getFirstChild(), p)\n+            && valueCheck(n.getLastChild(), p);\n+      case Token.HOOK:\n+        return valueCheck(n.getFirstChild().getNext(), p)\n+            && valueCheck(n.getLastChild(), p);\n+      default:\n+        return p.apply(n);\n+    }\n+  }\n+\n+  static class NumbericResultPredicate implements Predicate<Node> {\n+    public boolean apply(Node n) {\n+      return isNumericResultHelper(n);\n+    }\n+  }\n+\n+  static final NumbericResultPredicate NUMBERIC_RESULT_PREDICATE =\n+      new NumbericResultPredicate();\n+\n+  /**\n    * Returns true if the result of node evaluation is always a number\n    */\n   static boolean isNumericResult(Node n) {\n+    return valueCheck(n, NUMBERIC_RESULT_PREDICATE);\n+  }\n+\n+  static boolean isNumericResultHelper(Node n) {\n     switch (n.getType()) {\n-      // NOTE: ADD is deliberately excluded as it may produce\n-      // a string.\n+      case Token.ADD:\n+        return !mayBeString(n.getFirstChild())\n+            && !mayBeString(n.getLastChild());\n       case Token.BITNOT:\n       case Token.BITOR:\n       case Token.BITXOR:\n@@ -1112,10 +1147,23 @@\n     }\n   }\n \n+  static class BooleanResultPredicate implements Predicate<Node> {\n+    public boolean apply(Node n) {\n+      return isBooleanResultHelper(n);\n+    }\n+  }\n+\n+  static final BooleanResultPredicate BOOLEAN_RESULT_PREDICATE =\n+      new BooleanResultPredicate();\n+\n   /**\n    * @return Whether the result of node evaluation is always a boolean\n    */\n   static boolean isBooleanResult(Node n) {\n+    return valueCheck(n, BOOLEAN_RESULT_PREDICATE);\n+  }\n+\n+  static boolean isBooleanResultHelper(Node n) {\n     // TODO(johnlenz): Add a recursive option to recurse into\n     // AND, OR, HOOK, COMMA and ASSIGN, like \"getExpressionBooleanValue\".\n     switch (n.getType()) {\n@@ -1156,10 +1204,31 @@\n     return n.getType() == Token.NULL;\n   }\n \n+  static class MayBeStringResultPredicate implements Predicate<Node> {\n+    public boolean apply(Node n) {\n+      return mayBeStringHelper(n);\n+    }\n+  }\n+\n+  static final MayBeStringResultPredicate MAY_BE_STRING_PREDICATE =\n+      new MayBeStringResultPredicate();\n+\n   /**\n    * @returns Whether the results is possibly a string.\n    */\n   static boolean mayBeString(Node n) {\n+    return mayBeString(n, true);\n+  }\n+\n+  static boolean mayBeString(Node n, boolean recurse) {\n+    if (recurse) {\n+      return valueCheck(n, MAY_BE_STRING_PREDICATE);\n+    } else {\n+      return mayBeStringHelper(n);\n+    }\n+  }\n+\n+  static boolean mayBeStringHelper(Node n) {\n     return !isNumericResult(n) && !isBooleanResult(n)\n         && !isUndefined(n) && !isNull(n);\n   }\n\n"
    },
    "Closure-12": {
        "Buggy Function": "  private boolean hasExceptionHandler(Node cfgNode) {\n    return false;\n  }",
        "Inducing Changes": "diff --git a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\nindex 69d78e2..ecc1509 100644\n--- a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n@@ -422,7 +422,10 @@\n \n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n-          if (NodeUtil.isName(n) \u0026\u0026 n.getString().equals(varName)) {\n+          if (NodeUtil.isName(n) \u0026\u0026 n.getString().equals(varName) \u0026\u0026\n+              // do not count in if it is left child of an assignment operator\n+              !(NodeUtil.isAssign(parent) \u0026\u0026\n+               (parent.getFirstChild() \u003d\u003d n))) {\n             numUseWithinUseCfgNode++;\n           }\n         }\n"
    },
    "Closure-17": {
        "Buggy Function": "    private JSType getDeclaredType(String sourceName, JSDocInfo info,\n        Node lValue, @Nullable Node rValue) {\n      if (info != null && info.hasType()) {\n        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n      } else if (rValue != null && rValue.isFunction() &&\n          shouldUseFunctionLiteralType(\n              JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\n        return rValue.getJSType();\n      } else if (info != null) {\n        if (info.hasEnumParameterType()) {\n          if (rValue != null && rValue.isObjectLit()) {\n            return rValue.getJSType();\n          } else {\n            return createEnumTypeFromNodes(\n                rValue, lValue.getQualifiedName(), info, lValue);\n          }\n        } else if (info.isConstructor() || info.isInterface()) {\n          return createFunctionTypeFromNodes(\n              rValue, lValue.getQualifiedName(), info, lValue);\n        } else {\n          // Check if this is constant, and if it has a known type.\n          if (info.isConstant()) {\n            JSType knownType = null;\n            if (rValue != null) {\n              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n                // If rValue has a type-cast, we use the type in the type-cast.\n                // If rValue's type was already computed during scope creation,\n                // then we can safely use that.\n                return rValue.getJSType();\n              } else if (rValue.isOr()) {\n                // Check for a very specific JS idiom:\n                // var x = x || TYPE;\n                // This is used by Closure's base namespace for esoteric\n                // reasons.\n                Node firstClause = rValue.getFirstChild();\n                Node secondClause = firstClause.getNext();\n                boolean namesMatch = firstClause.isName()\n                    && lValue.isName()\n                    && firstClause.getString().equals(lValue.getString());\n                if (namesMatch && secondClause.getJSType() != null\n                    && !secondClause.getJSType().isUnknownType()) {\n                  return secondClause.getJSType();\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n    }",
        "Inducing Changes": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex 73aee95..a0dd90b 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -544,8 +544,10 @@\n       info = getBestJSDocInfo(objectLit);\n       Node lValue = getBestLValue(objectLit);\n       String lValueName = getBestLValueName(lValue);\n+      boolean createdEnumType = false;\n       if (info != null && info.hasEnumParameterType()) {\n         type = createEnumTypeFromNodes(objectLit, lValueName, info, lValue);\n+        createdEnumType = true;\n       }\n \n       if (type == null) {\n@@ -554,8 +556,11 @@\n \n       setDeferredType(objectLit, type);\n \n-      processObjectLitProperties(\n-          t, objectLit, ObjectType.cast(objectLit.getJSType()));\n+      // If this is an enum, the properties were already taken care of above.\n+      if (!createdEnumType) {\n+        processObjectLitProperties(\n+            t, objectLit, ObjectType.cast(objectLit.getJSType()));\n+      }\n     }\n \n     /**\n@@ -1127,20 +1132,25 @@\n           shouldUseFunctionLiteralType(\n               (FunctionType) rValue.getJSType(), info, lValue)) {\n         return rValue.getJSType();\n-      } else if (info != null && info.hasEnumParameterType()) {\n-        if (rValue != null && rValue.getType() == Token.OBJECTLIT) {\n-          return rValue.getJSType();\n-        } else {\n-          return createEnumTypeFromNodes(\n+      } else if (info != null) {\n+        if (info.hasEnumParameterType()) {\n+          if (rValue != null && rValue.getType() == Token.OBJECTLIT) {\n+            return rValue.getJSType();\n+          } else {\n+            return createEnumTypeFromNodes(\n+                rValue, lValue.getQualifiedName(), info, lValue);\n+          }\n+        } else if (info.isConstructor() || info.isInterface()) {\n+          return createFunctionTypeFromNodes(\n               rValue, lValue.getQualifiedName(), info, lValue);\n+        } else if (info.isConstant() && rValue != null\n+            && rValue.getJSType() != null\n+            && !rValue.getJSType().isUnknownType()) {\n+          return rValue.getJSType();\n         }\n-      } else if (info != null &&\n-                 (info.isConstructor() || info.isInterface())) {\n-        return createFunctionTypeFromNodes(\n-            rValue, lValue.getQualifiedName(), info, lValue);\n-      } else {\n-        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n       }\n+\n+      return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n     }\n \n     /**\n@@ -1290,18 +1300,19 @@\n       // 1) @type annnotation / @enum annotation\n       // 2) ASSIGN to FUNCTION literal\n       // 3) @param/@return annotation (with no function literal)\n-      // 4) ASSIGN to anything else\n+      // 4) ASSIGN to something marked @const\n+      // 5) ASSIGN to anything else\n       //\n-      // 1 and 3 are declarations, 4 is inferred, and 2 is a declaration iff\n+      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n       // the function has not been declared before.\n       //\n       // FUNCTION literals are special because TypedScopeCreator is very smart\n       // about getting as much type information as possible for them.\n \n-      // Determining type for #1 + #2 + #3\n+      // Determining type for #1 + #2 + #3 + #4\n       JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n       if (valueType == null && rhsValue != null) {\n-        // Determining type for #4\n+        // Determining type for #5\n         valueType = rhsValue.getJSType();\n       }\n \n@@ -1318,9 +1329,12 @@\n \n       boolean inferred = true;\n       if (info != null) {\n-        // Determining declaration for #1 + #3\n-        inferred = !(info.hasType() || info.hasEnumParameterType() ||\n-            FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n+        // Determining declaration for #1 + #3 + #4\n+        inferred = !(info.hasType()\n+            || info.hasEnumParameterType()\n+            || (info.isConstant() && valueType != null\n+                && !valueType.isUnknownType())\n+            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n \n       if (inferred) {\n\n"
    },
    "Closure-21": {
        "Buggy Function": "  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty() ||\n        n.isComma()) {\n      return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n    if (n.isExprResult()) {\n      return;\n    }\n\n    // This no-op statement was there so that JSDoc information could\n    // be attached to the name. This check should not complain about it.\n    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n      return;\n    }\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (parent.getType() == Token.COMMA) {\n      if (isResultUsed) {\n        return;\n      }\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA) continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n          else break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n        return;\n      }\n    }\n    if (\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n      // TODO(johnlenz): determine if it is necessary to\n      // try to protect side-effect free statements as well.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }",
        "Inducing Changes": "diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex 00e31e0..5de1e6f 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -3111,7 +3111,6 @@\n     // TODO(johnlenz): consider sharing some code with trySimpleUnusedResult.\n     Node parent = expr.getParent();\n     switch (parent.getType()) {\n-      case Token.BLOCK:\n       case Token.EXPR_RESULT:\n         return false;\n       case Token.HOOK:\n@@ -3120,21 +3119,6 @@\n         return (expr == parent.getFirstChild())\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n-        Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n-\n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n       case Token.FOR:\n\n"
    },
    "Closure-30": {
        "Buggy Function": "// buggy function from src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n@Override\npublic void process(Node externs, Node root) {\n    (new NodeTraversal(compiler, this)).traverse(root);\n}\n// buggy function from src/com/google/javascript/jscomp/MustBeReachingVariableDef.java\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.isName() && jsScope.isDeclared(n.getString(), true)) {\n      def.depends.add(jsScope.getVar(n.getString()));\n    }\n}\nboolean dependsOnOuterScopeVars(String name, Node useNode) {\n    Preconditions.checkArgument(getCfg().hasNode(useNode));\n    GraphNode<Node, Branch> n = getCfg().getNode(useNode);\n    FlowState<MustDef> state = n.getAnnotation();\n    Definition def = state.getIn().reachingDef.get(jsScope.getVar(name));\n    for (Var s : def.depends) {\n      if (s.scope != jsScope) {\n        return true;\n      }\n    }\n    return false;\n}",
        "Inducing Changes": "diff --git a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\nnew file mode 100644\nindex 0000000..8ec85c1\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n@@ -0,0 +1,470 @@\n+/*\n+ * Copyright 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Predicate;\n+import com.google.common.base.Predicates;\n+import com.google.common.collect.Lists;\n+import com.google.javascript.jscomp.ControlFlowGraph.AbstractCfgNodeTraversalCallback;\n+import com.google.javascript.jscomp.ControlFlowGraph.Branch;\n+import com.google.javascript.jscomp.DataFlowAnalysis.FlowState;\n+import com.google.javascript.jscomp.MustBeReachingVariableDef.MustDef;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;\n+import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n+import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n+import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import java.util.Collection;\n+import java.util.List;\n+\n+/**\n+ * Inline variables when possible. Using the information from\n+ * {@link MaybeReachingVariableUse} and {@link MustBeReachingVariableDef},\n+ * this pass attempts to inline a variable by placing the value at the\n+ * definition where the variable is used. The basic requirements for inlining\n+ * are the following:\n+ *\n+ * <ul>\n+ * <li> There is exactly one reaching definition at the use of that variable\n+ * </li>\n+ * <li> There is exactly one use for that definition of the variable\n+ * </li>\n+ * </ul>\n+ *\n+ * <p>Other requirements can be found in {@link Candidate#canInline}. Currently\n+ * this pass does not operate on the global scope due to compilation time.\n+ *\n+*\n+ */\n+class FlowSensitiveInlineVariables extends AbstractPostOrderCallback\n+    implements CompilerPass, ScopedCallback {\n+\n+  /**\n+   * Implementation:\n+   *\n+   * This pass first perform a traversal to gather a list of Candidates that\n+   * could be inlined using {@link GatherCandiates}.\n+   *\n+   * The second step involves verifying that each candidate is actually safe\n+   * to inline with {@link Candidate#canInline()} and finally perform inlining\n+   * using {@link Candidate#inlineVariable()}.\n+   *\n+   * The reason for the delayed evaluation of the candidates is because we\n+   * need two separate dataflow result.\n+   */\n+  private final AbstractCompiler compiler;\n+\n+  // These two pieces of data is persistent in the whole execution of enter\n+  // scope.\n+  private ControlFlowGraph<Node> cfg;\n+  private List<Candidate> candidates;\n+  private MustBeReachingVariableDef reachingDef;\n+  private MaybeReachingVariableUse reachingUses;\n+\n+  private static final Predicate<Node> SIDE_EFFECT_PREDICATE =\n+    new Predicate<Node>() {\n+      @Override\n+      public boolean apply(Node n) {\n+        // When the node is null it means, we reached the implicit return\n+        // where the function returns (possibly without an return statement)\n+        if (n == null) {\n+          return false;\n+        }\n+\n+        // TODO(user): We only care about calls to functions that\n+        // passes one of the dependent variable to a non-sideeffect free\n+        // function.\n+        if (NodeUtil.isCall(n) && NodeUtil.functionCallHasSideEffects(n)) {\n+          return true;\n+        }\n+\n+        if (NodeUtil.isNew(n) && NodeUtil.constructorCallHasSideEffects(n)) {\n+          return true;\n+        }\n+\n+        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n+          if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {\n+            return true;\n+          }\n+        }\n+        return false;\n+      }\n+  };\n+\n+  public FlowSensitiveInlineVariables(AbstractCompiler compiler) {\n+    this.compiler = compiler;\n+  }\n+\n+  @Override\n+  public void enterScope(NodeTraversal t) {\n+\n+    if (t.inGlobalScope()) {\n+      return; // Don't even brother. All global variables are likely escaped.\n+    }\n+\n+    // Compute the forward reaching definition.\n+    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false);\n+    // Process the body of the function.\n+    Preconditions.checkState(NodeUtil.isFunction(t.getScopeRoot()));\n+    cfa.process(null, t.getScopeRoot().getLastChild());\n+    cfg = cfa.getCfg();\n+    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n+    reachingDef.analyze();\n+    candidates = Lists.newLinkedList();\n+\n+    // Using the forward reaching definition search to find all the inline\n+    // candiates\n+    new NodeTraversal(compiler, new GatherCandiates()).traverse(\n+        t.getScopeRoot().getLastChild());\n+\n+    // Compute the backward reaching use. The CFG can be reused.\n+    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n+    reachingUses.analyze();\n+    for (Candidate c : candidates) {\n+      if (c.canInline()) {\n+        c.inlineVariable();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void exitScope(NodeTraversal t) {}\n+\n+  @Override\n+  public void process(Node externs, Node root) {\n+    (new NodeTraversal(compiler, this)).traverse(root);\n+  }\n+\n+  @Override\n+  public void visit(NodeTraversal t, Node n, Node parent) {\n+    // TODO(user): While the helpers do a subtree traversal on the AST, the\n+    // compiler pass itself only traverse the AST to look for function\n+    // declarations to perform dataflow analysis on. We could combine\n+    // the traversal in DataFlowAnalysis's computeEscaped later to save some\n+    // time.\n+  }\n+\n+  /**\n+   * Gathers a list of possible candidates for inlining based only on\n+   * information from {@link MustBeReachingVariableDef}. The list will be stored\n+   * in {@code candidiates} and the validity of each inlining Candidate should\n+   * be later verified with {@link Candidate#canInline()} when\n+   * {@link MaybeReachingVariableUse} has been performed.\n+   */\n+  private class GatherCandiates extends AbstractShallowCallback {\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      DiGraphNode<Node, Branch> graphNode = cfg.getDirectedGraphNode(n);\n+      if (graphNode == null) {\n+        // Not a CFG node.\n+        return;\n+      }\n+      FlowState<MustDef> state = graphNode.getAnnotation();\n+      final MustDef defs = state.getIn();\n+      final Node cfgNode = n;\n+      AbstractCfgNodeTraversalCallback gatherCb =\n+          new AbstractCfgNodeTraversalCallback() {\n+\n+        @Override\n+        public void visit(NodeTraversal t, Node n, Node parent) {\n+          if (NodeUtil.isName(n)) {\n+\n+            // Make sure that the name node is purely a read.\n+            if ((NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n)\n+                || NodeUtil.isVar(parent) || parent.getType() == Token.INC ||\n+                parent.getType() == Token.DEC || parent.getType() == Token.LP ||\n+                parent.getType() == Token.CATCH) {\n+              return;\n+            }\n+\n+            String name = n.getString();\n+            if (compiler.getCodingConvention().isExported(name)) {\n+              return;\n+            }\n+\n+            Node defNode = reachingDef.getDef(name, cfgNode);\n+            if (defNode != null) {\n+              candidates.add(new Candidate(name, defNode, n, cfgNode));\n+            }\n+          }\n+        }\n+      };\n+\n+      NodeTraversal.traverse(compiler, cfgNode, gatherCb);\n+    }\n+  }\n+\n+  /**\n+   * Models the connection between a definition and a use of that definition.\n+   */\n+  private class Candidate {\n+\n+    // Name of the variable.\n+    private final String varName;\n+\n+    // Nodes related to the definition.\n+    private Node def;\n+    private final Node defCfgNode;\n+\n+    // Nodes related to the use.\n+    private final Node use;\n+    private final Node useCfgNode;\n+\n+    // Number of uses of the variable within the CFG node that represented the\n+    // use in the CFG.\n+    private int numUseWithinUseCfgNode;\n+\n+    Candidate(String varName, Node defCfgNode, Node use, Node useCfgNode) {\n+      Preconditions.checkArgument(NodeUtil.isName(use));\n+      this.varName = varName;\n+      this.defCfgNode = defCfgNode;\n+      this.use = use;\n+      this.useCfgNode = useCfgNode;\n+    }\n+\n+    private boolean canInline() {\n+\n+      // Cannot inline a parameter.\n+      if (NodeUtil.isFunction(defCfgNode)) {\n+        return false;\n+      }\n+\n+      getDefinition(defCfgNode, null);\n+      getNumUseInUseCfgNode(useCfgNode, null);\n+\n+      // Definition was not found.\n+      if (def == null) {\n+        return false;\n+      }\n+\n+      // Check that the assignment isn't used as a R-Value.\n+      // TODO(user): Certain cases we can still inline.\n+      if (NodeUtil.isAssign(def) && !NodeUtil.isExprAssign(def.getParent())) {\n+        return false;\n+      }\n+\n+\n+      // The right of the definition has side effect:\n+      // Example, for x:\n+      // x = readProp(b), modifyProp(b); print(x);\n+      if (checkRightOf(def, defCfgNode, SIDE_EFFECT_PREDICATE)) {\n+        return false;\n+      }\n+\n+      // Similar check as the above but this time, all the sub-expressions\n+      // left of the use of the variable.\n+      // x = readProp(b); modifyProp(b), print(x);\n+      if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n+        return false;\n+      }\n+\n+      // Similar side effect check as above but this time the side effect is\n+      // else where along the path.\n+      // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+      CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>\n+        pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n+               cfg,\n+               cfg.getDirectedGraphNode(defCfgNode),\n+               cfg.getDirectedGraphNode(useCfgNode),\n+               SIDE_EFFECT_PREDICATE,\n+               Predicates.\n+                   <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n+               false);\n+      if (pathCheck.somePathsSatisfyPredicate()) {\n+        return false;\n+      }\n+\n+      // TODO(user): Side-effect is ok sometimes. As long as there are no\n+      // side-effect function down all paths to the use. Once we have all the\n+      // side-effect analysis tool.\n+      if (NodeUtil.mayHaveSideEffects(def.getLastChild())) {\n+        return false;\n+      }\n+\n+      // TODO(user): We could inline all the uses if the expression is short.\n+\n+      // Finally we have to make sure that there are no more than one use\n+      // in the program and in the CFG node. Even when it is semantically\n+      // correctly inlining twice increases code size.\n+      if (numUseWithinUseCfgNode != 1) {\n+        return false;\n+      }\n+\n+      // We give up inling stuff with R-Value that has GETPROP, GETELEM,\n+      // or anything that creates a new object.\n+      // Example:\n+      // var x = a.b.c; j.c = 1; print(x);\n+      // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n+      // TODO(user): We could get more accuracy by looking more in-detail\n+      // what j is and what x is trying to into to.\n+      if (NodeUtil.has(def.getLastChild(),\n+          new Predicate<Node>() {\n+              @Override\n+              public boolean apply(Node input) {\n+                switch (input.getType()) {\n+                  case Token.GETELEM:\n+                  case Token.GETPROP:\n+                  case Token.ARRAYLIT:\n+                  case Token.OBJECTLIT:\n+                  case Token.REGEXP:\n+                  case Token.NEW:\n+                    return true;\n+                }\n+                return false;\n+              }\n+          },\n+          new Predicate<Node>() {\n+              @Override\n+              public boolean apply(Node input) {\n+                // Recurse if the node is not a function.\n+                return !NodeUtil.isFunction(input);\n+              }\n+          })) {\n+        return false;\n+      }\n+\n+      Collection<Node> uses = reachingUses.getUses(varName, defCfgNode);\n+\n+      if (uses.size() != 1) {\n+        return false;\n+      }\n+\n+      return true;\n+    }\n+\n+    /**\n+     * Actual transformation.\n+     */\n+    private void inlineVariable() {\n+      Node defParent = def.getParent();\n+      Node useParent = use.getParent();\n+      if (NodeUtil.isAssign(def)) {\n+        Node rhs = def.getLastChild();\n+        rhs.detachFromParent();\n+        // Oh yes! I have grandparent to remove this.\n+        Preconditions.checkState(NodeUtil.isExpressionNode(defParent));\n+        while (defParent.getParent().getType() == Token.LABEL) {\n+          defParent = defParent.getParent();\n+        }\n+        defParent.detachFromParent();\n+        useParent.replaceChild(use, rhs);\n+      } else if (NodeUtil.isVar(defParent)) {\n+        Node rhs = def.getLastChild();\n+        def.removeChild(rhs);\n+        useParent.replaceChild(use, rhs);\n+      } else {\n+        Preconditions.checkState(false, \"No other definitions can be inlined.\");\n+      }\n+      compiler.reportCodeChange();\n+    }\n+\n+    /**\n+     * Set the def node\n+     *\n+     * @param n A node that has a corresponding CFG node in the CFG.\n+     */\n+    private void getDefinition(Node n, Node parent) {\n+      AbstractCfgNodeTraversalCallback gatherCb =\n+        new AbstractCfgNodeTraversalCallback() {\n+\n+        @Override\n+        public void visit(NodeTraversal t, Node n, Node parent) {\n+          switch (n.getType()) {\n+            case Token.NAME:\n+              if (n.getString().equals(varName) && n.hasChildren()) {\n+                def = n;\n+              }\n+              return;\n+\n+            case Token.ASSIGN:\n+              Node lhs = n.getFirstChild();\n+              if (NodeUtil.isName(lhs) && lhs.getString().equals(varName)) {\n+                def = n;\n+              }\n+              return;\n+          }\n+        }\n+      };\n+      NodeTraversal.traverse(compiler, n, gatherCb);\n+    }\n+\n+    /**\n+     * Computes the number of uses of the variable varName and store it in\n+     * numUseWithinUseCfgNode.\n+     */\n+    private void getNumUseInUseCfgNode(Node n, Node parant) {\n+\n+      AbstractCfgNodeTraversalCallback gatherCb =\n+          new AbstractCfgNodeTraversalCallback() {\n+\n+        @Override\n+        public void visit(NodeTraversal t, Node n, Node parent) {\n+          if (NodeUtil.isName(n) && n.getString().equals(varName)) {\n+            numUseWithinUseCfgNode++;\n+          }\n+        }\n+      };\n+\n+      NodeTraversal.traverse(compiler, n, gatherCb);\n+    }\n+  }\n+\n+  /**\n+   * Given an expression by its root and sub-expression n, return true if there\n+   * the predicate is true for some expression on the right of n.\n+   *\n+   * Example:\n+   *\n+   * NotChecked(), NotChecked(), n, Checked(), Checked();\n+   */\n+  private static boolean checkRightOf(\n+      Node n, Node expressionRoot, Predicate<Node> predicate) {\n+    for (Node p = n; p != expressionRoot; p = p.getParent()) {\n+      for (Node cur = p.getNext(); cur != null; cur = cur.getNext()) {\n+        if (predicate.apply(cur)) {\n+          return true;\n+        }\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Given an expression by its root and sub-expression n, return true if there\n+   * the predicate is true for some expression on the left of n.\n+   *\n+   * Example:\n+   *\n+   * Checked(), Checked(), n, NotChecked(), NotChecked();\n+   */\n+  private static boolean checkLeftOf(\n+      Node n, Node expressionRoot, Predicate<Node> predicate) {\n+    for (Node p = n.getParent(); p != expressionRoot; p = p.getParent()) {\n+      for (Node cur = p.getParent().getFirstChild(); cur != p;\n+          cur = cur.getNext()) {\n+        if (predicate.apply(cur)) {\n+          return true;\n+        }\n+      }\n+    }\n+    return false;\n+  }\n+}\n\n"
    },
    "Closure-31": {
        "Buggy Function": "  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n\n    // Parse main js sources.\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n      // Parse externs sources.\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n\n      // Modules inferred in ProcessCommonJS pass.\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n\n      // Check if inputs need to be rebuilt from modules.\n      boolean staleInputs = false;\n\n      // Check if the sources need to be re-ordered.\n      if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          // Forward-declare all the provided types, so that they\n          // are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }\n\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n\n        // Inputs can have a null AST during initial parse.\n        if (n == null) {\n          continue;\n        }\n\n        if (n.getJSDocInfo() != null) {\n          JSDocInfo info = n.getJSDocInfo();\n          if (info.isExterns()) {\n            // If the input file is explicitly marked as an externs file, then\n            // assume the programmer made a mistake and throw it into\n            // the externs pile anyways.\n            externsRoot.addChildToBack(n);\n            input.setIsExtern(true);\n\n            input.getModule().remove(input);\n\n            externs.add(input);\n            staleInputs = true;\n          } else if (info.isNoCompile()) {\n            input.getModule().remove(input);\n            staleInputs = true;\n          }\n        }\n      }\n\n      if (staleInputs) {\n        fillEmptyModules(modules);\n        rebuildInputsFromModules();\n      }\n\n      // Build the AST.\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n\n          // Annotate the nodes in the tree with information from the\n          // input file. This information is used to construct the SourceMap.\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n\n        jsRoot.addChildToBack(n);\n      }\n\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }",
        "Inducing Changes": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex 90a469f..4ff23f7 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -479,14 +479,14 @@\n     inputsById = new HashMap<InputId, CompilerInput>();\n     for (CompilerInput input : externs) {\n       InputId id = input.getInputId();\n-      CompilerInput previous = inputsById.put(id, input);\n+      CompilerInput previous = putCompilerInput(id, input);\n       if (previous != null) {\n         report(JSError.make(DUPLICATE_EXTERN_INPUT, input.getName()));\n       }\n     }\n     for (CompilerInput input : inputs) {\n       InputId id = input.getInputId();\n-      CompilerInput previous = inputsById.put(id, input);\n+      CompilerInput previous = putCompilerInput(id, input);\n       if (previous != null) {\n         report(JSError.make(DUPLICATE_INPUT, input.getName()));\n       }\n@@ -1021,17 +1021,22 @@\n       throw new IllegalArgumentException(\"Conflicting externs name: \" + name);\n     }\n     CompilerInput input = new CompilerInput(ast, true);\n-    inputsById.put(input.getInputId(), input);\n+    putCompilerInput(input.getInputId(), input);\n     externsRoot.addChildToFront(ast.getAstRoot(this));\n     externs.add(0, input);\n     return input;\n   }\n \n+  private CompilerInput putCompilerInput(InputId id, CompilerInput input) {\n+    input.setCompiler(this);\n+    return inputsById.put(id, input);\n+  }\n+\n   /** Add a source input dynamically. Intended for incremental compilation. */\n   void addIncrementalSourceAst(JsAst ast) {\n     InputId id = ast.getInputId();\n     Preconditions.checkState(getInput(id) == null, \"Duplicate input %s\", id.getIdName());\n-    inputsById.put(id, new CompilerInput(ast));\n+    putCompilerInput(id, new CompilerInput(ast));\n   }\n \n   /**\n@@ -1059,7 +1064,7 @@\n     }\n \n     CompilerInput newInput = new CompilerInput(ast);\n-    inputsById.put(ast.getInputId(), newInput);\n+    putCompilerInput(ast.getInputId(), newInput);\n \n     JSModule module = oldInput.getModule();\n     if (module != null) {\n@@ -1108,7 +1113,7 @@\n       modules.get(0).add(newInput);\n     }\n \n-    inputsById.put(ast.getInputId(), newInput);\n+    putCompilerInput(ast.getInputId(), newInput);\n \n     return true;\n   }\n@@ -1268,11 +1273,14 @@\n         processAMDAndCommonJSModules();\n       }\n \n-      // Check if the sources need to be re-ordered.\n-      if (options.dependencyOptions.needsManagement()) {\n-        for (CompilerInput input : inputs) {\n-          input.setCompiler(this);\n+      // Check if inputs need to be rebuilt from modules.\n+      boolean staleInputs = false;\n \n+      // Check if the sources need to be re-ordered.\n+      if (options.dependencyOptions.needsManagement() &&\n+          !options.skipAllPasses &&\n+          options.closurePass) {\n+        for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n@@ -1284,6 +1292,7 @@\n           inputs =\n               (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n               .manageDependencies(options.dependencyOptions, inputs);\n+          staleInputs = true;\n         } catch (CircularDependencyException e) {\n           report(JSError.make(\n               JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n@@ -1303,8 +1312,6 @@\n         }\n       }\n \n-      // Check if inputs need to be rebuilt from modules.\n-      boolean staleInputs = false;\n       for (CompilerInput input : inputs) {\n         Node n = input.getAstRoot(this);\n \n@@ -1446,7 +1453,7 @@\n   Node parseSyntheticCode(String js) {\n     CompilerInput input = new CompilerInput(\n         SourceFile.fromCode(\" [synthetic:\" + (++syntheticCodeId) + \"] \", js));\n-    inputsById.put(input.getInputId(), input);\n+    putCompilerInput(input.getInputId(), input);\n     return input.getAstRoot(this);\n   }\n \n@@ -1479,7 +1486,7 @@\n     if (inputsById == null) {\n       inputsById = Maps.newHashMap();\n     }\n-    inputsById.put(input.getInputId(), input);\n+    putCompilerInput(input.getInputId(), input);\n     return input.getAstRoot(this);\n   }\n \n\n"
    },
    "Closure-33": {
        "Buggy Function": "  public void matchConstraint(ObjectType constraintObj) {\n    // We only want to match contraints on anonymous types.\n\n    // Handle the case where the constraint object is a record type.\n    //\n    // param constraintObj {{prop: (number|undefined)}}\n    // function f(constraintObj) {}\n    // f({});\n    //\n    // We want to modify the object literal to match the constraint, by\n    // taking any each property on the record and trying to match\n    // properties on this object.\n    if (constraintObj.isRecordType()) {\n      for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!isPropertyTypeDeclared(prop)) {\n          JSType typeToInfer = propType;\n          if (!hasProperty(prop)) {\n            typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n                .getLeastSupertype(propType);\n          }\n          defineInferredProperty(prop, typeToInfer, null);\n        }\n      }\n    }\n  }",
        "Inducing Changes": "diff --git a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\nindex f4b537d..1a51afb 100644\n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n@@ -550,4 +550,30 @@\n     }\n     return this;\n   }\n+\n+  @Override\n+  public void matchConstraint(ObjectType constraintObj) {\n+    // Handle the case where the constraint object is a record type.\n+    //\n+    // param constraintObj {{prop: (number|undefined)}}\n+    // function f(constraintObj) {}\n+    // f({});\n+    //\n+    // We want to modify the object literal to match the constraint, by\n+    // taking any each property on the record and trying to match\n+    // properties on this object.\n+    if (constraintObj.isRecordType()) {\n+      for (String prop : constraintObj.getOwnPropertyNames()) {\n+        JSType propType = constraintObj.getPropertyType(prop);\n+        if (!isPropertyTypeDeclared(prop)) {\n+          JSType typeToInfer = propType;\n+          if (!hasProperty(prop)) {\n+            typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n+                .getLeastSupertype(propType);\n+          }\n+          defineInferredProperty(prop, typeToInfer, null);\n+        }\n+      }\n+    }\n+  }\n }\n\n"
    },
    "Closure-48": {
        "Buggy Function": "    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n\n      // Precedence of type information on GETPROPs:\n      // 1) @type annnotation / @enum annotation\n      // 2) ASSIGN to FUNCTION literal\n      // 3) @param/@return annotation (with no function literal)\n      // 4) ASSIGN to something marked @const\n      // 5) ASSIGN to anything else\n      //\n      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n      // the function has jsdoc or has not been declared before.\n      //\n      // FUNCTION literals are special because TypedScopeCreator is very smart\n      // about getting as much type information as possible for them.\n\n      // Determining type for #1 + #2 + #3 + #4\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n      }\n      // Function prototypes are special.\n      // It's a common JS idiom to do:\n      // F.prototype = { ... };\n      // So if F does not have an explicitly declared super type,\n      // allow F.prototype to be redefined arbitrarily.\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          // If the programmer has declared that F inherits from Super,\n          // and they assign F.prototype to an object literal,\n          // then they are responsible for making sure that the object literal's\n          // implicit prototype is set up appropriately. We just obey\n          // the @extends tag.\n          ObjectType qVarType = ObjectType.cast(qVar.getType());\n          if (qVarType != null &&\n              rhsValue != null &&\n              rhsValue.isObjectLit()) {\n            typeRegistry.resetImplicitPrototype(\n                rhsValue.getJSType(), qVarType.getImplicitPrototype());\n          } else if (!qVar.isTypeInferred()) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to some arbitrary expression,\n            // there's not much we can do. We just ignore the expression,\n            // and hope they've annotated their code in a way to tell us\n            // what props are going to be on that prototype.\n            return;\n          }\n          if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n\n      if (valueType == null) {\n        if (parent.isExprResult()) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n\n        return;\n      }\n\n      // NOTE(nicksantos): Determining whether a property is declared or not\n      // is really really obnoxious.\n      //\n      // The problem is that there are two (equally valid) coding styles:\n      //\n      // (function() {\n      //   /* The authoritative definition of goog.bar. */\n      //   goog.bar = function() {};\n      // })();\n      //\n      // function f() {\n      //   goog.bar();\n      //   /* Reset goog.bar to a no-op. */\n      //   goog.bar = function() {};\n      // }\n      //\n      // In a dynamic language with first-class functions, it's very difficult\n      // to know which one the user intended without looking at lots of\n      // contextual information (the second example demonstrates a small case\n      // of this, but there are some really pathological cases as well).\n      //\n      // The current algorithm checks if either the declaration has\n      // jsdoc type information, or @const with a known type,\n      // or a function literal with a name we haven't seen before.\n      boolean inferred = true;\n      if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null &&\n            rhsValue.isFunction() &&\n            (info != null || !scope.isDeclared(qName, false)));\n      }\n\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          // Only declare this as an official property if it has not been\n          // declared yet.\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            // If the property is undeclared or inferred, declare it now.\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null && rhsValue.isTrue()) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType =\n            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      }\n    }",
        "Inducing Changes": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex 28d9d37..5628a08 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -158,37 +158,42 @@\n     // inner scopes, because only global scopes can contain named classes that\n     // show up in the type registry.\n     Scope newScope = null;\n+    AbstractScopeBuilder scopeBuilder = null;\n     if (parent == null) {\n       // Find all the classes in the global scope.\n       newScope = createInitialScope(root);\n \n-      GlobalScopeBuilder scopeBuilder = new GlobalScopeBuilder(newScope);\n+      GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope);\n+      scopeBuilder = globalScopeBuilder;\n       NodeTraversal.traverse(compiler, root, scopeBuilder);\n-      scopeBuilder.resolveStubDeclarations();\n-      scopeBuilder.resolveTypes();\n-\n-      // Gather the properties in each function that we found in the\n-      // global scope, if that function has a @this type that we can\n-      // build properties on.\n-      for (Node functionNode : scopeBuilder.nonExternFunctions) {\n-        JSType type = functionNode.getJSType();\n-        if (type != null && type instanceof FunctionType) {\n-          FunctionType fnType = (FunctionType) type;\n-          ObjectType fnThisType = fnType.getTypeOfThis();\n-          if (!fnThisType.isUnknownType()) {\n-            NodeTraversal.traverse(compiler, functionNode.getLastChild(),\n-                scopeBuilder.new CollectProperties(fnThisType));\n-          }\n-        }\n-      }\n-\n-      codingConvention.defineDelegateProxyPrototypeProperties(\n-          typeRegistry, newScope, delegateProxyPrototypes);\n     } else {\n       newScope = new Scope(parent, root);\n-      LocalScopeBuilder scopeBuilder = new LocalScopeBuilder(newScope);\n-      scopeBuilder.build();\n-      scopeBuilder.resolveTypes();\n+      LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope);\n+      scopeBuilder = localScopeBuilder;\n+      localScopeBuilder.build();\n+    }\n+\n+    scopeBuilder.resolveStubDeclarations();\n+    scopeBuilder.resolveTypes();\n+\n+    // Gather the properties in each function that we found in the\n+    // global scope, if that function has a @this type that we can\n+    // build properties on.\n+    for (Node functionNode : scopeBuilder.nonExternFunctions) {\n+      JSType type = functionNode.getJSType();\n+      if (type != null && type instanceof FunctionType) {\n+        FunctionType fnType = (FunctionType) type;\n+        ObjectType fnThisType = fnType.getTypeOfThis();\n+        if (!fnThisType.isUnknownType()) {\n+          NodeTraversal.traverse(compiler, functionNode.getLastChild(),\n+              scopeBuilder.new CollectProperties(fnThisType));\n+        }\n+      }\n+    }\n+\n+    if (parent == null) {\n+      codingConvention.defineDelegateProxyPrototypeProperties(\n+          typeRegistry, newScope, delegateProxyPrototypes);\n     }\n     return newScope;\n   }\n@@ -359,6 +364,20 @@\n         Lists.newArrayList();\n \n     /**\n+     * Functions that we found in the global scope and not in externs.\n+     */\n+    private final List<Node> nonExternFunctions = Lists.newArrayList();\n+\n+    /**\n+     * Type-less stubs.\n+     *\n+     * If at the end of traversal, we still don't have types for these\n+     * stubs, then we should declare UNKNOWN types.\n+     */\n+    private final List<StubDeclaration> stubDeclarations =\n+        Lists.newArrayList();\n+\n+    /**\n      * The current source file that we're in.\n      */\n     private String sourceName = null;\n@@ -403,7 +422,58 @@\n     }\n \n     @Override\n-    public abstract void visit(NodeTraversal t, Node n, Node parent);\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      attachLiteralTypes(n);\n+\n+      switch (n.getType()) {\n+        case Token.CALL:\n+          checkForClassDefiningCalls(t, n, parent);\n+          break;\n+\n+        case Token.FUNCTION:\n+          if (t.getInput() == null || !t.getInput().isExtern()) {\n+            nonExternFunctions.add(n);\n+          }\n+\n+          // VARs and ASSIGNs are handled in different branches of this\n+          // switch statement.\n+          if (parent.getType() != Token.ASSIGN &&\n+              parent.getType() != Token.NAME) {\n+            defineDeclaredFunction(n, parent);\n+          }\n+\n+          break;\n+\n+        case Token.ASSIGN:\n+          // Handle constructor and enum definitions.\n+          defineNamedTypeAssign(n, parent);\n+\n+          // Handle initialization of properties.\n+          Node firstChild = n.getFirstChild();\n+          if (firstChild.getType() == Token.GETPROP &&\n+              firstChild.isQualifiedName()) {\n+            maybeDeclareQualifiedName(t, n.getJSDocInfo(),\n+                firstChild, n, firstChild.getNext());\n+          }\n+          break;\n+\n+        case Token.CATCH:\n+          defineCatch(n, parent);\n+          break;\n+\n+        case Token.VAR:\n+          defineVar(n, parent);\n+          break;\n+\n+        case Token.GETPROP:\n+          // Handle stubbed properties.\n+          if (parent.getType() == Token.EXPR_RESULT &&\n+              n.isQualifiedName()) {\n+            maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);\n+          }\n+          break;\n+      }\n+    }\n \n     /**\n      * Returns the type specified in a JSDoc annotation near a GETPROP or NAME.\n@@ -615,8 +685,8 @@\n         Node rValue, JSDocInfo info, @Nullable Node lvalueNode) {\n       FunctionType functionType = null;\n \n-      // Handle function aliases.\n-      if (rValue != null && rValue.isQualifiedName()) {\n+      // Global function aliases should be registered with the type registry.\n+      if (rValue != null && rValue.isQualifiedName() && scope.isGlobal()) {\n         Var var = scope.getVar(rValue.getQualifiedName());\n         if (var != null && var.getType() instanceof FunctionType) {\n           functionType = (FunctionType) var.getType();\n@@ -863,100 +933,27 @@\n         }\n       }\n     }\n-  }\n-\n-  /**\n-   * A shallow traversal of the global scope to build up all classes,\n-   * functions, and methods.\n-   */\n-  private final class GlobalScopeBuilder extends AbstractScopeBuilder {\n \n     /**\n-     * Functions that we found in the global scope and not in externs.\n-     */\n-    private final List<Node> nonExternFunctions = Lists.newArrayList();\n-\n-    /**\n-     * Type-less stubs in the global scope.\n+     * Look for a type declaration on a GETPROP node.\n      *\n-     * If at the end of traversal, we still don't have types for these\n-     * stubs, then we should declare UNKNOWN types.\n+     * @param info The doc info for this property.\n+     * @param n A top-level GETPROP node (it should not be contained inside\n+     *     another GETPROP).\n+     * @param rhsValue The node that {@code n} is being initialized to,\n+     *     or {@code null} if this is a stub declaration.\n      */\n-    private final List<StubDeclaration> stubDeclarations =\n-        Lists.newArrayList();\n-\n-    private GlobalScopeBuilder(Scope scope) {\n-      super(scope);\n-    }\n-\n-    /**\n-     * Visit a node in the global scope, and add anything it declares to the\n-     * global symbol table.\n-     *\n-     * @param t The current traversal.\n-     * @param n The node being visited.\n-     * @param parent The parent of n\n-     */\n-    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n-      attachLiteralTypes(n);\n-\n-      switch (n.getType()) {\n-        case Token.CALL:\n-          checkForClassDefiningCalls(t, n, parent);\n-          break;\n-\n-        case Token.FUNCTION:\n-          if (!t.getInput().isExtern()) {\n-            nonExternFunctions.add(n);\n-          }\n-\n-          // VARs and ASSIGNs are handled separately.\n-          if (parent.getType() == Token.ASSIGN ||\n-              parent.getType() == Token.NAME) {\n-            return;\n-          }\n-\n-          defineDeclaredFunction(n, parent);\n-          break;\n-\n-        case Token.ASSIGN:\n-          // Handle constructor and enum definitions.\n-          defineNamedTypeAssign(n, parent);\n-\n-          // Handle typedefs.\n-          checkForOldStyleTypedef(t, n);\n-\n-          // Handle initialization of properties.\n-          Node firstChild = n.getFirstChild();\n-          if (firstChild.getType() == Token.GETPROP &&\n-              firstChild.isQualifiedName()) {\n-            maybeDeclareQualifiedName(t, n.getJSDocInfo(),\n-                firstChild, n, firstChild.getNext());\n-          }\n-          break;\n-\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-\n-        case Token.VAR:\n-          defineVar(n, parent);\n-\n-          // Handle typedefs.\n-          if (n.hasOneChild()) {\n-            checkForOldStyleTypedef(t, n);\n-            checkForTypedef(t, n.getFirstChild(), n.getJSDocInfo());\n-          }\n-          break;\n-\n-        case Token.GETPROP:\n-          // Handle stubbed properties.\n-          if (parent.getType() == Token.EXPR_RESULT &&\n-              n.isQualifiedName()) {\n-            checkForTypedef(t, n, n.getJSDocInfo());\n-            maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);\n-          }\n-          break;\n+    private JSType getDeclaredGetPropType(NodeTraversal t, JSDocInfo info,\n+        Node n, Node rhsValue) {\n+      if (info != null && info.hasType()) {\n+        return getDeclaredTypeInAnnotation(t, n, info);\n+      } else if (info != null && info.hasEnumParameterType()) {\n+        return n.getJSType();\n+      } else if (rhsValue != null &&\n+          rhsValue.getType() == Token.FUNCTION) {\n+        return rhsValue.getJSType();\n+      } else {\n+        return getDeclaredTypeInAnnotation(t, n, info);\n       }\n     }\n \n@@ -1068,6 +1065,284 @@\n     }\n \n     /**\n+     * Declare the symbol for a qualified name in the global scope.\n+     *\n+     * @param info The doc info for this property.\n+     * @param n A top-level GETPROP node (it should not be contained inside\n+     *     another GETPROP).\n+     * @param parent The parent of {@code n}.\n+     * @param rhsValue The node that {@code n} is being initialized to,\n+     *     or {@code null} if this is a stub declaration.\n+     */\n+    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n+        Node n, Node parent, Node rhsValue) {\n+      Node ownerNode = n.getFirstChild();\n+      String ownerName = ownerNode.getQualifiedName();\n+      String qName = n.getQualifiedName();\n+      String propName = n.getLastChild().getString();\n+      Preconditions.checkArgument(qName != null && ownerName != null);\n+\n+      // Function prototypes are special.\n+      // It's a common JS idiom to do:\n+      // F.prototype = { ... };\n+      // So if F does not have an explicitly declared super type,\n+      // allow F.prototype to be redefined arbitrarily.\n+      if (\"prototype\".equals(propName)) {\n+        Var qVar = scope.getVar(qName);\n+        if (qVar != null) {\n+          if (!qVar.isTypeInferred()) {\n+            // Just ignore assigns to declared prototypes.\n+            return;\n+          }\n+          scope.undeclare(qVar);\n+        }\n+      }\n+\n+      // Precedence of type information on GETPROPs:\n+      // 1) @type annotation / @enum annotation\n+      // 2) ASSIGN to FUNCTION literal\n+      // 3) @param/@return annotation (with no function literal)\n+      // 4) ASSIGN to anything else\n+      //\n+      // 1 and 3 are declarations, 4 is inferred, and 2 is a declaration iff\n+      // the function has not been declared before.\n+      //\n+      // FUNCTION literals are special because TypedScopeCreator is very smart\n+      // about getting as much type information as possible for them.\n+\n+      // Determining type for #1 + #2 + #3\n+      JSType valueType = getDeclaredGetPropType(t, info, n, rhsValue);\n+      if (valueType == null && rhsValue != null) {\n+        // Determining type for #4\n+        valueType = rhsValue.getJSType();\n+      }\n+\n+      if (valueType == null) {\n+        if (parent.getType() == Token.EXPR_RESULT) {\n+          stubDeclarations.add(new StubDeclaration(\n+              n,\n+              t.getInput() != null && t.getInput().isExtern(),\n+              ownerName));\n+        }\n+\n+        return;\n+      }\n+\n+      boolean inferred = true;\n+      if (info != null) {\n+        // Determining declaration for #1 + #3\n+        inferred = !(info.hasType() || info.hasEnumParameterType() ||\n+            FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n+      }\n+\n+      if (inferred) {\n+        // Determining declaration for #2\n+        inferred = !(rhsValue != null &&\n+            rhsValue.getType() == Token.FUNCTION &&\n+            !scope.isDeclared(qName, false));\n+      }\n+\n+      if (!inferred) {\n+        ObjectType ownerType = getObjectSlot(ownerName);\n+        if (ownerType != null) {\n+          // Only declare this as an official property if it has not been\n+          // declared yet.\n+          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n+          if ((!ownerType.hasOwnProperty(propName) ||\n+               ownerType.isPropertyTypeInferred(propName)) &&\n+              ((isExtern && !ownerType.isNativeObjectType()) ||\n+               !ownerType.isInstanceType())) {\n+            // If the property is undeclared or inferred, declare it now.\n+            ownerType.defineDeclaredProperty(propName, valueType, isExtern);\n+          }\n+        }\n+\n+        // If the property is already declared, the error will be\n+        // caught when we try to declare it in the current scope.\n+        defineSlot(n, parent, valueType, inferred);\n+      } else if (rhsValue != null &&\n+          rhsValue.getType() == Token.TRUE) {\n+        // We declare these for delegate proxy method properties.\n+        ObjectType ownerType = getObjectSlot(ownerName);\n+        if (ownerType instanceof FunctionType) {\n+          JSType ownerTypeOfThis = ((FunctionType) ownerType).getTypeOfThis();\n+          String delegateName = codingConvention.getDelegateSuperclassName();\n+          JSType delegateType = delegateName == null ?\n+              null : typeRegistry.getType(delegateName);\n+          if (delegateType != null &&\n+              ownerTypeOfThis.isSubtype(delegateType)) {\n+            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE),\n+                true);\n+          }\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Find the ObjectType associated with the given slot.\n+     * @param slotName The name of the slot to find the type in.\n+     * @return An object type, or null if this slot does not contain an object.\n+     */\n+    private ObjectType getObjectSlot(String slotName) {\n+      Var ownerVar = scope.getVar(slotName);\n+      if (ownerVar != null) {\n+        JSType ownerVarType = ownerVar.getType();\n+        return ObjectType.cast(ownerVarType == null ?\n+            null : ownerVarType.restrictByNotNullOrUndefined());\n+      }\n+      return null;\n+    }\n+\n+    /**\n+     * Resolve any stub delcarations to unknown types if we could not\n+     * find types for them during traversal.\n+     */\n+    void resolveStubDeclarations() {\n+      for (StubDeclaration stub : stubDeclarations) {\n+        Node n = stub.node;\n+        Node parent = n.getParent();\n+        String qName = n.getQualifiedName();\n+        String propName = n.getLastChild().getString();\n+        String ownerName = stub.ownerName;\n+        boolean isExtern = stub.isExtern;\n+\n+        if (scope.isDeclared(qName, false)) {\n+          continue;\n+        }\n+\n+        // If we see a stub property, make sure to register this property\n+        // in the type registry.\n+        ObjectType ownerType = getObjectSlot(ownerName);\n+        ObjectType unknownType = typeRegistry.getNativeObjectType(UNKNOWN_TYPE);\n+        defineSlot(n, parent, unknownType, true);\n+\n+        if (ownerType != null &&\n+            (isExtern || ownerType.isFunctionPrototypeType())) {\n+          // If this is a stub for a prototype, just declare it\n+          // as an unknown type. These are seen often in externs.\n+          ownerType.defineInferredProperty(\n+              propName, unknownType, isExtern);\n+        } else {\n+          typeRegistry.registerPropertyOnType(\n+              propName, ownerType == null ? unknownType : ownerType);\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Collects all declared properties in a function, and\n+     * resolves them relative to the global scope.\n+     */\n+    private final class CollectProperties\n+        extends AbstractShallowCallback {\n+      private final ObjectType thisType;\n+\n+      CollectProperties(ObjectType thisType) {\n+        this.thisType = thisType;\n+      }\n+\n+      public void visit(NodeTraversal t, Node n, Node parent) {\n+        if (parent != null && parent.getType() == Token.EXPR_RESULT) {\n+          switch (n.getType()) {\n+            case Token.ASSIGN:\n+              maybeCollectMember(t, n.getFirstChild(), n);\n+              break;\n+            case Token.GETPROP:\n+              maybeCollectMember(t, n, n);\n+              break;\n+          }\n+        }\n+      }\n+\n+      private void maybeCollectMember(NodeTraversal t,\n+          Node member, Node nodeWithJsDocInfo) {\n+        JSDocInfo info = nodeWithJsDocInfo.getJSDocInfo();\n+\n+        // Do nothing if there is no JSDoc type info, or\n+        // if the node is not a member expression, or\n+        // if the member expression is not of the form: this.someProperty.\n+        if (info == null ||\n+            member.getType() != Token.GETPROP ||\n+            member.getFirstChild().getType() != Token.THIS) {\n+          return;\n+        }\n+\n+        member.getFirstChild().setJSType(thisType);\n+        JSType jsType = getDeclaredTypeInAnnotation(t, member, info);\n+        Node name = member.getLastChild();\n+        if (jsType != null &&\n+            (name.getType() == Token.NAME || name.getType() == Token.STRING)) {\n+          thisType.defineDeclaredProperty(\n+              name.getString(),\n+              jsType,\n+              false /* functions with implementations are not in externs */);\n+        }\n+      }\n+    } // end CollectProperties\n+  }\n+\n+  /**\n+   * A stub declaration without any type information.\n+   */\n+  private static final class StubDeclaration {\n+    private final Node node;\n+    private final boolean isExtern;\n+    private final String ownerName;\n+\n+    private StubDeclaration(Node node, boolean isExtern, String ownerName) {\n+      this.node = node;\n+      this.isExtern = isExtern;\n+      this.ownerName = ownerName;\n+    }\n+  }\n+\n+  /**\n+   * A shallow traversal of the global scope to build up all classes,\n+   * functions, and methods.\n+   */\n+  private final class GlobalScopeBuilder extends AbstractScopeBuilder {\n+\n+    private GlobalScopeBuilder(Scope scope) {\n+      super(scope);\n+    }\n+\n+    /**\n+     * Visit a node in the global scope, and add anything it declares to the\n+     * global symbol table.\n+     *\n+     * @param t The current traversal.\n+     * @param n The node being visited.\n+     * @param parent The parent of n\n+     */\n+    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n+      super.visit(t, n, parent);\n+\n+      switch (n.getType()) {\n+\n+        case Token.ASSIGN:\n+          // Handle typedefs.\n+          checkForOldStyleTypedef(t, n);\n+          break;\n+\n+        case Token.VAR:\n+          // Handle typedefs.\n+          if (n.hasOneChild()) {\n+            checkForOldStyleTypedef(t, n);\n+            checkForTypedef(t, n.getFirstChild(), n.getJSDocInfo());\n+          }\n+          break;\n+      }\n+    }\n+\n+    @Override\n+    void maybeDeclareQualifiedName(\n+        NodeTraversal t, JSDocInfo info,\n+        Node n, Node parent, Node rhsValue) {\n+      checkForTypedef(t, n, info);\n+      super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue);\n+    }\n+\n+    /**\n      * Handle typedefs.\n      * @param t The current traversal.\n      * @param candidate A qualified name node.\n@@ -1136,258 +1411,6 @@\n         // this typedef in the scope.\n       }\n     }\n-\n-    /**\n-     * Declare the symbol for a qualified name in the global scope.\n-     *\n-     * @param info The doc info for this property.\n-     * @param n A top-level GETPROP node (it should not be contained inside\n-     *     another GETPROP).\n-     * @param parent The parent of {@code n}.\n-     * @param rhsValue The node that {@code n} is being initialized to,\n-     *     or {@code null} if this is a stub declaration.\n-     */\n-    private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n-        Node n, Node parent, Node rhsValue) {\n-      Node ownerNode = n.getFirstChild();\n-      String ownerName = ownerNode.getQualifiedName();\n-      String qName = n.getQualifiedName();\n-      String propName = n.getLastChild().getString();\n-      Preconditions.checkArgument(qName != null && ownerName != null);\n-\n-      // Function prototypes are special.\n-      // It's a common JS idiom to do:\n-      // F.prototype = { ... };\n-      // So if F does not have an explicitly declared super type,\n-      // allow F.prototype to be redefined arbitrarily.\n-      if (\"prototype\".equals(propName)) {\n-        Var qVar = scope.getVar(qName);\n-        if (qVar != null) {\n-          if (!qVar.isTypeInferred()) {\n-            // Just ignore assigns to declared prototypes.\n-            return;\n-          }\n-          scope.undeclare(qVar);\n-        }\n-      }\n-\n-      // Precedence of type information on GETPROPs:\n-      // 1) @type annotation / @enum annotation\n-      // 2) ASSIGN to FUNCTION literal\n-      // 3) @param/@return annotation (with no function literal)\n-      // 4) ASSIGN to anything else\n-      //\n-      // 1 and 3 are declarations, 4 is inferred, and 2 is a declaration iff\n-      // the function has not been declared before.\n-      //\n-      // FUNCTION literals are special because TypedScopeCreator is very smart\n-      // about getting as much type information as possible for them.\n-\n-      // Determining type for #1 + #2 + #3\n-      JSType valueType = getDeclaredGetPropType(t, info, n, rhsValue);\n-      if (valueType == null && rhsValue != null) {\n-        // Determining type for #4\n-        valueType = rhsValue.getJSType();\n-      }\n-\n-      if (valueType == null) {\n-        if (parent.getType() == Token.EXPR_RESULT) {\n-          stubDeclarations.add(new StubDeclaration(\n-              n, t.getInput().isExtern(), ownerName));\n-        }\n-\n-        return;\n-      }\n-\n-      boolean inferred = true;\n-      if (info != null) {\n-        // Determining declaration for #1 + #3\n-        inferred = !(info.hasType() || info.hasEnumParameterType() ||\n-            FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n-      }\n-\n-      if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null &&\n-            rhsValue.getType() == Token.FUNCTION &&\n-            !scope.isDeclared(qName, false));\n-      }\n-\n-      if (!inferred) {\n-        ObjectType ownerType = getObjectSlot(ownerName);\n-        if (ownerType != null) {\n-          // Only declare this as an official property if it has not been\n-          // declared yet.\n-          boolean isExtern = t.getInput().isExtern();\n-          if ((!ownerType.hasOwnProperty(propName) ||\n-               ownerType.isPropertyTypeInferred(propName)) &&\n-              ((isExtern && !ownerType.isNativeObjectType()) ||\n-               !ownerType.isInstanceType())) {\n-            // If the property is undeclared or inferred, declare it now.\n-            ownerType.defineDeclaredProperty(propName, valueType, isExtern);\n-          }\n-        }\n-\n-        // If the property is already declared, the error will be\n-        // caught when we try to declare it in the current scope.\n-        defineSlot(n, parent, valueType, inferred);\n-      } else if (rhsValue != null &&\n-          rhsValue.getType() == Token.TRUE) {\n-        // We declare these for delegate proxy method properties.\n-        ObjectType ownerType = getObjectSlot(ownerName);\n-        if (ownerType instanceof FunctionType) {\n-          JSType ownerTypeOfThis = ((FunctionType) ownerType).getTypeOfThis();\n-          String delegateName = codingConvention.getDelegateSuperclassName();\n-          JSType delegateType = delegateName == null ?\n-              null : typeRegistry.getType(delegateName);\n-          if (delegateType != null &&\n-              ownerTypeOfThis.isSubtype(delegateType)) {\n-            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE),\n-                true);\n-          }\n-        }\n-      }\n-    }\n-\n-    /**\n-     * Find the ObjectType associated with the given slot.\n-     * @param slotName The name of the slot to find the type in.\n-     * @return An object type, or null if this slot does not contain an object.\n-     */\n-    private ObjectType getObjectSlot(String slotName) {\n-      Var ownerVar = scope.getVar(slotName);\n-      if (ownerVar != null) {\n-        JSType ownerVarType = ownerVar.getType();\n-        return ObjectType.cast(ownerVarType == null ?\n-            null : ownerVarType.restrictByNotNullOrUndefined());\n-      }\n-      return null;\n-    }\n-\n-    /**\n-     * Look for a type declaration on a GETPROP node.\n-     *\n-     * @param info The doc info for this property.\n-     * @param n A top-level GETPROP node (it should not be contained inside\n-     *     another GETPROP).\n-     * @param rhsValue The node that {@code n} is being initialized to,\n-     *     or {@code null} if this is a stub declaration.\n-     */\n-    private JSType getDeclaredGetPropType(NodeTraversal t, JSDocInfo info,\n-        Node n, Node rhsValue) {\n-      if (info != null && info.hasType()) {\n-        return getDeclaredTypeInAnnotation(t, n, info);\n-      } else if (info != null && info.hasEnumParameterType()) {\n-        return n.getJSType();\n-      } else if (rhsValue != null &&\n-          rhsValue.getType() == Token.FUNCTION) {\n-        return rhsValue.getJSType();\n-      } else {\n-        return getDeclaredTypeInAnnotation(t, n, info);\n-      }\n-    }\n-\n-    /**\n-     * Resolve any stub delcarations to unknown types if we could not\n-     * find types for them during traversal.\n-     */\n-    private void resolveStubDeclarations() {\n-      for (StubDeclaration stub : stubDeclarations) {\n-        Node n = stub.node;\n-        Node parent = n.getParent();\n-        String qName = n.getQualifiedName();\n-        String propName = n.getLastChild().getString();\n-        String ownerName = stub.ownerName;\n-        boolean isExtern = stub.isExtern;\n-\n-        if (scope.isDeclared(qName, false)) {\n-          continue;\n-        }\n-\n-        // If we see a stub property, make sure to register this property\n-        // in the type registry.\n-        ObjectType ownerType = getObjectSlot(ownerName);\n-        ObjectType unknownType = typeRegistry.getNativeObjectType(UNKNOWN_TYPE);\n-        defineSlot(n, parent, unknownType, true);\n-\n-        if (ownerType != null &&\n-            (isExtern || ownerType.isFunctionPrototypeType())) {\n-          // If this is a stub for a prototype, just declare it\n-          // as an unknown type. These are seen often in externs.\n-          ownerType.defineInferredProperty(\n-              propName, unknownType, isExtern);\n-        } else {\n-          typeRegistry.registerPropertyOnType(\n-              propName, ownerType == null ? unknownType : ownerType);\n-        }\n-      }\n-    }\n-\n-    /**\n-     * A stub declaration without any type information.\n-     */\n-    private final class StubDeclaration {\n-      private final Node node;\n-      private final boolean isExtern;\n-      private final String ownerName;\n-\n-      private StubDeclaration(Node node, boolean isExtern, String ownerName) {\n-        this.node = node;\n-        this.isExtern = isExtern;\n-        this.ownerName = ownerName;\n-      }\n-    }\n-\n-    /**\n-     * Collects all declared properties in a function, and\n-     * resolves them relative to the global scope.\n-     */\n-    private final class CollectProperties\n-        extends AbstractShallowCallback {\n-      private final ObjectType thisType;\n-\n-      CollectProperties(ObjectType thisType) {\n-        this.thisType = thisType;\n-      }\n-\n-      public void visit(NodeTraversal t, Node n, Node parent) {\n-        if (parent != null && parent.getType() == Token.EXPR_RESULT) {\n-          switch (n.getType()) {\n-            case Token.ASSIGN:\n-              maybeCollectMember(t, n.getFirstChild(), n);\n-              break;\n-            case Token.GETPROP:\n-              maybeCollectMember(t, n, n);\n-              break;\n-          }\n-        }\n-      }\n-\n-      private void maybeCollectMember(NodeTraversal t,\n-          Node member, Node nodeWithJsDocInfo) {\n-        JSDocInfo info = nodeWithJsDocInfo.getJSDocInfo();\n-\n-        // Do nothing if there is no JSDoc type info, or\n-        // if the node is not a member expression, or\n-        // if the member expression is not of the form: this.someProperty.\n-        if (info == null ||\n-            member.getType() != Token.GETPROP ||\n-            member.getFirstChild().getType() != Token.THIS) {\n-          return;\n-        }\n-\n-        member.getFirstChild().setJSType(thisType);\n-        JSType jsType = getDeclaredTypeInAnnotation(t, member, info);\n-        Node name = member.getLastChild();\n-        if (jsType != null &&\n-            (name.getType() == Token.NAME || name.getType() == Token.STRING)) {\n-          thisType.defineDeclaredProperty(\n-              name.getString(),\n-              jsType,\n-              false /* functions with implementations are not in externs */);\n-        }\n-      }\n-    } // end CollectProperties\n   } // end GlobalScopeBuilder\n \n   /**\n@@ -1425,24 +1448,7 @@\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          // VARs and ASSIGNs are handled separately.\n-          if (parent.getType() == Token.NAME) {\n-            return;\n-          }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+      super.visit(t, n, parent);\n     }\n \n     /** Handle bleeding functions and function parameters. */\n\n"
    },
    "Closure-52": {
        "Buggy Function": "  static boolean isSimpleNumber(String s) {\n    int len = s.length();\n    for (int index = 0; index < len; index++) {\n      char c = s.charAt(index);\n      if (c < '0' || c > '9') {\n        return false;\n      }\n    }\n    return len > 0;\n  }",
        "Inducing Changes": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex 668fe51..593ec05 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -60,6 +60,13 @@\n     this(consumer, null);\n   }\n \n+  /**\n+   * Insert a ECMASCRIPT 5 strict annotation.\n+   */\n+  public void tagAsStrict() {\n+    add(\"'use strict';\");\n+  }\n+\n   void add(String str) {\n     cc.add(str);\n   }\n@@ -196,7 +203,7 @@\n \n       case Token.ARRAYLIT:\n         add(\"[\");\n-        addArrayList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n+        addArrayList(first);\n         add(\"]\");\n         break;\n \n@@ -333,13 +340,20 @@\n         Node body = fn.getLastChild();\n \n         // Add the property name.\n-        if (TokenStream.isJSIdentifier(name) &&\n+        if (!n.isQuotedString() &&\n+            TokenStream.isJSIdentifier(name) &&\n             // do not encode literally any non-literal characters that were\n             // unicode escaped.\n             NodeUtil.isLatin(name)) {\n           add(name);\n         } else {\n-          add(jsString(n.getString(), outputCharsetEncoder));\n+          // Determine if the string is a simple number.\n+          double d = getSimpleNumber(name);\n+          if (!Double.isNaN(d)) {\n+            cc.addNumber(d);\n+          } else {\n+            add(jsString(n.getString(), outputCharsetEncoder));\n+          }\n         }\n \n         add(parameters);\n@@ -643,18 +657,25 @@\n           if (c.getType() == Token.GET || c.getType() == Token.SET) {\n             add(c);\n           } else {\n-            // Object literal property names don't have to be quoted if they are\n-            // not JavaScript keywords\n-            if (c.getType() == Token.STRING &&\n-                !c.isQuotedString() &&\n-                !TokenStream.isKeyword(c.getString()) &&\n-                TokenStream.isJSIdentifier(c.getString()) &&\n-                // do not encode literally any non-literal characters that were\n-                // unicode escaped.\n-                NodeUtil.isLatin(c.getString())) {\n-              add(c.getString());\n+            Preconditions.checkState(c.getType() == Token.STRING);\n+            String key = c.getString();\n+            // Object literal property names don't have to be quoted if they\n+            // are not JavaScript keywords\n+            if (!c.isQuotedString() &&\n+                !TokenStream.isKeyword(key) &&\n+                TokenStream.isJSIdentifier(key) &&\n+                // do not encode literally any non-literal characters that\n+                // were unicode escaped.\n+                NodeUtil.isLatin(key)) {\n+              add(key);\n             } else {\n-              addExpr(c, 1);\n+              // Determine if the string is a simple number.\n+              double d = getSimpleNumber(key);\n+              if (!Double.isNaN(d)) {\n+                cc.addNumber(d);\n+              } else {\n+                addExpr(c, 1);\n+              }\n             }\n             add(\":\");\n             addExpr(c.getFirstChild(), 1);\n@@ -712,6 +733,27 @@\n     cc.endSourceMapping(n);\n   }\n \n+  static boolean isSimpleNumber(String s) {\n+    int len = s.length();\n+    for (int index = 0; index < len; index++) {\n+      char c = s.charAt(index);\n+      if (c < '0' || c > '9') {\n+        return false;\n+      }\n+    }\n+    return len > 0;\n+  }\n+\n+  static double getSimpleNumber(String s) {\n+    if (isSimpleNumber(s)) {\n+      long l = Long.parseLong(s);\n+      if (l < NodeUtil.MAX_POSITIVE_INTEGER_NUMBER) {\n+        return l;\n+      }\n+    }\n+    return Double.NaN;\n+  }\n+\n   /**\n    * @return Whether the name is an indirect eval.\n    */\n@@ -868,27 +910,19 @@\n    * slot.\n    * @param firstInList The first in the node list (chained through the next\n    * property).\n-   * @param skipIndexes If not null, then the array of skipped entries in the\n-   * array.\n    */\n-  void addArrayList(Node firstInList, int[] skipIndexes) {\n-    int nextSlot = 0;\n-    int nextSkipSlot = 0;\n+  void addArrayList(Node firstInList) {\n+    boolean lastWasEmpty = false;\n     for (Node n = firstInList; n != null; n = n.getNext()) {\n-      while (skipIndexes != null && nextSkipSlot < skipIndexes.length) {\n-        if (nextSlot == skipIndexes[nextSkipSlot]) {\n-          cc.listSeparator();\n-          nextSlot++;\n-          nextSkipSlot++;\n-        } else {\n-          break;\n-        }\n-      }\n       if (n != firstInList) {\n         cc.listSeparator();\n       }\n       addExpr(n, 1);\n-      nextSlot++;\n+      lastWasEmpty = n.getType() == Token.EMPTY;\n+    }\n+\n+    if (lastWasEmpty) {\n+      cc.listSeparator();\n     }\n   }\n \n@@ -964,6 +998,7 @@\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n+        case '\\0': sb.append(\"\\\\0\"); break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n\n"
    },
    "Closure-59": {
        "Buggy Function": "  public void initOptions(CompilerOptions options) {\n    this.options = options;\n    if (errorManager == null) {\n      if (outStream == null) {\n        setErrorManager(\n            new LoggerErrorManager(createMessageFormatter(), logger));\n      } else {\n        PrintStreamErrorManager printer =\n            new PrintStreamErrorManager(createMessageFormatter(), outStream);\n        printer.setSummaryDetailLevel(options.summaryDetailLevel);\n        setErrorManager(printer);\n      }\n    }\n\n    // DiagnosticGroups override the plain checkTypes option.\n    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = true;\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = false;\n    } else if (!options.checkTypes) {\n      // If DiagnosticGroups did not override the plain checkTypes\n      // option, and checkTypes is enabled, then turn off the\n      // parser type warnings.\n      options.setWarningLevel(\n          DiagnosticGroup.forType(\n              RhinoErrorReporter.TYPE_PARSE_ERROR),\n          CheckLevel.OFF);\n    }\n\n    if (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n\n    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n      options.setWarningLevel(\n          DiagnosticGroups.ES5_STRICT,\n          CheckLevel.ERROR);\n    }\n\n    // Initialize the warnings guard.\n    List<WarningsGuard> guards = Lists.newArrayList();\n    guards.add(\n        new SuppressDocWarningsGuard(\n            getDiagnosticGroups().getRegisteredGroups()));\n    guards.add(options.getWarningsGuard());\n\n    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n\n    // All passes must run the variable check. This synthesizes\n    // variables later so that the compiler doesn't crash. It also\n    // checks the externs file for validity. If you don't want to warn\n    // about missing variable declarations, we shut that specific\n    // error off.\n    if (!options.checkSymbols &&\n        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\n          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n    }\n\n    this.warningsGuard = composedGuards;\n  }",
        "Inducing Changes": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex 30215f4..533ddac 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -232,6 +232,27 @@\n       }\n     }\n \n+    // DiagnosticGroups override the plain checkTypes option.\n+    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n+      options.checkTypes = true;\n+    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n+      options.checkTypes = false;\n+    } else if (!options.checkTypes) {\n+      // If DiagnosticGroups did not override the plain checkTypes\n+      // option, and checkTypes is enabled, then turn off the\n+      // parser type warnings.\n+      options.setWarningLevel(\n+          DiagnosticGroup.forType(\n+              RhinoErrorReporter.TYPE_PARSE_ERROR),\n+          CheckLevel.OFF);\n+    }\n+\n+    if (options.checkGlobalThisLevel.isOn()) {\n+      options.setWarningLevel(\n+          DiagnosticGroups.GLOBAL_THIS,\n+          options.checkGlobalThisLevel);\n+    }\n+\n     // Initialize the warnings guard.\n     List<WarningsGuard> guards = Lists.newArrayList();\n     guards.add(\n@@ -253,6 +274,7 @@\n       guards.add(new DiagnosticGroupWarningsGuard(\n           DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n     }\n+\n     this.warningsGuard = new ComposeWarningsGuard(guards);\n   }\n \n@@ -1427,6 +1449,9 @@\n     builder.setLineBreak(options.lineBreak);\n     builder.setSourceMap(sourceMap);\n     builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\n+    builder.setTagAsStrict(\n+        options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);\n+    builder.setLineLengthThreshold(options.lineLengthThreshold);\n \n     Charset charset = options.outputCharset != null ?\n         Charset.forName(options.outputCharset) : null;\n@@ -1627,7 +1652,11 @@\n \n   @Override\n   public boolean acceptEcmaScript5() {\n-    return options.languageIn == LanguageMode.ECMASCRIPT5;\n+    return options.getLanguageIn() == LanguageMode.ECMASCRIPT5;\n+  }\n+\n+  public LanguageMode languageMode() {\n+    return options.getLanguageIn();\n   }\n \n   @Override\n@@ -1639,13 +1668,16 @@\n   Config getParserConfig() {\n     if (parserConfig == null) {\n       Config.LanguageMode mode;\n-      switch (options.languageIn) {\n+      switch (options.getLanguageIn()) {\n         case ECMASCRIPT3:\n           mode = Config.LanguageMode.ECMASCRIPT3;\n           break;\n         case ECMASCRIPT5:\n           mode = Config.LanguageMode.ECMASCRIPT5;\n           break;\n+        case ECMASCRIPT5_STRICT:\n+          mode = Config.LanguageMode.ECMASCRIPT5_STRICT;\n+          break;\n         default:\n           throw new IllegalStateException(\"unexpected language mode\");\n       }\n\n"
    },
    "Closure-60": {
        "Buggy Function": "static TernaryValue getImpureBooleanValue(Node n) {\nswitch (n.getType()) {\n  case Token.ASSIGN:\n  case Token.COMMA:\n    // For ASSIGN and COMMA the value is the value of the RHS.\n    return getImpureBooleanValue(n.getLastChild());\n  case Token.NOT:\n    TernaryValue value = getImpureBooleanValue(n.getLastChild());\n    return value.not();\n  case Token.AND: {\n    TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n    TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n    return lhs.and(rhs);\n  }\n  case Token.OR:  {\n    TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n    TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n    return lhs.or(rhs);\n  }\n  case Token.HOOK:  {\n    TernaryValue trueValue = getImpureBooleanValue(\n        n.getFirstChild().getNext());\n    TernaryValue falseValue = getImpureBooleanValue(n.getLastChild());\n    if (trueValue.equals(falseValue)) {\n      return trueValue;\n    } else {\n      return TernaryValue.UNKNOWN;\n    }\n  }\n  case Token.ARRAYLIT:\n  case Token.OBJECTLIT:\n    // ignoring side-effects\n    return TernaryValue.TRUE;\n\n  default:\n    return getPureBooleanValue(n);\n}\n}\n\nstatic TernaryValue getPureBooleanValue(Node n) {\nswitch (n.getType()) {\n  case Token.STRING:\n    return TernaryValue.forBoolean(n.getString().length() > 0);\n\n  case Token.NUMBER:\n    return TernaryValue.forBoolean(n.getDouble() != 0);\n\n  case Token.NOT:\n    return getPureBooleanValue(n.getLastChild()).not();\n\n  case Token.NULL:\n  case Token.FALSE:\n  case Token.VOID:\n    return TernaryValue.FALSE;\n\n  case Token.NAME:\n    String name = n.getString();\n    if (\"undefined\".equals(name)\n        || \"NaN\".equals(name)) {\n      // We assume here that programs don't change the value of the keyword\n      // undefined to something other than the value undefined.\n      return TernaryValue.FALSE;\n    } else if (\"Infinity\".equals(name)) {\n      return TernaryValue.TRUE;\n    }\n    break;\n\n  case Token.TRUE:\n  case Token.REGEXP:\n    return TernaryValue.TRUE;\n\n  case Token.ARRAYLIT:\n  case Token.OBJECTLIT:\n    if (!mayHaveSideEffects(n)) {\n      return TernaryValue.TRUE;\n    }\n}\n\nreturn TernaryValue.UNKNOWN;\n}",
        "Inducing Changes": "diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex 64f4c90..1677ed6 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -632,6 +632,14 @@\n   }\n \n   /**\n+   * @return Whether the call has a local result.\n+   */\n+  static boolean callHasLocalResult(Node n) {\n+    Preconditions.checkState(n.getType() == Token.CALL);\n+    return (n.getSideEffectFlags() & Node.FLAG_LOCAL_RESULTS) > 0;\n+  }\n+\n+  /**\n    * Returns true if the current node's type implies side effects.\n    *\n    * This is a non-recursive version of the may have side effects\n\n"
    },
    "Closure-61": {
        "Buggy Function": "  static boolean functionCallHasSideEffects(\n      Node callNode, @Nullable AbstractCompiler compiler) {\n    if (callNode.getType() != Token.CALL) {\n      throw new IllegalStateException(\n          \"Expected CALL node, got \" + Token.name(callNode.getType()));\n    }\n\n    if (callNode.isNoSideEffectsCall()) {\n      return false;\n    }\n\n    Node nameNode = callNode.getFirstChild();\n\n    // Built-in functions with no side effects.\n    if (nameNode.getType() == Token.NAME) {\n      String name = nameNode.getString();\n      if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n        return false;\n      }\n    } else if (nameNode.getType() == Token.GETPROP) {\n      if (callNode.hasOneChild()\n          && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(\n                nameNode.getLastChild().getString())) {\n        return false;\n      }\n\n      if (callNode.isOnlyModifiesThisCall()\n          && evaluatesToLocalValue(nameNode.getFirstChild())) {\n        return false;\n      }\n\n      // Functions in the \"Math\" namespace have no side effects.\n\n      if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n        if (nameNode.getFirstChild().getType() == Token.REGEXP\n            && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n          return false;\n        } else if (nameNode.getFirstChild().getType() == Token.STRING\n            && STRING_REGEXP_METHODS.contains(\n                nameNode.getLastChild().getString())) {\n          Node param = nameNode.getNext();\n          if (param != null &&\n              (param.getType() == Token.STRING\n                  || param.getType() == Token.REGEXP))\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }",
        "Inducing Changes": "diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex f9ce42e..3634939 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -954,14 +954,6 @@\n         return false;\n       }\n \n-      // Functions in the \"Math\" namespace have no side effects.\n-      if (nameNode.getFirstChild().getType() == Token.NAME) {\n-        String namespaceName = nameNode.getFirstChild().getString();\n-        if (namespaceName.equals(\"Math\")) {\n-          return false;\n-        }\n-      }\n-\n       if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n         if (nameNode.getFirstChild().getType() == Token.REGEXP\n             && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n\n"
    },
    "Closure-62": {
        "Buggy Function": "  private String format(JSError error, boolean warning) {\n    // extract source excerpt\n    SourceExcerptProvider source = getSource();\n    String sourceExcerpt = source == null ? null :\n        excerpt.get(\n            source, error.sourceName, error.lineNumber, excerptFormatter);\n\n    // formatting the message\n    StringBuilder b = new StringBuilder();\n    if (error.sourceName != null) {\n      b.append(error.sourceName);\n      if (error.lineNumber > 0) {\n        b.append(':');\n        b.append(error.lineNumber);\n      }\n      b.append(\": \");\n    }\n\n    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n    b.append(\" - \");\n\n    b.append(error.description);\n    b.append('\\n');\n    if (sourceExcerpt != null) {\n      b.append(sourceExcerpt);\n      b.append('\\n');\n      int charno = error.getCharno();\n\n      // padding equal to the excerpt and arrow at the end\n      // charno == sourceExpert.length() means something is missing\n      // at the end of the line\n      if (excerpt.equals(LINE)\n          && 0 <= charno && charno < sourceExcerpt.length()) {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }\n    }\n    return b.toString();\n  }",
        "Inducing Changes": "diff --git a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\nindex 420dbc0..f529b7d 100644\n--- a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n+++ b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n@@ -92,10 +92,8 @@\n       int charno = error.getCharno();\n \n       // padding equal to the excerpt and arrow at the end\n-      // charno == sourceExpert.length() means something is missing\n-      // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno <= sourceExcerpt.length()) {\n+          && 0 <= charno && charno < sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n\n"
    },
    "Closure-64": {
        "Buggy Function": "public void toSource(final CodeBuilder cb,\n                   final int inputSeqNum,\n                   final Node root) {\nrunInCompilerThread(new Callable<Void>() {\n  public Void call() throws Exception {\n    if (options.printInputDelimiter) {\n      if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n        cb.append(\"\\n\");  // Make sure that the label starts on a new line\n      }\n      Preconditions.checkState(root.getType() == Token.SCRIPT);\n\n      String delimiter = options.inputDelimiter;\n\n      String sourceName = (String)root.getProp(Node.SOURCENAME_PROP);\n      Preconditions.checkState(sourceName != null);\n      Preconditions.checkState(!sourceName.isEmpty());\n\n      delimiter = delimiter.replaceAll(\"%name%\", sourceName)\n        .replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n\n      cb.append(delimiter)\n        .append(\"\\n\");\n    }\n    if (root.getJSDocInfo() != null &&\n        root.getJSDocInfo().getLicense() != null) {\n      cb.append(\"/*\\n\")\n        .append(root.getJSDocInfo().getLicense())\n        .append(\"*/\\n\");\n    }\n\n    // If there is a valid source map, then indicate to it that the current\n    // root node's mappings are offset by the given string builder buffer.\n    if (options.sourceMapOutputPath != null) {\n      sourceMap.setStartingPosition(\n          cb.getLineIndex(), cb.getColumnIndex());\n    }\n\n    String code = toSource(root, sourceMap);\n    if (!code.isEmpty()) {\n      cb.append(code);\n\n      // In order to avoid parse ambiguity when files are concatenated\n      // together, all files should end in a semi-colon. Do a quick\n      // heuristic check if there's an obvious semi-colon already there.\n      int length = code.length();\n      char lastChar = code.charAt(length - 1);\n      char secondLastChar = length >= 2 ?\n          code.charAt(length - 2) : '\\0';\n      boolean hasSemiColon = lastChar == ';' ||\n          (lastChar == '\\n' && secondLastChar == ';');\n      if (!hasSemiColon) {\n        cb.append(\";\");\n      }\n    }\n    return null;\n  }\n});\n}\n@Override\nString toSource(Node n) {\ninitCompilerOptionsIfTesting();\nreturn toSource(n, null);\n}\nprivate String toSource(Node n, SourceMap sourceMap) {\nCodePrinter.Builder builder = new CodePrinter.Builder(n);\nbuilder.setPrettyPrint(options.prettyPrint);\nbuilder.setLineBreak(options.lineBreak);\nbuilder.setSourceMap(sourceMap);\nbuilder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\nbuilder.setTagAsStrict(\n    options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);\nbuilder.setLineLengthThreshold(options.lineLengthThreshold);\n\nCharset charset = options.outputCharset != null ?\n    Charset.forName(options.outputCharset) : null;\nbuilder.setOutputCharset(charset);\n\nreturn builder.build();\n}",
        "Inducing Changes": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex 21adb25..c8e1da8 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -1443,6 +1443,8 @@\n     builder.setLineBreak(options.lineBreak);\n     builder.setSourceMap(sourceMap);\n     builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\n+    builder.setTagAsStrict(\n+        options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);\n \n     Charset charset = options.outputCharset != null ?\n         Charset.forName(options.outputCharset) : null;\n@@ -1643,11 +1645,11 @@\n \n   @Override\n   public boolean acceptEcmaScript5() {\n-    return options.languageIn == LanguageMode.ECMASCRIPT5;\n+    return options.getLanguageIn() == LanguageMode.ECMASCRIPT5;\n   }\n \n-  public LanguageMode LanguageMode() {\n-    return options.languageIn;\n+  public LanguageMode languageMode() {\n+    return options.getLanguageIn();\n   }\n \n   @Override\n@@ -1659,7 +1661,7 @@\n   Config getParserConfig() {\n     if (parserConfig == null) {\n       Config.LanguageMode mode;\n-      switch (options.languageIn) {\n+      switch (options.getLanguageIn()) {\n         case ECMASCRIPT3:\n           mode = Config.LanguageMode.ECMASCRIPT3;\n           break;\n\n"
    },
    "Closure-65": {
        "Buggy Function": "  static String strEscape(String s, char quote,\n                          String doublequoteEscape,\n                          String singlequoteEscape,\n                          String backslashEscape,\n                          CharsetEncoder outputCharsetEncoder) {\n    StringBuilder sb = new StringBuilder(s.length() + 2);\n    sb.append(quote);\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      switch (c) {\n        case '\\0': sb.append(\"\\\\0\"); break;\n        case '\\n': sb.append(\"\\\\n\"); break;\n        case '\\r': sb.append(\"\\\\r\"); break;\n        case '\\t': sb.append(\"\\\\t\"); break;\n        case '\\\\': sb.append(backslashEscape); break;\n        case '\\\"': sb.append(doublequoteEscape); break;\n        case '\\'': sb.append(singlequoteEscape); break;\n        case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n          if (i >= 2 &&\n              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n            sb.append(\"\\\\>\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        case '<':\n          // Break </script into <\\/script\n          final String END_SCRIPT = \"/script\";\n\n          // Break <!-- into <\\!--\n          final String START_COMMENT = \"!--\";\n\n          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                              END_SCRIPT.length())) {\n            sb.append(\"<\\\\\");\n          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                     START_COMMENT.length())) {\n            sb.append(\"<\\\\\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        default:\n          // If we're given an outputCharsetEncoder, then check if the\n          //  character can be represented in this character set.\n          if (outputCharsetEncoder != null) {\n            if (outputCharsetEncoder.canEncode(c)) {\n              sb.append(c);\n            } else {\n              // Unicode-escape the character.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          } else {\n            // No charsetEncoder provided - pass straight latin characters\n            // through, and escape the rest.  Doing the explicit character\n            // check is measurably faster than using the CharsetEncoder.\n            if (c > 0x1f && c < 0x7f) {\n              sb.append(c);\n            } else {\n              // Other characters can be misinterpreted by some js parsers,\n              // or perhaps mangled by proxies along the way,\n              // so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          }\n      }\n    }\n    sb.append(quote);\n    return sb.toString();\n  }",
        "Inducing Changes": "Add Whole Class File of buggy method"
    },
    "Closure-66": {
        "Buggy Function": "  public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    // To be explicitly set to false if the node is not typeable.\n    boolean typeable = true;\n\n    switch (n.getType()) {\n      case Token.NAME:\n        typeable = visitName(t, n, parent);\n        break;\n\n      case Token.LP:\n        // If this is under a FUNCTION node, it is a parameter list and can be\n        // ignored here.\n        if (parent.getType() != Token.FUNCTION) {\n          ensureTyped(t, n, getJSType(n.getFirstChild()));\n        } else {\n          typeable = false;\n        }\n        break;\n\n      case Token.COMMA:\n        ensureTyped(t, n, getJSType(n.getLastChild()));\n        break;\n\n      case Token.TRUE:\n      case Token.FALSE:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.THIS:\n        ensureTyped(t, n, t.getScope().getTypeOfThis());\n        break;\n\n      case Token.REF_SPECIAL:\n        ensureTyped(t, n);\n        break;\n\n      case Token.GET_REF:\n        ensureTyped(t, n, getJSType(n.getFirstChild()));\n        break;\n\n      case Token.NULL:\n        ensureTyped(t, n, NULL_TYPE);\n        break;\n\n      case Token.NUMBER:\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.STRING:\n        // Object literal keys are handled with OBJECTLIT\n        if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n          ensureTyped(t, n, STRING_TYPE);\n          // Object literal keys are not typeable\n        }\n        break;\n\n      case Token.GET:\n      case Token.SET:\n        // Object literal keys are handled with OBJECTLIT\n        break;\n\n      case Token.ARRAYLIT:\n        ensureTyped(t, n, ARRAY_TYPE);\n        break;\n\n      case Token.REGEXP:\n        ensureTyped(t, n, REGEXP_TYPE);\n        break;\n\n      case Token.GETPROP:\n        visitGetProp(t, n, parent);\n        typeable = !(parent.getType() == Token.ASSIGN &&\n                     parent.getFirstChild() == n);\n        break;\n\n      case Token.GETELEM:\n        visitGetElem(t, n);\n        // The type of GETELEM is always unknown, so no point counting that.\n        // If that unknown leaks elsewhere (say by an assignment to another\n        // variable), then it will be counted.\n        typeable = false;\n        break;\n\n      case Token.VAR:\n        visitVar(t, n);\n        typeable = false;\n        break;\n\n      case Token.NEW:\n        visitNew(t, n);\n        typeable = true;\n        break;\n\n      case Token.CALL:\n        visitCall(t, n);\n        typeable = !NodeUtil.isExpressionNode(parent);\n        break;\n\n      case Token.RETURN:\n        visitReturn(t, n);\n        typeable = false;\n        break;\n\n      case Token.DEC:\n      case Token.INC:\n        left = n.getFirstChild();\n        validator.expectNumber(\n            t, left, getJSType(left), \"increment/decrement\");\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.NOT:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.VOID:\n        ensureTyped(t, n, VOID_TYPE);\n        break;\n\n      case Token.TYPEOF:\n        ensureTyped(t, n, STRING_TYPE);\n        break;\n\n      case Token.BITNOT:\n        childType = getJSType(n.getFirstChild());\n        if (!childType.matchesInt32Context()) {\n          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),\n              childType.toString());\n        }\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.POS:\n      case Token.NEG:\n        left = n.getFirstChild();\n        validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.EQ:\n      case Token.NE: {\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n        TernaryValue result =\n            leftTypeRestricted.testForEquality(rightTypeRestricted);\n        if (result != TernaryValue.UNKNOWN) {\n          if (n.getType() == Token.NE) {\n            result = result.not();\n          }\n          report(t, n, DETERMINISTIC_TEST, leftType.toString(),\n              rightType.toString(), result.toString());\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n      }\n\n      case Token.SHEQ:\n      case Token.SHNE: {\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n        if (!leftTypeRestricted.canTestForShallowEqualityWith(\n                rightTypeRestricted)) {\n          report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),\n              rightType.toString());\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n      }\n\n      case Token.LT:\n      case Token.LE:\n      case Token.GT:\n      case Token.GE:\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n        if (rightType.isNumber()) {\n          validator.expectNumber(\n              t, n, leftType, \"left side of numeric comparison\");\n        } else if (leftType.isNumber()) {\n          validator.expectNumber(\n              t, n, rightType, \"right side of numeric comparison\");\n        } else if (leftType.matchesNumberContext() &&\n                   rightType.matchesNumberContext()) {\n          // OK.\n        } else {\n          // Whether the comparison is numeric will be determined at runtime\n          // each time the expression is evaluated. Regardless, both operands\n          // should match a string context.\n          String message = \"left side of comparison\";\n          validator.expectString(t, n, leftType, message);\n          validator.expectNotNullOrUndefined(\n              t, n, leftType, message, getNativeType(STRING_TYPE));\n          message = \"right side of comparison\";\n          validator.expectString(t, n, rightType, message);\n          validator.expectNotNullOrUndefined(\n              t, n, rightType, message, getNativeType(STRING_TYPE));\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.IN:\n        left = n.getFirstChild();\n        right = n.getLastChild();\n        leftType = getJSType(left);\n        rightType = getJSType(right);\n        validator.expectObject(t, n, rightType, \"'in' requires an object\");\n        validator.expectString(t, left, leftType, \"left side of 'in'\");\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.INSTANCEOF:\n        left = n.getFirstChild();\n        right = n.getLastChild();\n        leftType = getJSType(left);\n        rightType = getJSType(right).restrictByNotNullOrUndefined();\n\n        validator.expectAnyObject(\n            t, left, leftType, \"deterministic instanceof yields false\");\n        validator.expectActualObject(\n            t, right, rightType, \"instanceof requires an object\");\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.ASSIGN:\n        visitAssign(t, n);\n        typeable = false;\n        break;\n\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_MUL:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n      case Token.DIV:\n      case Token.MOD:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n      case Token.SUB:\n      case Token.ADD:\n      case Token.MUL:\n        visitBinaryOperator(n.getType(), t, n);\n        break;\n\n      case Token.DELPROP:\n        if (!isReference(n.getFirstChild())) {\n          report(t, n, BAD_DELETE);\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.CASE:\n        JSType switchType = getJSType(parent.getFirstChild());\n        JSType caseType = getJSType(n.getFirstChild());\n        validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n        typeable = false;\n        break;\n\n      case Token.WITH: {\n        Node child = n.getFirstChild();\n        childType = getJSType(child);\n        validator.expectObject(\n            t, child, childType, \"with requires an object\");\n        typeable = false;\n        break;\n      }\n\n      case Token.FUNCTION:\n        visitFunction(t, n);\n        break;\n\n      // These nodes have no interesting type behavior.\n      case Token.LABEL:\n      case Token.LABEL_NAME:\n      case Token.SWITCH:\n      case Token.BREAK:\n      case Token.CATCH:\n      case Token.TRY:\n      case Token.SCRIPT:\n      case Token.EXPR_RESULT:\n      case Token.BLOCK:\n      case Token.EMPTY:\n      case Token.DEFAULT:\n      case Token.CONTINUE:\n      case Token.DEBUGGER:\n      case Token.THROW:\n        typeable = false;\n        break;\n\n      // These nodes require data flow analysis.\n      case Token.DO:\n      case Token.FOR:\n      case Token.IF:\n      case Token.WHILE:\n        typeable = false;\n        break;\n\n      // These nodes are typed during the type inference.\n      case Token.AND:\n      case Token.HOOK:\n      case Token.OBJECTLIT:\n      case Token.OR:\n        if (n.getJSType() != null) { // If we didn't run type inference.\n          ensureTyped(t, n);\n        } else {\n          // If this is an enum, then give that type to the objectlit as well.\n          if ((n.getType() == Token.OBJECTLIT)\n              && (parent.getJSType() instanceof EnumType)) {\n            ensureTyped(t, n, parent.getJSType());\n          } else {\n            ensureTyped(t, n);\n          }\n        }\n        if (n.getType() == Token.OBJECTLIT) {\n          for (Node key : n.children()) {\n            visitObjLitKey(t, key, n);\n          }\n        }\n        break;\n\n      default:\n        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n        ensureTyped(t, n);\n        break;\n    }\n\n    // Don't count externs since the user's code may not even use that part.\n    typeable = typeable && !inExterns;\n\n    if (typeable) {\n      doPercentTypedAccounting(t, n);\n    }\n\n    checkNoTypeCheckSection(n, false);\n  }",
        "Inducing Changes": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex 8198efc..5760f79 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2006 Google Inc.\n+ * Copyright 2006 The Closure Compiler Authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -48,9 +48,6 @@\n  * <p>Checks the types of JS expressions against any declared type\n  * information.</p>\n  *\n- *\n- *\n- * @author nicksantos@google.com (Nick Santos)\n  */\n public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n \n@@ -249,7 +246,12 @@\n       UNKNOWN_EXPR_TYPE,\n       UNRESOLVED_TYPE,\n       WRONG_ARGUMENT_COUNT,\n-      ILLEGAL_IMPLICIT_CAST);\n+      ILLEGAL_IMPLICIT_CAST,\n+      TypedScopeCreator.UNKNOWN_LENDS,\n+      TypedScopeCreator.LENDS_ON_NON_OBJECT,\n+      TypedScopeCreator.CTOR_INITIALIZER,\n+      TypedScopeCreator.IFACE_INITIALIZER,\n+      FunctionTypeBuilder.THIS_TYPE_NON_OBJECT);\n \n   private final AbstractCompiler compiler;\n   private final TypeValidator validator;\n@@ -490,25 +492,28 @@\n         break;\n \n       case Token.NUMBER:\n-        if (n.getParent().getType() != Token.OBJECTLIT) {\n+        // Object literal keys are handled with OBJECTLIT\n+        if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n           ensureTyped(t, n, NUMBER_TYPE);\n-        } else {\n-          typeable = false;\n         }\n         break;\n \n+      case Token.STRING:\n+        // Object literal keys are handled with OBJECTLIT\n+        if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n+          ensureTyped(t, n, STRING_TYPE);\n+        }\n+        break;\n+\n+      case Token.GET:\n+      case Token.SET:\n+        // Object literal keys are handled with OBJECTLIT\n+        break;\n+\n       case Token.ARRAYLIT:\n         ensureTyped(t, n, ARRAY_TYPE);\n         break;\n \n-      case Token.STRING:\n-        if (n.getParent().getType() != Token.OBJECTLIT) {\n-          ensureTyped(t, n, STRING_TYPE);\n-        } else {\n-          typeable = false;\n-        }\n-        break;\n-\n       case Token.REGEXP:\n         ensureTyped(t, n, REGEXP_TYPE);\n         break;\n@@ -640,11 +645,11 @@\n           // should match a string context.\n           String message = \"left side of comparison\";\n           validator.expectString(t, n, leftType, message);\n-          validator.expectNotVoid(\n+          validator.expectNotNullOrUndefined(\n               t, n, leftType, message, getNativeType(STRING_TYPE));\n           message = \"right side of comparison\";\n           validator.expectString(t, n, rightType, message);\n-          validator.expectNotVoid(\n+          validator.expectNotNullOrUndefined(\n               t, n, rightType, message, getNativeType(STRING_TYPE));\n         }\n         ensureTyped(t, n, BOOLEAN_TYPE);\n@@ -772,6 +777,11 @@\n             ensureTyped(t, n);\n           }\n         }\n+        if (n.getType() == Token.OBJECTLIT) {\n+          for (Node key : n.children()) {\n+            visitObjLitKey(t, key, n);\n+          }\n+        }\n         break;\n \n       default:\n@@ -925,6 +935,64 @@\n   }\n \n   /**\n+   * Visits an object literal field definition <code>key : value</code>.\n+   *\n+   * If the <code>lvalue</code> is a prototype modification, we change the\n+   * schema of the object type it is referring to.\n+   *\n+   * @param t the traversal\n+   * @param key the assign node\n+   */\n+  private void visitObjLitKey(NodeTraversal t, Node key, Node objlit) {\n+    // TODO(johnlenz): Validate get and set function declarations are valid\n+    // as is the functions can have \"extraneous\" bits.\n+\n+    // For getter and setter property definitions the\n+    // rvalue type != the property type.\n+    Node rvalue = key.getFirstChild();\n+    JSType rightType = NodeUtil.getObjectLitKeyTypeFromValueType(\n+        key, getJSType(rvalue));\n+    if (rightType == null) {\n+      rightType = getNativeType(UNKNOWN_TYPE);\n+    }\n+\n+    Node owner = objlit;\n+\n+    // Validate value is assignable to the key type.\n+\n+    JSType keyType = getJSType(key);\n+    boolean valid = validator.expectCanAssignToPropertyOf(t, key,\n+        rightType, keyType,\n+        owner, NodeUtil.getObjectLitKeyName(key));\n+    if (valid) {\n+      ensureTyped(t, key, rightType);\n+    } else {\n+      ensureTyped(t, key);\n+    }\n+\n+    // Validate that the key type is assignable to the object property type.\n+    // This is necessary as the objlit may have been cast to a non-literal\n+    // object type.\n+    // TODO(johnlenz): consider introducing a CAST node to the AST (or\n+    // perhaps a parentheses node).\n+\n+    JSType objlitType = getJSType(objlit);\n+    ObjectType type = ObjectType.cast(\n+        objlitType.restrictByNotNullOrUndefined());\n+    if (type != null) {\n+      String property = NodeUtil.getObjectLitKeyName(key);\n+      if (type.hasProperty(property) &&\n+          !type.isPropertyTypeInferred(property) &&\n+          !propertyIsImplicitCast(type, property)) {\n+        validator.expectCanAssignToPropertyOf(\n+            t, key, keyType,\n+            type.getPropertyType(property), owner, property);\n+      }\n+      return;\n+    }\n+  }\n+\n+  /**\n    * Returns true if any type in the chain has an implictCast annotation for\n    * the given property.\n    */\n@@ -947,12 +1015,9 @@\n   private void checkDeclaredPropertyInheritance(\n       NodeTraversal t, Node n, FunctionType ctorType, String propertyName,\n       JSDocInfo info, JSType propertyType) {\n-    // TODO(user): We're not 100% confident that type-checking works,\n-    // so we return quietly if the unknown type is a superclass of this type.\n-    // Remove this check as we become more confident. We should flag a warning\n-    // when the unknown type is on the inheritance chain, as it is likely\n-    // because of a programmer error.\n-    if (ctorType.hasUnknownSupertype()) {\n+    // If the supertype doesn't resolve correctly, we've warned about this\n+    // already.\n+    if (hasUnknownOrEmptySupertype(ctorType)) {\n       return;\n     }\n \n@@ -964,11 +1029,13 @@\n     boolean foundInterfaceProperty = false;\n     if (ctorType.isConstructor()) {\n       for (JSType implementedInterface : ctorType.getImplementedInterfaces()) {\n-        if (implementedInterface.isUnknownType()) {\n+        if (implementedInterface.isUnknownType() ||\n+            implementedInterface.isEmptyType()) {\n           continue;\n         }\n         FunctionType interfaceType =\n             implementedInterface.toObjectType().getConstructor();\n+        Preconditions.checkNotNull(interfaceType);\n         boolean interfaceHasProperty =\n             interfaceType.getPrototype().hasProperty(propertyName);\n         foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty;\n@@ -980,10 +1047,7 @@\n               HIDDEN_INTERFACE_PROPERTY, propertyName,\n               interfaceType.getTopMostDefiningType(propertyName).toString()));\n         }\n-        if (!declaredOverride) {\n-          continue;\n-        }\n-        // @override is present and we have to check that it is ok\n+        // Check that it is ok\n         if (interfaceHasProperty) {\n           JSType interfacePropType =\n               interfaceType.getPrototype().getPropertyType(propertyName);\n@@ -1036,6 +1100,34 @@\n   }\n \n   /**\n+   * Given a constructor or an interface type, find out whether the unknown\n+   * type is a supertype of the current type.\n+   */\n+  private static boolean hasUnknownOrEmptySupertype(FunctionType ctor) {\n+    Preconditions.checkArgument(ctor.isConstructor() || ctor.isInterface());\n+    Preconditions.checkArgument(!ctor.isUnknownType());\n+\n+    // The type system should notice inheritance cycles on its own\n+    // and break the cycle.\n+    while (true) {\n+      ObjectType maybeSuperInstanceType =\n+          ctor.getPrototype().getImplicitPrototype();\n+      if (maybeSuperInstanceType == null) {\n+        return false;\n+      }\n+      if (maybeSuperInstanceType.isUnknownType() ||\n+          maybeSuperInstanceType.isEmptyType()) {\n+        return true;\n+      }\n+      ctor = maybeSuperInstanceType.getConstructor();\n+      if (ctor == null) {\n+        return false;\n+      }\n+      Preconditions.checkState(ctor.isConstructor() || ctor.isInterface());\n+    }\n+  }\n+\n+  /**\n    * Visits an ASSIGN node for cases such as\n    * <pre>\n    * interface.property2.property = ...;\n@@ -1154,8 +1246,8 @@\n \n     // TODO(user): remove in favor of flagging every property access on\n     // non-object.\n-    if (!validator.expectNotVoid(t, n, childType,\n-            \"undefined has no properties\", getNativeType(OBJECT_TYPE))) {\n+    if (!validator.expectNotNullOrUndefined(t, n, childType,\n+            childType + \" has no properties\", getNativeType(OBJECT_TYPE))) {\n       ensureTyped(t, n);\n       return;\n     }\n@@ -1403,9 +1495,17 @@\n \n     Iterator<Node> parameters = functionType.getParameters().iterator();\n     int ordinal = 0;\n-    while (arguments.hasNext() && parameters.hasNext()) {\n-      Node parameter = parameters.next();\n-      Node argument = arguments.next();\n+    Node parameter = null;\n+    Node argument = null;\n+    while (arguments.hasNext() &&\n+           (parameters.hasNext() ||\n+            parameter != null && parameter.isVarArgs())) {\n+      // If there are no parameters left in the list, then the while loop\n+      // above implies that this must be a var_args function.\n+      if (parameters.hasNext()) {\n+        parameter = parameters.next();\n+      }\n+      argument = arguments.next();\n       ordinal++;\n \n       validator.expectArgumentMatchesParameter(t, argument,\n@@ -1553,17 +1653,14 @@\n   private void checkEnumInitializer(\n       NodeTraversal t, Node value, JSType primitiveType) {\n     if (value.getType() == Token.OBJECTLIT) {\n-      // re-using value as the value of the object literal and advancing twice\n-      value = value.getFirstChild();\n-      value = (value == null) ? null : value.getNext();\n-      while (value != null) {\n-        // the value's type must be assignable to the enum's primitive type\n-        validator.expectCanAssignTo(t, value, getJSType(value), primitiveType,\n-            \"element type must match enum's type\");\n+      for (Node key = value.getFirstChild();\n+           key != null; key = key.getNext()) {\n+        Node propValue = key.getFirstChild();\n \n-        // advancing twice\n-        value = value.getNext();\n-        value = (value == null) ? null : value.getNext();\n+        // the value's type must be assignable to the enum's primitive type\n+        validator.expectCanAssignTo(\n+            t, propValue, getJSType(propValue), primitiveType,\n+            \"element type must match enum's type\");\n       }\n     } else if (value.getJSType() instanceof EnumType) {\n       // TODO(user): Remove the instanceof check in favor\n\n"
    },
    "Closure-68": {
        "Buggy Function": "boolean parse() {\nint lineno;\nint charno;\n\n// JSTypes are represented as Rhino AST nodes, and then resolved later.\nJSTypeExpression type;\n\nstate = State.SEARCHING_ANNOTATION;\nskipEOLs();\n\nJsDocToken token = next();\n\nList<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();\n\n// Always record that we have a comment.\nif (jsdocBuilder.shouldParseDocumentation()) {\n  ExtractionInfo blockInfo = extractBlockComment(token);\n  token = blockInfo.token;\n  if (!blockInfo.string.isEmpty()) {\n    jsdocBuilder.recordBlockDescription(blockInfo.string);\n  }\n} else {\n  if (token != JsDocToken.ANNOTATION &&\n      token != JsDocToken.EOC) {\n    // Mark that there was a description, but don't bother marking\n    // what it was.\n    jsdocBuilder.recordBlockDescription(\"\");\n  }\n}\n\n// Parse the actual JsDoc.\nretry: for (;;) {\n  switch (token) {\n    case ANNOTATION:\n      if (state == State.SEARCHING_ANNOTATION) {\n        state = State.SEARCHING_NEWLINE;\n        lineno = stream.getLineno();\n        charno = stream.getCharno();\n\n        String annotationName = stream.getString();\n        Annotation annotation = annotationNames.get(annotationName);\n        if (annotation == null) {\n          parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n              stream.getLineno(), stream.getCharno());\n        } else {\n          // Mark the beginning of the annotation.\n          jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n          switch (annotation) {\n            case AUTHOR:\n              if (jsdocBuilder.shouldParseDocumentation()) {\n                ExtractionInfo authorInfo = extractSingleLineBlock();\n                String author = authorInfo.string;\n\n                if (author.length() == 0) {\n                  parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                      stream.getLineno(), stream.getCharno());\n                } else {\n                  jsdocBuilder.addAuthor(author);\n                }\n                token = authorInfo.token;\n              } else {\n                token = eatTokensUntilEOL(token);\n              }\n              continue retry;\n\n            case CONSTANT:\n              if (!jsdocBuilder.recordConstancy()) {\n                parser.addParserWarning(\"msg.jsdoc.const\",\n                    stream.getLineno(), stream.getCharno());\n              }\n              token = eatTokensUntilEOL();\n              continue retry;\n\n            case CONSTRUCTOR:\n              if (!jsdocBuilder.recordConstructor()) {\n                if (jsdocBuilder.isInterfaceRecorded()) {\n                  parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                      stream.getLineno(), stream.getCharno());\n                } else {\n                  parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                      stream.getLineno(), stream.getCharno());\n                }\n              }\n              token = eatTokensUntilEOL();\n              continue retry;\n\n            case DEPRECATED:\n              if (!jsdocBuilder.recordDeprecated()) {\n                parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                    stream.getLineno(), stream.getCharno());\n              }\n\n              // Find the reason/description, if any.\n              ExtractionInfo reasonInfo =\n                  extractMultilineTextualBlock(token);\n\n              String reason = reasonInfo.string;\n\n              if (reason.length() > 0) {\n                jsdocBuilder.recordDeprecationReason(reason);\n              }\n\n              token = reasonInfo.token;\n              continue retry;\n\n            case INTERFACE:\n              if (!jsdocBuilder.recordInterface()) {\n                if (jsdocBuilder.isConstructorRecorded()) {\n                  parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                      stream.getLineno(), stream.getCharno());\n                } else {\n                  parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                      stream.getLineno(), stream.getCharno());\n                }\n              }\n              token = eatTokensUntilEOL();\n              continue retry;\n\n            case DESC:\n              if (jsdocBuilder.isDescriptionRecorded()) {\n                parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                    stream.getLineno(), stream.getCharno());\n                token = eatTokensUntilEOL();\n                continue retry;\n              } else {\n                ExtractionInfo descriptionInfo =\n                    extractMultilineTextualBlock(token);\n\n                String description = descriptionInfo.string;\n\n                jsdocBuilder.recordDescription(description);\n                token = descriptionInfo.token;\n                continue retry;\n              }\n\n            case FILE_OVERVIEW:\n              String fileOverview = \"\";\n              if (jsdocBuilder.shouldParseDocumentation()) {\n                ExtractionInfo fileOverviewInfo =\n                    extractMultilineTextualBlock(token,\n                        WhitespaceOption.TRIM);\n\n                fileOverview = fileOverviewInfo.string;\n\n                token = fileOverviewInfo.token;\n              } else {\n                token = eatTokensUntilEOL(token);\n              }\n\n              if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                  fileOverviewJSDocInfo != null) {\n                parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                    stream.getLineno(), stream.getCharno());\n              }\n              continue retry;\n\n            case LICENSE:\n            case PRESERVE:\n              ExtractionInfo preserveInfo =\n                  extractMultilineTextualBlock(token,\n                                               WhitespaceOption.PRESERVE);\n\n              String preserve = preserveInfo.string;\n\n              if (preserve.length() > 0) {\n                if (fileLevelJsDocBuilder != null) {\n                  fileLevelJsDocBuilder.append(preserve);\n                }\n              }\n\n              token = preserveInfo.token;\n              continue retry;\n\n            case ENUM:\n              token = next();\n              lineno = stream.getLineno();\n              charno = stream.getCharno();\n\n              type = null;\n              if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                type = createJSTypeExpression(\n                    parseAndRecordTypeNode(token));\n              }\n\n              if (type == null) {\n                type = createJSTypeExpression(newStringNode(\"number\"));\n              }\n              if (!jsdocBuilder.recordEnumParameterType(type)) {\n                parser.addTypeWarning(\n                    \"msg.jsdoc.incompat.type\", lineno, charno);\n              }\n              token = eatTokensUntilEOL(token);\n              continue retry;\n\n            case EXPORT:\n              if (!jsdocBuilder.recordExport()) {\n                parser.addParserWarning(\"msg.jsdoc.export\",\n                    stream.getLineno(), stream.getCharno());\n              }\n              token = eatTokensUntilEOL();\n              continue retry;\n\n            case EXTERNS:\n              if (!jsdocBuilder.recordExterns()) {\n                parser.addParserWarning(\"msg.jsdoc.externs\",\n                    stream.getLineno(), stream.getCharno());\n              }\n              token = eatTokensUntilEOL();\n              continue retry;\n\n            case JAVA_DISPATCH:\n              if (!jsdocBuilder.recordJavaDispatch()) {\n                parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                    stream.getLineno(), stream.getCharno());\n              }\n              token = eatTokensUntilEOL();\n              continue retry;\n\n            case EXTENDS:\n            case IMPLEMENTS:\n              skipEOLs();\n              token = next();\n              lineno = stream.getLineno();\n              charno = stream.getCharno();\n              boolean matchingRc = false;\n\n              if (token == JsDocToken.LC) {\n                token = next();\n                matchingRc = true;\n              }\n\n              if (token == JsDocToken.STRING) {\n                Node typeNode = parseAndRecordTypeNameNode(\n                    token, lineno, charno, matchingRc);\n\n                lineno = stream.getLineno();\n                charno = stream.getCharno();\n\n                typeNode = wrapNode(Token.BANG, typeNode);\n                if (typeNode != null && !matchingRc) {\n                  typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                }\n                type = createJSTypeExpression(typeNode);\n\n                if (annotation == Annotation.EXTENDS) {\n                  // record the extended type, check later\n                  extendedTypes.add(new ExtendedTypeInfo(\n                      type, stream.getLineno(), stream.getCharno()));\n                } else {\n                  Preconditions.checkState(\n                      annotation == Annotation.IMPLEMENTS);\n                  if (!jsdocBuilder.recordImplementedInterface(type)) {\n                    parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                        lineno, charno);\n                  }\n                }\n                token = next();\n                if (matchingRc) {\n                  if (token != JsDocToken.RC) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                } else if (token != JsDocToken.EOL &&\n                    token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                  parser.addTypeWarning(\"msg.end.annotation.expected\",\n                      stream.getLineno(), stream.getCharno());\n                }\n              } else {\n                parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n              }\n              token = eatTokensUntilEOL(token);\n              continue retry;\n\n            case HIDDEN:\n              if (!jsdocBuilder.recordHiddenness()) {\n                parser.addParserWarning(\"msg.jsdoc.hidden\",\n                    stream.getLineno(), stream.getCharno());\n              }\n              token = eatTokensUntilEOL();\n              continue retry;\n\n            case LENDS:\n              skipEOLs();\n\n              matchingRc = false;\n              if (match(JsDocToken.LC)) {\n                token = next();\n                matchingRc = true;\n              }\n\n              if (match(JsDocToken.STRING)) {\n                token = next();\n                if (!jsdocBuilder.recordLends(stream.getString())) {\n                  parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                      stream.getLineno(), stream.getCharno());\n                }\n              } else {\n                parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                    stream.getLineno(), stream.getCharno());\n              }\n\n              if (matchingRc && !match(JsDocToken.RC)) {\n                parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                    stream.getLineno(), stream.getCharno());\n              }\n              token = eatTokensUntilEOL();\n              continue retry;\n\n            case MEANING:\n              ExtractionInfo meaningInfo =\n                  extractMultilineTextualBlock(token);\n              String meaning = meaningInfo.string;\n              token = meaningInfo.token;\n              if (!jsdocBuilder.recordMeaning(meaning)) {\n                parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                    stream.getLineno(), stream.getCharno());\n              }\n              continue retry;\n\n            case NO_ALIAS:\n              if (!jsdocBuilder.recordNoAlias()) {\n                parser.addParserWarning(\"msg.jsdoc.noalias\",\n                    stream.getLineno(), stream.getCharno());\n              }\n              token = eatTokensUntilEOL();\n              continue retry;\n\n            case NO_COMPILE:\n              if (!jsdocBuilder.recordNoCompile()) {\n                parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                    stream.getLineno(), stream.getCharno());\n              }\n              token = eatTokensUntilEOL();\n              continue retry;\n\n            case NO_TYPE_CHECK:\n              if (!jsdocBuilder.recordNoTypeCheck()) {\n                parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                    stream.getLineno(), stream.getCharno());\n              }\n              token = eatTokensUntilEOL();\n              continue retry;\n\n            case NOT_IMPLEMENTED:\n              token = eatTokensUntilEOL();\n              continue retry;\n\n            case INHERIT_DOC:\n            case OVERRIDE:\n              if (!jsdocBuilder.recordOverride()) {\n                parser.addTypeWarning(\"msg.jsdoc.override\",\n                    stream.getLineno(), stream.getCharno());\n              }\n              token = eatTokensUntilEOL();\n              continue retry;\n\n            case THROWS:\n              skipEOLs();\n              token = next();\n              lineno = stream.getLineno();\n              charno = stream.getCharno();\n              type = null;\n\n              if (token == JsDocToken.LC) {\n                type = createJSTypeExpression(\n                    parseAndRecordTypeNode(token));\n\n                if (type == null) {\n                  // parsing error reported during recursive descent\n                  // recovering parsing\n                  token = eatTokensUntilEOL();\n                  continue retry;\n                }\n              }\n\n              // *Update* the token to that after the type annotation.\n              token = current();\n\n              // Save the throw type.\n              jsdocBuilder.recordThrowType(type);\n\n              // Find the throw's description (if applicable).\n              if (jsdocBuilder.shouldParseDocumentation()) {\n                ExtractionInfo descriptionInfo =\n                    extractMultilineTextualBlock(token);\n\n                String description = descriptionInfo.string;\n\n                if (description.length() > 0) {\n                  jsdocBuilder.recordThrowDescription(type, description);\n                }\n\n                token = descriptionInfo.token;\n              } else {\n                token = eatTokensUntilEOL(token);\n              }\n              continue retry;\n\n            case PARAM:\n              skipEOLs();\n              token = next();\n              lineno = stream.getLineno();\n              charno = stream.getCharno();\n              type = null;\n\n              if (token == JsDocToken.LC) {\n                type = createJSTypeExpression(\n                    parseAndRecordParamTypeNode(token));\n\n                if (type == null) {\n                  // parsing error reported during recursive descent\n                  // recovering parsing\n                  token = eatTokensUntilEOL();\n                  continue retry;\n                }\n                skipEOLs();\n                token = next();\n                lineno = stream.getLineno();\n                charno = stream.getCharno();\n              }\n\n              String name = null;\n              boolean isBracketedParam = JsDocToken.LB == token;\n              if (isBracketedParam) {\n                token = next();\n              }\n\n              if (JsDocToken.STRING != token) {\n                parser.addTypeWarning(\"msg.missing.variable.name\",\n                    lineno, charno);\n              } else {\n                name = stream.getString();\n\n                if (isBracketedParam) {\n                  token = next();\n\n                  // Throw out JsDocToolkit's \"default\" parameter\n                  // annotation.  It makes no sense under our type\n                  // system.\n                  if (JsDocToken.EQUALS == token) {\n                    token = next();\n                    if (JsDocToken.STRING == token) {\n                      token = next();\n                    }\n                  }\n\n                  if (JsDocToken.RB != token) {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                  } else if (type != null) {\n                    // Make the type expression optional, if it isn't\n                    // already.\n                    type = JSTypeExpression.makeOptionalArg(type);\n                  }\n                }\n\n                // If the param name has a DOT in it, just throw it out\n                // quietly. We do not handle the JsDocToolkit method\n                // for handling properties of params.\n                if (name.indexOf('.') > -1) {\n                  name = null;\n                } else if (!jsdocBuilder.recordParameter(name, type)) {\n                  if (jsdocBuilder.hasParameter(name)) {\n                    parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                        lineno, charno);\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                        lineno, charno);\n                  }\n                }\n              }\n\n              if (name == null) {\n                token = eatTokensUntilEOL(token);\n                continue retry;\n              }\n\n              jsdocBuilder.markName(name, lineno, charno);\n\n              // Find the parameter's description (if applicable).\n              if (jsdocBuilder.shouldParseDocumentation()) {\n                ExtractionInfo paramDescriptionInfo =\n                    extractMultilineTextualBlock(token);\n\n                String paramDescription = paramDescriptionInfo.string;\n\n                if (paramDescription.length() > 0) {\n                  jsdocBuilder.recordParameterDescription(name,\n                      paramDescription);\n                }\n\n                token = paramDescriptionInfo.token;\n              } else {\n                token = eatTokensUntilEOL(token);\n              }\n              continue retry;\n\n            case PRESERVE_TRY:\n              if (!jsdocBuilder.recordPreserveTry()) {\n                parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                    stream.getLineno(), stream.getCharno());\n              }\n              token = eatTokensUntilEOL();\n              continue retry;\n\n            case PRIVATE:\n              if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                parser.addParserWarning(\"msg.jsdoc.visibility.private\",\n                    stream.getLineno(), stream.getCharno());\n              }\n              token = eatTokensUntilEOL();\n              continue retry;\n\n            case PROTECTED:\n              if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                parser.addParserWarning(\"msg.jsdoc.visibility.protected\",\n                    stream.getLineno(), stream.getCharno());\n              }\n              token = eatTokensUntilEOL();\n              continue retry;\n\n            case PUBLIC:\n              if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                parser.addParserWarning(\"msg.jsdoc.visibility.public\",\n                    stream.getLineno(), stream.getCharno());\n              }\n              token = eatTokensUntilEOL();\n              continue retry;\n\n            case NO_SHADOW:\n              if (!jsdocBuilder.recordNoShadow()) {\n                parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                    stream.getLineno(), stream.getCharno());\n              }\n              token = eatTokensUntilEOL();\n              continue retry;\n\n            case NO_SIDE_EFFECTS:\n              if (!jsdocBuilder.recordNoSideEffects()) {\n                parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                    stream.getLineno(), stream.getCharno());\n              }\n              token = eatTokensUntilEOL();\n              continue retry;\n\n            case MODIFIES:\n              token = parseModifiesTag(next());\n              continue retry;\n\n            case IMPLICIT_CAST:\n              if (!jsdocBuilder.recordImplicitCast()) {\n                parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                    stream.getLineno(), stream.getCharno());\n              }\n              token = eatTokensUntilEOL();\n              continue retry;\n\n            case SEE:\n              if (jsdocBuilder.shouldParseDocumentation()) {\n                ExtractionInfo referenceInfo = extractSingleLineBlock();\n                String reference = referenceInfo.string;\n\n                if (reference.length() == 0) {\n                  parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                      stream.getLineno(), stream.getCharno());\n                } else {\n                  jsdocBuilder.addReference(reference);\n                }\n\n                token = referenceInfo.token;\n              } else {\n                token = eatTokensUntilEOL(token);\n              }\n              continue retry;\n\n            case SUPPRESS:\n              token = parseSuppressTag(next());\n              continue retry;\n\n            case TEMPLATE:\n              ExtractionInfo templateInfo = extractSingleLineBlock();\n              String templateTypeName = templateInfo.string;\n\n              if (templateTypeName.length() == 0) {\n                parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                      stream.getLineno(), stream.getCharno());\n              } else if (!jsdocBuilder.recordTemplateTypeName(\n                  templateTypeName)) {\n                parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                    stream.getLineno(), stream.getCharno());\n              }\n\n              token = templateInfo.token;\n              continue retry;\n\n            case VERSION:\n              ExtractionInfo versionInfo = extractSingleLineBlock();\n              String version = versionInfo.string;\n\n              if (version.length() == 0) {\n                parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                      stream.getLineno(), stream.getCharno());\n              } else {\n                if (!jsdocBuilder.recordVersion(version)) {\n                   parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                      stream.getLineno(), stream.getCharno());\n                }\n              }\n\n              token = versionInfo.token;\n              continue retry;\n\n            case DEFINE:\n            case RETURN:\n            case THIS:\n            case TYPE:\n            case TYPEDEF:\n              lineno = stream.getLineno();\n              charno = stream.getCharno();\n\n              Node typeNode = null;\n              if (!lookAheadForTypeAnnotation() &&\n                  annotation == Annotation.RETURN) {\n                // If RETURN doesn't have a type annotation, record\n                // it as the unknown type.\n                typeNode = newNode(Token.QMARK);\n              } else {\n                skipEOLs();\n                token = next();\n                typeNode = parseAndRecordTypeNode(token, lineno, charno);\n              }\n\n              if (annotation == Annotation.THIS) {\n                typeNode = wrapNode(Token.BANG, typeNode);\n                if (typeNode != null && token != JsDocToken.LC) {\n                  typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                }\n              }\n              type = createJSTypeExpression(typeNode);\n\n              if (type == null) {\n                // error reported during recursive descent\n                // recovering parsing\n              } else {\n                switch (annotation) {\n                  case DEFINE:\n                    if (!jsdocBuilder.recordDefineType(type)) {\n                      parser.addParserWarning(\"msg.jsdoc.define\",\n                          lineno, charno);\n                    }\n                    break;\n\n                  case RETURN:\n                    if (!jsdocBuilder.recordReturnType(type)) {\n                      parser.addTypeWarning(\n                          \"msg.jsdoc.incompat.type\", lineno, charno);\n                      break;\n                    }\n\n                    // Find the return's description (if applicable).\n                    if (jsdocBuilder.shouldParseDocumentation()) {\n                      ExtractionInfo returnDescriptionInfo =\n                          extractMultilineTextualBlock(token);\n\n                      String returnDescription =\n                          returnDescriptionInfo.string;\n\n                      if (returnDescription.length() > 0) {\n                        jsdocBuilder.recordReturnDescription(\n                            returnDescription);\n                      }\n\n                      token = returnDescriptionInfo.token;\n                    } else {\n                      token = eatTokensUntilEOL(token);\n                    }\n                    continue retry;\n\n                  case THIS:\n                    if (!jsdocBuilder.recordThisType(type)) {\n                      parser.addTypeWarning(\n                          \"msg.jsdoc.incompat.type\", lineno, charno);\n                    }\n                    break;\n\n                  case TYPE:\n                    if (!jsdocBuilder.recordType(type)) {\n                      parser.addTypeWarning(\n                          \"msg.jsdoc.incompat.type\", lineno, charno);\n                    }\n                    break;\n\n                  case TYPEDEF:\n                    if (!jsdocBuilder.recordTypedef(type)) {\n                      parser.addTypeWarning(\n                          \"msg.jsdoc.incompat.type\", lineno, charno);\n                    }\n                    break;\n                }\n\n                token = eatTokensUntilEOL();\n              }\n              continue retry;\n          }\n        }\n      }\n      break;\n\n    case EOC:\n      if (hasParsedFileOverviewDocInfo()) {\n        fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n      }\n      checkExtendedTypes(extendedTypes);\n      return true;\n\n    case EOF:\n      // discard any accumulated information\n      jsdocBuilder.build(null);\n      parser.addParserWarning(\"msg.unexpected.eof\",\n          stream.getLineno(), stream.getCharno());\n      checkExtendedTypes(extendedTypes);\n      return false;\n\n    case EOL:\n      if (state == State.SEARCHING_NEWLINE) {\n        state = State.SEARCHING_ANNOTATION;\n      }\n      token = next();\n      continue retry;\n\n    default:\n      if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n        token = next();\n        continue retry;\n      } else {\n        state = State.SEARCHING_NEWLINE;\n        token = eatTokensUntilEOL();\n        continue retry;\n      }\n  }\n\n  // next token\n  token = next();\n}\n}\nprivate Node parseBasicTypeExpression(JsDocToken token) {\nif (token == JsDocToken.STAR) {\n  return newNode(Token.STAR);\n} else if (token == JsDocToken.LB) {\n  skipEOLs();\n  return parseArrayType(next());\n} else if (token == JsDocToken.LC) {\n  skipEOLs();\n  return parseRecordType(next());\n} else if (token == JsDocToken.LP) {\n  skipEOLs();\n  return parseUnionType(next());\n} else if (token == JsDocToken.STRING) {\n  String string = stream.getString();\n  if (\"function\".equals(string)) {\n    skipEOLs();\n    return parseFunctionType(next());\n  } else if (\"null\".equals(string) || \"undefined\".equals(string)) {\n    return newStringNode(string);\n  } else {\n    return parseTypeName(token);\n  }\n}\n\nreturn reportGenericTypeSyntaxWarning();\n}\nprivate Node parseFunctionType(JsDocToken token) {\n// NOTE(nicksantos): We're not implementing generics at the moment, so\n// just throw out TypeParameters.\nif (token != JsDocToken.LP) {\n  return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n}\n\nNode functionType = newNode(Token.FUNCTION);\nNode parameters = null;\nskipEOLs();\nif (!match(JsDocToken.RP)) {\n  token = next();\n\n  boolean hasParams = true;\n  if (token == JsDocToken.STRING) {\n    String tokenStr = stream.getString();\n    boolean isThis = \"this\".equals(tokenStr);\n    boolean isNew = \"new\".equals(tokenStr);\n    if (isThis || isNew) {\n      if (match(JsDocToken.COLON)) {\n        next();\n        skipEOLs();\n        Node contextType = wrapNode(\n            isThis ? Token.THIS : Token.NEW,\n            parseTypeName(next()));\n        if (contextType == null) {\n          return null;\n        }\n\n        functionType.addChildToFront(contextType);\n      } else {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n      }\n\n      if (match(JsDocToken.COMMA)) {\n        next();\n        skipEOLs();\n        token = next();\n      } else {\n        hasParams = false;\n      }\n    }\n  }\n\n  if (hasParams) {\n    parameters = parseParametersType(token);\n    if (parameters == null) {\n      return null;\n    }\n  }\n}\n\nif (parameters != null) {\n  functionType.addChildToBack(parameters);\n}\n\nskipEOLs();\nif (!match(JsDocToken.RP)) {\n  return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n}\n\nskipEOLs();\nNode resultType = parseResultType(next());\nif (resultType == null) {\n  return null;\n} else {\n  functionType.addChildToBack(resultType);\n}\nreturn functionType;\n}",
        "Inducing Changes": "diff --git a/src/com/google/javascript/jscomp/AbstractCompiler.java b/src/com/google/javascript/jscomp/AbstractCompiler.java\nindex 44846ec..2c9881d 100644\n--- a/src/com/google/javascript/jscomp/AbstractCompiler.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompiler.java\n@@ -31,6 +31,9 @@\n *\n  */\n public abstract class AbstractCompiler implements SourceExcerptProvider {\n+  static final DiagnosticType READ_ERROR \u003d DiagnosticType.error(\n+      \"JSC_READ_ERROR\", \"Cannot read: {0}\");\n+\n   // TODO(nicksantos): Decide if all of these are really necessary.\n   // Many of them are just accessors that should be passed to the\n   // CompilerPass\u0027s constructor.\n@@ -202,4 +205,16 @@\n    * Gets the error manager.\n    */\n   abstract public ErrorManager getErrorManager();\n+\n+  /**\n+   * Set if the normalization pass has been done.\n+   * Note: non-private to enable test cases that require the Normalize pass.\n+   */\n+  abstract void setNormalized();\n+\n+  /**\n+   * Set once unnormalizing passes have been start.\n+   * Note: non-private to enable test cases that require the Normalize pass.\n+   */\n+  abstract void setUnnormalized();\n }\ndiff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\\nindex 2980574..040bbf1 100644\\n--- a/src/com/google/javascript/jscomp/Compiler.java\\n+++ b/src/com/google/javascript/jscomp/Compiler.java\\n@@ -29,11 +29,9 @@\\n import com.google.javascript.rhino.Token;\\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\\n \\n-import java.io.FileReader;\\n import java.io.IOException;\\n import java.io.PrintStream;\\n import java.io.Serializable;\\n-import java.text.ParseException;\\n import java.util.ArrayList;\\n import java.util.HashMap;\\n import java.util.List;\\n@@ -90,15 +88,6 @@\\n \\n   private Map\\u003cString, CompilerInput\\u003e inputsByName_;\\n \\n-  /** Fully qualified function names and globally unique ids */\\n-  private FunctionNames functionNames_;\\n-\\n-  /** The variable renaming map */\\n-  private VariableMap variableMap_;\\n-\\n-  /** The property renaming map */\\n-  private VariableMap propertyMap_;\\n-\\n   /** The source code map */\\n   private SourceMap sourceMap_;\\n \\n@@ -120,9 +109,6 @@\\n   /** Whether to use threads. */\\n   private boolean useThreads \\u003d true;\\n \\n-  /** The naming map for anonymous functions */\\n-  private VariableMap anonFunctionNameMap_;\\n-\\n   /** The function information map */\\n   private FunctionInformationMap functionInformationMap_;\\n \\n@@ -148,20 +134,12 @@\\n       RhinoErrorReporter.forNewRhino(this);\\n \\n   /** Error strings used for reporting JSErrors */\\n-  public static final DiagnosticType READ_ERROR \\u003d DiagnosticType.error(\\n-      \\\"JSC_READ_ERROR\\\", \\\"Cannot read: {0}\\\");\\n   public static final DiagnosticType OPTIMIZE_LOOP_ERROR \\u003d DiagnosticType.error(\\n       \\\"JSC_OPTIMIZE_LOOP_ERROR\\\",\\n       \\\"Exceeded max number of optimization iterations: {0}\\\");\\n   public static final DiagnosticType MOTION_ITERATIONS_ERROR \\u003d\\n       DiagnosticType.error(\\\"JSC_OPTIMIZE_LOOP_ERROR\\\",\\n           \\\"Exceeded max number of code motion iterations: {0}\\\");\\n-  private static final DiagnosticType INPUT_MAP_PROP_PARSE \\u003d\\n-      DiagnosticType.error(\\\"JSC_INPUT_MAP_PROP_PARSE\\\",\\n-          \\\"Input property map parse error: {0}\\\");\\n-  private static final DiagnosticType INPUT_VAR_PROP_PARSE \\u003d\\n-      DiagnosticType.error(\\\"JSC_INPUT_MAP_VAR_PARSE\\\",\\n-          \\\"Input variable map parse error: {0}\\\");\\n \\n   private static final long COMPILER_STACK_SIZE \\u003d 1048576L;\\n \\n@@ -528,7 +506,8 @@\\n     }\\n \\n     if (options_.nameAnonymousFunctionsOnly) {\\n-      nameAnonymousFunctions(options_.anonymousFunctionNaming);\\n+      // TODO(nicksantos): Move this into an instrument() phase maybe?\\n+      check();\\n       return;\\n     }\\n \\n@@ -614,9 +593,9 @@\\n       return;\\n     }\\n \\n-    if (options_.instrumentationTemplate !\\u003d null ||\\n-        options_.recordFunctionInformation) {\\n-      computeFunctionNames();\\n+    // TODO(nicksantos): clean this up. The flow here is too hard to follow.\\n+    if (options_.nameAnonymousFunctionsOnly) {\\n+      return;\\n     }\\n \\n     if (options_.removeTryCatchFinally) {\\n@@ -702,34 +681,6 @@\\n   }\\n \\n   /**\\n-   * Alias string literals with global variables, to avoid creating lots of\\n-   * transient objects.\\n-   */\\n-  private void aliasStrings(Set\\u003cString\\u003e aliasableStrings,\\n-                            boolean aliasAllStrings,\\n-                            String aliasStringsBlacklist,\\n-                            boolean outputStringUsage) {\\n-    logger_.info(\\\"Aliasing strings\\\");\\n-    startPass(\\\"aliasStrings\\\");\\n-    AliasStrings aliasStrings \\u003d new AliasStrings(\\n-        this,\\n-        getModuleGraph(),\\n-        aliasAllStrings ? null : aliasableStrings,\\n-        aliasStringsBlacklist,\\n-        outputStringUsage);\\n-    process(aliasStrings);\\n-    endPass();\\n-  }\\n-\\n-  private void aliasKeywords() {\\n-    logger_.info(\\\"Aliasing true/false/null\\\");\\n-    startPass(\\\"aliasKeywords\\\");\\n-    AliasKeywords aliasKeywords \\u003d new AliasKeywords(this);\\n-    process(aliasKeywords);\\n-    endPass();\\n-  }\\n-\\n-  /**\\n    * Runs custom passes that are designated to run at a particular time.\\n    */\\n   private void runCustomPasses(CustomPassExecutionTime executionTime) {\\n@@ -794,10 +745,11 @@\\n    * Returns the result of the compilation.\\n    */\\n   public Result getResult() {\\n+    PassConfig.State state \\u003d getPassConfig().getIntermediateState();\\n     return new Result(getErrors(), getWarnings(), debugLog_.toString(),\\n-                      variableMap_, propertyMap_, anonFunctionNameMap_,\\n-                      functionInformationMap_, sourceMap_, externExports_,\\n-                      getPassConfig().getCssNames());\\n+        state.variableMap, state.propertyMap,\\n+        state.anonymousFunctionNameMap, functionInformationMap_,\\n+        sourceMap_, externExports_, state.cssNames);\\n   }\\n \\n   /**\\n@@ -857,6 +809,7 @@\\n    * Set if the normalization pass has been done.\\n    * Note: non-private to enable test cases that require the Normalize pass.\\n    */\\n+  @Override\\n   void setNormalized() {\\n     normalized \\u003d true;\\n   }\\n@@ -865,6 +818,7 @@\\n    * Set once unnormalizing passes have been start.\\n    * Note: non-private to enable test cases that require the Normalize pass.\\n    */\\n+  @Override\\n   void setUnnormalized() {\\n     normalized \\u003d false;\\n   }\\n@@ -1307,160 +1261,6 @@\\n     if (hasErrors()) {\\n       return;\\n     }\\n-\\n-    if (options_.flowSensitiveInlineVariables) {\\n-      flowSensitiveInlineVariables();\\n-    }\\n-\\n-    if (options_.collapseAnonymousFunctions) {\\n-      collapseAnonymousFunctions();\\n-    }\\n-\\n-    // Move functions before extracting prototype member declarations.\\n-    if (options_.moveFunctionDeclarations) {\\n-      moveFunctionDeclarations();\\n-    }\\n-\\n-    if (options_.anonymousFunctionNaming \\u003d\\u003d\\n-        AnonymousFunctionNamingPolicy.MAPPED) {\\n-      nameAnonymousFunctions(AnonymousFunctionNamingPolicy.MAPPED);\\n-    }\\n-\\n-    // The mapped name anonymous function pass makes use of information that\\n-    // the extract prototype member declarations pass removes so the former\\n-    // happens before the latter.\\n-    //\\n-    // Extracting prototype properties screws up the heuristic renaming\\n-    // policies, so never run it when those policies are requested.\\n-    if (options_.extractPrototypeMemberDeclarations \\u0026\\u0026\\n-        (options_.propertyRenaming !\\u003d PropertyRenamingPolicy.HEURISTIC \\u0026\\u0026\\n-         options_.propertyRenaming !\\u003d\\n-            PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC)) {\\n-      extractPrototypeMemberDeclarations();\\n-    }\\n-\\n-    if (options_.coalesceVariableNames) {\\n-      coalesceVariableNames();\\n-    }\\n-\\n-    VariableMap prevPropertyMap \\u003d null;\\n-    if (options_.inputPropertyMapSerialized !\\u003d null) {\\n-      try {\\n-        prevPropertyMap \\u003d\\n-            VariableMap.fromBytes(options_.inputPropertyMapSerialized);\\n-      } catch (ParseException e) {\\n-        report(JSError.make(INPUT_MAP_PROP_PARSE, e.getMessage()));\\n-      }\\n-    }\\n-\\n-    if (options_.ambiguateProperties \\u0026\\u0026 (options_.propertyRenaming\\n-        \\u003d\\u003d PropertyRenamingPolicy.ALL_UNQUOTED)) {\\n-      ambiguateProperties(options_.anonymousFunctionNaming\\n-          .getReservedCharacters());\\n-    }\\n-\\n-    switch (options_.propertyRenaming) {\\n-      case HEURISTIC:\\n-        renamePrototypes(false,\\n-            options_.anonymousFunctionNaming,\\n-            prevPropertyMap);\\n-        break;\\n-      case AGGRESSIVE_HEURISTIC:\\n-        renamePrototypes(true,\\n-            options_.anonymousFunctionNaming,\\n-            prevPropertyMap);\\n-        break;\\n-      case ALL_UNQUOTED:\\n-        renameProperties(options_.generatePseudoNames,\\n-            options_.anonymousFunctionNaming,\\n-            prevPropertyMap);\\n-        break;\\n-    }\\n-\\n-    // This comes after property renaming because quoted property names must\\n-    // not be renamed.\\n-    if (options_.convertToDottedProperties) {\\n-      convertToDottedProperties();\\n-    }\\n-\\n-    // Property renaming must happen before this pass runs since this\\n-    // pass may convert dotted properties into quoted properties.  It\\n-    // is beneficial to run before alias strings, alias keywords and\\n-    // variable renaming.\\n-    if (options_.rewriteFunctionExpressions) {\\n-      rewriteFunctionExpressions();\\n-    }\\n-\\n-    // This comes after converting quoted property accesses to dotted property\\n-    // accesses in order to avoid aliasing property names.\\n-    if (!options_.aliasableStrings.isEmpty() || options_.aliasAllStrings) {\\n-      aliasStrings(options_.aliasableStrings,\\n-                   options_.aliasAllStrings,\\n-                   options_.aliasStringsBlacklist,\\n-                   options_.outputJsStringUsage);\\n-    }\\n-\\n-    if (options_.aliasExternals) {\\n-      aliasExternals();\\n-    }\\n-\\n-    if (options_.aliasKeywords) {\\n-      aliasKeywords();\\n-    }\\n-\\n-    if (options_.collapseVariableDeclarations) {\\n-      collapseVariableDeclarations();\\n-    }\\n-\\n-    denormalize();\\n-\\n-    if (options_.instrumentationTemplate !\\u003d null) {\\n-      instrumentFunctions();\\n-    }\\n-\\n-    if (options_.variableRenaming !\\u003d VariableRenamingPolicy.ALL) {\\n-      // If we\\u0027re leaving some (or all) variables with their old names,\\n-      // then we need to undo any of the markers we added for distinguishing\\n-      // local variables (\\\"$$1\\\") or constants (\\\"$$constant\\\").\\n-      invertContextualRenaming();\\n-    }\\n-\\n-    if (options_.variableRenaming !\\u003d VariableRenamingPolicy.OFF) {\\n-      VariableMap prevVariableMap \\u003d null;\\n-      if (options_.inputVariableMapSerialized !\\u003d null) {\\n-        try {\\n-          prevVariableMap \\u003d\\n-              VariableMap.fromBytes(options_.inputVariableMapSerialized);\\n-        } catch (ParseException e) {\\n-          report(JSError.make(INPUT_VAR_PROP_PARSE, e.getMessage()));\\n-        }\\n-      }\\n-\\n-      renameVars(options_.renamePrefix,\\n-          options_.variableRenaming \\u003d\\u003d VariableRenamingPolicy.LOCAL,\\n-          options_.anonymousFunctionNaming,\\n-          options_.generatePseudoNames,\\n-          prevVariableMap);\\n-    }\\n-\\n-    // This pass should run after names stop changing.\\n-    if (options_.processObjectPropertyString) {\\n-      objectPropertyStringPostprocess();\\n-    }\\n-\\n-    if (options_.labelRenaming) {\\n-      renameLabels();\\n-    }\\n-\\n-    if (options_.anonymousFunctionNaming \\u003d\\u003d\\n-        AnonymousFunctionNamingPolicy.UNMAPPED) {\\n-      nameAnonymousFunctions(AnonymousFunctionNamingPolicy.UNMAPPED);\\n-    }\\n-\\n-    // Safety check\\n-    if (options_.checkSymbols) {\\n-      sanityCheckVars();\\n-    }\\n   }\\n \\n   @Override\\n@@ -1473,16 +1273,6 @@\\n     return options_.cssRenamingMap;\\n   }\\n \\n-\\n-  /** Checks that all variables are defined. */\\n-  void sanityCheckVars() {\\n-    logger_.info(\\\"Checking for undefined vars\\\");\\n-    startPass(\\\"sanityCheckVars\\\");\\n-    VarCheck v \\u003d new VarCheck(this, true);\\n-    process(v);\\n-    endPass();\\n-  }\\n-\\n   /**\\n    * Reprocesses the current defines over the AST.  This is used by GwtCompiler\\n    * to generate N outputs for different targets from the same (checked) AST.\\n@@ -1495,66 +1285,6 @@\\n         .process(externsRoot, jsRoot);\\n   }\\n \\n-  void computeFunctionNames() {\\n-    logger_.info(\\\"Computing fully-qualified function names and ids\\\");\\n-    startPass(\\\"computeFunctionNames\\\");\\n-    functionNames_ \\u003d new FunctionNames(this);\\n-    process(functionNames_);\\n-    endPass();\\n-  }\\n-\\n-  void flowSensitiveInlineVariables() {\\n-    logger_.info(\\\"Flow Sensitive Inline Variables\\\");\\n-    startPass(\\\"flowSensitiveInlineVariables\\\");\\n-    process(new FlowSensitiveInlineVariables(this));\\n-    endPass();\\n-  }\\n-\\n-  void coalesceVariableNames() {\\n-    logger_.info(\\\"Coalesce Variable Names\\\");\\n-    startPass(\\\"coalesceVariableNames\\\");\\n-    process(new CoalesceVariableNames(this));\\n-    endPass();\\n-  }\\n-\\n-  void collapseVariableDeclarations() {\\n-    logger_.info(\\\"Collapsing variable declarations\\\");\\n-    startPass(\\\"collapseVariableDeclarations\\\");\\n-    process(new CollapseVariableDeclarations(this));\\n-    setUnnormalized();\\n-    endPass();\\n-  }\\n-\\n-  void extractPrototypeMemberDeclarations() {\\n-    logger_.info(\\\"Extracting Common Prototype Member Declarations\\\");\\n-    startPass(\\\"extractPrototypeMemberDeclarations\\\");\\n-    process(new ExtractPrototypeMemberDeclarations(this));\\n-    endPass();\\n-  }\\n-\\n-  void rewriteFunctionExpressions() {\\n-    logger_.info(\\\"Rewrite function expressions\\\");\\n-    startPass(\\\"rewriteFunctionExpressions\\\");\\n-    process(new FunctionRewriter(this));\\n-    endPass();\\n-  }\\n-\\n-  void collapseAnonymousFunctions() {\\n-    logger_.info(\\\"Collapsing anonymous functions\\\");\\n-    startPass(\\\"collapseAnonymousFunctions\\\");\\n-    process(new CollapseAnonymousFunctions(this));\\n-    endPass();\\n-  }\\n-\\n-\\n-\\n-  void moveFunctionDeclarations() {\\n-    logger_.info(\\\"Move function declarations\\\");\\n-    startPass(\\\"moveFunctionDeclarations\\\");\\n-    process(new MoveFunctionDeclarations(this));\\n-    endPass();\\n-  }\\n-\\n   boolean isInliningForbidden() {\\n     return options_.propertyRenaming \\u003d\\u003d PropertyRenamingPolicy.HEURISTIC ||\\n         options_.propertyRenaming \\u003d\\u003d\\n@@ -1571,44 +1301,6 @@\\n     return cfa.getCfg();\\n   }\\n \\n-  void nameAnonymousFunctions(AnonymousFunctionNamingPolicy policy) {\\n-    logger_.info(\\\"Naming anonymous functions\\\");\\n-    startPass(\\\"nameAnonymousFunctions\\\");\\n-    if (policy \\u003d\\u003d AnonymousFunctionNamingPolicy.UNMAPPED) {\\n-      process(new NameAnonymousFunctions(this));\\n-    } else if (policy \\u003d\\u003d AnonymousFunctionNamingPolicy.MAPPED) {\\n-      NameAnonymousFunctionsMapped naf \\u003d new NameAnonymousFunctionsMapped(this);\\n-      process(naf);\\n-      anonFunctionNameMap_ \\u003d naf.getFunctionMap();\\n-    }\\n-    endPass();\\n-  }\\n-\\n-  void aliasExternals() {\\n-    logger_.info(\\\"Creating alias functions for externals\\\");\\n-    startPass(\\\"aliasExternals\\\");\\n-    AliasExternals ae \\u003d new AliasExternals(this,\\n-                                           getModuleGraph(),\\n-                                           options_.unaliasableGlobals,\\n-                                           options_.aliasableGlobals);\\n-    process(ae);\\n-    endPass();\\n-  }\\n-\\n-  void objectPropertyStringPostprocess() {\\n-    logger_.info(\\\"goog.testing.ObjectPropertyString postprocess\\\");\\n-    startPass(\\\"ObjectPropertyStringPostprocess\\\");\\n-    process(new ObjectPropertyStringPostprocess(this));\\n-    endPass();\\n-  }\\n-\\n-  void ambiguateProperties(char[] reservedCharacters) {\\n-    logger_.info(\\\"Ambiguating properties\\\");\\n-    startPass(\\\"ambiguateProperties\\\");\\n-    process(new AmbiguateProperties(this, reservedCharacters));\\n-    endPass();\\n-  }\\n-\\n   public void normalize() {\\n     logger_.info(\\\"Normalizing\\\");\\n     startPass(\\\"normalize\\\");\\n@@ -1617,14 +1309,6 @@\\n     endPass();\\n   }\\n \\n-  private void denormalize() {\\n-    logger_.info(\\\"Denormalizing\\\");\\n-    startPass(\\\"denormalize\\\");\\n-    process(new Denormalize(this));\\n-    setUnnormalized();\\n-    endPass();\\n-  }\\n-\\n   @Override\\n   void normalizeNodeTypes(Node root) {\\n     Tracer tracer \\u003d newTracer(\\\"normalizeNodeTypes\\\");\\n@@ -1647,97 +1331,12 @@\\n     stopTracer(tracer, \\\"annotateCodingConvention\\\");\\n   }\\n \\n-  void renameVars(String renamePrefix, boolean renameLocalVarsOnly,\\n-      AnonymousFunctionNamingPolicy anonFunctionNamePolicy,\\n-      boolean generatePseudoNames,\\n-      VariableMap prevVariableMap) {\\n-    logger_.info(\\\"Renaming vars\\\");\\n-    startPass(\\\"renameVars\\\");\\n-    boolean preserveAnonymousFunctionNames \\u003d\\n-      anonFunctionNamePolicy !\\u003d AnonymousFunctionNamingPolicy.OFF;\\n-    RenameVars rn \\u003d new RenameVars(\\n-        this, renamePrefix,\\n-        renameLocalVarsOnly, preserveAnonymousFunctionNames,\\n-        generatePseudoNames,\\n-        prevVariableMap,\\n-        anonFunctionNamePolicy.getReservedCharacters(),\\n-        getPassConfig().getExportedNames());\\n-    process(rn);\\n-    variableMap_ \\u003d rn.getVariableMap();\\n-    endPass();\\n-  }\\n-\\n-  void renameProperties(boolean generatePseudoNames,\\n-      AnonymousFunctionNamingPolicy anonFunctionNamePolicy,\\n-      VariableMap prevPropertyMap) {\\n-    logger_.info(\\\"Renaming properties\\\");\\n-    startPass(\\\"renameProperties\\\");\\n-    RenameProperties rp \\u003d new RenameProperties(\\n-        this, generatePseudoNames, prevPropertyMap,\\n-        anonFunctionNamePolicy.getReservedCharacters());\\n-    process(rp);\\n-    propertyMap_ \\u003d rp.getPropertyMap();\\n-    endPass();\\n-  }\\n-\\n-  void invertContextualRenaming() {\\n-    logger_.info(\\\"Denormalizing local names\\\");\\n-    startPass(\\\"invertNames\\\");\\n-    process(MakeDeclaredNamesUnique.getContextualRenameInverter(this));\\n-    endPass();\\n-  }\\n-\\n-  void renamePrototypes(boolean aggressive,\\n-      AnonymousFunctionNamingPolicy anonFunctionNamePolicy,\\n-      VariableMap prevPropertyMap) {\\n-    logger_.info(\\\"Renaming prototypes\\\");\\n-    startPass(\\\"renamePrototypes\\\");\\n-    RenamePrototypes rp \\u003d new RenamePrototypes(this, aggressive,\\n-        anonFunctionNamePolicy.getReservedCharacters(),\\n-        prevPropertyMap);\\n-    process(rp);\\n-    propertyMap_ \\u003d rp.getPropertyMap();\\n-    endPass();\\n-  }\\n-\\n-  void renameLabels() {\\n-    logger_.info(\\\"Renaming labels\\\");\\n-    startPass(\\\"renameLabels\\\");\\n-    RenameLabels rn \\u003d new RenameLabels(this);\\n-    process(rn);\\n-    endPass();\\n-  }\\n-\\n-  void convertToDottedProperties() {\\n-    logger_.info(\\\"Converting quoted property accesses to dot syntax\\\");\\n-    startPass(\\\"convertToDottedProperties\\\");\\n-    process(new ConvertToDottedProperties(this));\\n-    endPass();\\n-  }\\n-\\n-  void instrumentFunctions() {\\n-    logger_.info(\\\"Instrumenting functions\\\");\\n-    startPass(\\\"instrumentFunctions\\\");\\n-    try {\\n-      FileReader templateFile \\u003d\\n-          new FileReader(options_.instrumentationTemplate);\\n-\\n-      process(new InstrumentFunctions(this,\\n-                                      functionNames_,\\n-                                      options_.instrumentationTemplate,\\n-                                      options_.appNameStr,\\n-                                      templateFile));\\n-    } catch (IOException e) {\\n-      report(JSError.make(READ_ERROR, options_.instrumentationTemplate));\\n-    }\\n-    endPass();\\n-  }\\n-\\n   void recordFunctionInformation() {\\n     logger_.info(\\\"Recording function information\\\");\\n     startPass(\\\"recordFunctionInformation\\\");\\n     RecordFunctionInformation recordFunctionInfoPass \\u003d\\n-        new RecordFunctionInformation(this, functionNames_);\\n+        new RecordFunctionInformation(\\n+            this, getPassConfig().getIntermediateState().functionNames);\\n     process(recordFunctionInfoPass);\\n     functionInformationMap_ \\u003d recordFunctionInfoPass.getMap();\\n     endPass();\\n@@ -1926,11 +1525,11 @@\\n   }\\n \\n   VariableMap getVariableMap() {\\n-    return variableMap_;\\n+    return getPassConfig().getIntermediateState().variableMap;\\n   }\\n \\n   VariableMap getPropertyMap() {\\n-    return propertyMap_;\\n+    return getPassConfig().getIntermediateState().propertyMap;\\n   }\\n \\n   CompilerOptions getOptions() {\\n@@ -1983,7 +1582,6 @@\\n     private CompilerInput[] externs;\\n     private CompilerInput[] inputs;\\n     private JSModule[] modules;\\n-    private FunctionNames functionNames;\\n     private PassConfig.State passConfigState;\\n     private JSTypeRegistry typeRegistry;\\n     private boolean normalized;\\n@@ -2001,7 +1599,6 @@\\n     state.externs \\u003d externs_;\\n     state.inputs \\u003d inputs_;\\n     state.modules \\u003d modules_;\\n-    state.functionNames \\u003d functionNames_;\\n     state.passConfigState \\u003d getPassConfig().getIntermediateState();\\n     state.typeRegistry \\u003d typeRegistry;\\n     state.normalized \\u003d normalized;\\n@@ -2019,7 +1616,6 @@\\n     externs_ \\u003d state.externs;\\n     inputs_ \\u003d state.inputs;\\n     modules_ \\u003d state.modules;\\n-    functionNames_ \\u003d state.functionNames;\\n     passes \\u003d createPassConfigInternal();\\n     getPassConfig().setIntermediateState(state.passConfigState);\\n     typeRegistry \\u003d state.typeRegistry;\\n\",\ndiff --git a/src/com/google/javascript/jscomp/ControlStructureCheck.java b/src/com/google/javascript/jscomp/ControlStructureCheck.java\nindex 5c2c276..a2984f1 100644\n--- a/src/com/google/javascript/jscomp/ControlStructureCheck.java\n+++ b/src/com/google/javascript/jscomp/ControlStructureCheck.java\n@@ -16,6 +16,7 @@\n \n package com.google.javascript.jscomp;\n \n+import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n@@ -48,6 +49,10 @@\n       \"JSC_INVALID_LABEL_CONTINUE\",\n       \"continue can only target labels of loop structures\");\n \n+  static final DiagnosticType USE_OF_WITH \u003d DiagnosticType.warning(\n+      \"JSC_USE_OF_WITH\",\n+      \"The use of the \u0027with\u0027 structure should be avoided.\");\n+\n   ControlStructureCheck(AbstractCompiler compiler) {\n     this.compiler \u003d compiler;\n   }\n@@ -79,6 +84,15 @@\n    */\n   private void check(Node node, boolean inLoop, boolean inSwitch) {\n     switch (node.getType()) {\n+      case Token.WITH:\n+        JSDocInfo info \u003d node.getJSDocInfo();\n+        boolean allowWith \u003d\n+            info !\u003d null \u0026\u0026 info.getSuppressions().contains(\"with\");\n+        if (!allowWith) {\n+          report(node, USE_OF_WITH);\n+        }\n+        break;\n+\n       case Token.FUNCTION:\n         // Save the old labels because we are in a new scope.\n         Deque\u003cString\u003e oldSwitchLabels \u003d switchLabels;\ndiff --git a/src/com/google/javascript/jscomp/DefaultPassConfig.java b/src/com/google/javascript/jscomp/DefaultPassConfig.java\nindex 2f3afb4..ac82dcd 100644\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n@@ -21,6 +21,7 @@\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n import com.google.common.io.Files;\n import com.google.javascript.jscomp.CheckLevel;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n@@ -28,10 +29,14 @@\n import com.google.javascript.rhino.Token;\n \n import java.io.File;\n+import java.io.FileReader;\n import java.io.IOException;\n+import java.text.ParseException;\n import java.util.Collection;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n \n /**\n  * Pass factories and meta-data for native JSCompiler passes.\n@@ -64,6 +69,14 @@\n       DiagnosticType.error(\"JSC_REPORT_PATH_IO_ERROR\",\n           \"Error writing compiler report to {0}\");\n \n+  private static final DiagnosticType INPUT_MAP_PROP_PARSE \u003d\n+      DiagnosticType.error(\"JSC_INPUT_MAP_PROP_PARSE\",\n+          \"Input property map parse error: {0}\");\n+\n+  private static final DiagnosticType INPUT_MAP_VAR_PARSE \u003d\n+      DiagnosticType.error(\"JSC_INPUT_MAP_VAR_PARSE\",\n+          \"Input variable map parse error: {0}\");\n+\n   /**\n    * A global namespace to share across checking passes.\n    * TODO(nicksantos): This is a hack until I can get the namespace into\n@@ -76,14 +89,76 @@\n    */\n   private TightenTypes tightenTypes \u003d null;\n \n+  /** Names exported by goog.exportSymbol. */\n+  private Set\u003cString\u003e exportedNames \u003d null;\n+\n+  /**\n+   * Ids for cross-module method stubbing, so that each method has\n+   * a unique id.\n+   */\n+  private CrossModuleMethodMotion.IdGenerator crossModuleIdGenerator \u003d\n+      new CrossModuleMethodMotion.IdGenerator();\n+\n+  /**\n+   * Keys are arguments passed to getCssName() found during compilation; values\n+   * are the number of times the key appeared as an argument to getCssName().\n+   */\n+  private Map\u003cString, Integer\u003e cssNames \u003d null;\n+\n+  /** The variable renaming map */\n+  private VariableMap variableMap \u003d null;\n+\n+  /** The property renaming map */\n+  private VariableMap propertyMap \u003d null;\n+\n+  /** The naming map for anonymous functions */\n+  private VariableMap anonymousFunctionNameMap \u003d null;\n+\n+  /** Fully qualified function names and globally unique ids */\n+  private FunctionNames functionNames \u003d null;\n+\n   public DefaultPassConfig(CompilerOptions options) {\n     super(options);\n   }\n \n   @Override\n+  State getIntermediateState() {\n+    return new State(\n+        cssNames \u003d\u003d null ? null : Maps.newHashMap(cssNames),\n+        exportedNames \u003d\u003d null ? null :\n+            Collections.unmodifiableSet(exportedNames),\n+        crossModuleIdGenerator, variableMap, propertyMap,\n+        anonymousFunctionNameMap, functionNames);\n+  }\n+\n+  @Override\n+  void setIntermediateState(State state) {\n+    this.cssNames \u003d state.cssNames \u003d\u003d null ? null :\n+        Maps.newHashMap(state.cssNames);\n+    this.exportedNames \u003d state.exportedNames \u003d\u003d null ? null :\n+        Sets.newHashSet(state.exportedNames);\n+    this.crossModuleIdGenerator \u003d state.crossModuleIdGenerator;\n+    this.variableMap \u003d state.variableMap;\n+    this.propertyMap \u003d state.propertyMap;\n+    this.anonymousFunctionNameMap \u003d state.anonymousFunctionNameMap;\n+    this.functionNames \u003d state.functionNames;\n+  }\n+\n+  @Override\n   protected List\u003cPassFactory\u003e getChecks() {\n     List\u003cPassFactory\u003e checks \u003d Lists.newArrayList();\n \n+    if (options.nameAnonymousFunctionsOnly) {\n+      if (options.anonymousFunctionNaming \u003d\u003d\n+          AnonymousFunctionNamingPolicy.MAPPED) {\n+        checks.add(nameMappedAnonymousFunctions);\n+      } else if (options.anonymousFunctionNaming \u003d\u003d\n+          AnonymousFunctionNamingPolicy.UNMAPPED) {\n+        checks.add(nameUnmappedAnonymousFunctions);\n+      }\n+      return checks;\n+    }\n+\n     if (options.checkSuspiciousCode) {\n       checks.add(suspiciousCode);\n     }\n@@ -198,6 +273,12 @@\n \n     // Defines in code always need to be processed.\n     checks.add(processDefines);\n+\n+    if (options.instrumentationTemplate !\u003d null ||\n+        options.recordFunctionInformation) {\n+      checks.add(computeFunctionNames);\n+    }\n+\n     assertAllOneTimePasses(checks);\n     return checks;\n   }\n@@ -318,6 +399,119 @@\n           CustomPassExecutionTime.AFTER_OPTIMIZATION_LOOP));\n     }\n \n+    if (options.flowSensitiveInlineVariables) {\n+      passes.add(flowSensitiveInlineVariables);\n+    }\n+\n+    if (options.collapseAnonymousFunctions) {\n+      passes.add(collapseAnonymousFunctions);\n+    }\n+\n+    // Move functions before extracting prototype member declarations.\n+    if (options.moveFunctionDeclarations) {\n+      passes.add(moveFunctionDeclarations);\n+    }\n+\n+    if (options.anonymousFunctionNaming \u003d\u003d\n+        AnonymousFunctionNamingPolicy.MAPPED) {\n+      passes.add(nameMappedAnonymousFunctions);\n+    }\n+\n+    // The mapped name anonymous function pass makes use of information that\n+    // the extract prototype member declarations pass removes so the former\n+    // happens before the latter.\n+    //\n+    // Extracting prototype properties screws up the heuristic renaming\n+    // policies, so never run it when those policies are requested.\n+    if (options.extractPrototypeMemberDeclarations \u0026\u0026\n+        (options.propertyRenaming !\u003d PropertyRenamingPolicy.HEURISTIC \u0026\u0026\n+         options.propertyRenaming !\u003d\n+            PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC)) {\n+      passes.add(extractPrototypeMemberDeclarations);\n+    }\n+\n+    if (options.coalesceVariableNames) {\n+      passes.add(coalesceVariableNames);\n+    }\n+\n+    if (options.ambiguateProperties \u0026\u0026\n+        (options.propertyRenaming \u003d\u003d PropertyRenamingPolicy.ALL_UNQUOTED)) {\n+      passes.add(ambiguateProperties);\n+    }\n+\n+    if (options.propertyRenaming !\u003d PropertyRenamingPolicy.OFF) {\n+      passes.add(renameProperties);\n+    }\n+\n+    // This comes after property renaming because quoted property names must\n+    // not be renamed.\n+    if (options.convertToDottedProperties) {\n+      passes.add(convertToDottedProperties);\n+    }\n+\n+    // Property renaming must happen before this pass runs since this\n+    // pass may convert dotted properties into quoted properties.  It\n+    // is beneficial to run before alias strings, alias keywords and\n+    // variable renaming.\n+    if (options.rewriteFunctionExpressions) {\n+      passes.add(rewriteFunctionExpressions);\n+    }\n+\n+    // This comes after converting quoted property accesses to dotted property\n+    // accesses in order to avoid aliasing property names.\n+    if (!options.aliasableStrings.isEmpty() || options.aliasAllStrings) {\n+      passes.add(aliasStrings);\n+    }\n+\n+    if (options.aliasExternals) {\n+      passes.add(aliasExternals);\n+    }\n+\n+    if (options.aliasKeywords) {\n+      passes.add(aliasKeywords);\n+    }\n+\n+    if (options.collapseVariableDeclarations) {\n+      passes.add(collapseVariableDeclarations);\n+    }\n+\n+    passes.add(denormalize);\n+\n+    if (options.instrumentationTemplate !\u003d null) {\n+      passes.add(instrumentFunctions);\n+    }\n+\n+    if (options.variableRenaming !\u003d VariableRenamingPolicy.ALL) {\n+      // If we\u0027re leaving some (or all) variables with their old names,\n+      // then we need to undo any of the markers we added for distinguishing\n+      // local variables (\"$$1\") or constants (\"$$constant\").\n+      passes.add(invertContextualRenaming);\n+    }\n+\n+\n+    if (options.variableRenaming !\u003d VariableRenamingPolicy.OFF) {\n+      passes.add(renameVars);\n+    }\n+\n+    // This pass should run after names stop changing.\n+    if (options.processObjectPropertyString) {\n+      passes.add(objectPropertyStringPostprocess);\n+    }\n+\n+    if (options.labelRenaming) {\n+      passes.add(renameLabels);\n+    }\n+\n+    if (options.anonymousFunctionNaming \u003d\u003d\n+        AnonymousFunctionNamingPolicy.UNMAPPED) {\n+      passes.add(nameUnmappedAnonymousFunctions);\n+    }\n+\n+    // Safety check\n+    if (options.checkSymbols) {\n+      passes.add(sanityCheckVars);\n+    }\n+\n     return passes;\n   }\n \n@@ -492,7 +686,7 @@\n         @Override\n         public void process(Node externs, Node root) {\n           pass.process(externs, root);\n-          setExportedNames(pass.getExportedVariableNames());\n+          exportedNames \u003d pass.getExportedVariableNames();\n         }\n       };\n     }\n@@ -523,13 +717,13 @@\n       return new CompilerPass() {\n         @Override\n         public void process(Node externs, Node jsRoot) {\n-          Map\u003cString, Integer\u003e cssNames \u003d null;\n+          Map\u003cString, Integer\u003e newCssNames \u003d null;\n           if (options.gatherCssNames) {\n-            cssNames \u003d Maps.newHashMap();\n+            newCssNames \u003d Maps.newHashMap();\n           }\n-          (new ReplaceCssNames(compiler, cssNames)).process(\n+          (new ReplaceCssNames(compiler, newCssNames)).process(\n               externs, jsRoot);\n-          setCssNames(cssNames);\n+          cssNames \u003d newCssNames;\n         }\n       };\n     }\n@@ -792,6 +986,15 @@\n     }\n   };\n \n+  /** Computes the names of functions for later analysis. */\n+  private final PassFactory computeFunctionNames \u003d\n+      new PassFactory(\"computeFunctionNames\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return ((functionNames \u003d new FunctionNames(compiler)));\n+    }\n+  };\n+\n   /** Generates unique ids. */\n   private final PassFactory replaceIdGenerators \u003d\n       new PassFactory(\"replaceIdGenerators\", true) {\n@@ -1131,13 +1334,347 @@\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n       return new CrossModuleMethodMotion(\n-          compiler, getCrossModuleIdGenerator(),\n+          compiler, crossModuleIdGenerator,\n           // Only move properties in externs if we\u0027re not treating\n           // them as exports.\n           options.removeUnusedPrototypePropertiesInExterns);\n     }\n   };\n \n+  /** A data-flow based variable inliner. */\n+  private final PassFactory flowSensitiveInlineVariables \u003d\n+      new PassFactory(\"flowSensitiveInlineVariables\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new FlowSensitiveInlineVariables(compiler);\n+    }\n+  };\n+\n+  /** Uses register-allocation algorithms to use fewer variables. */\n+  private final PassFactory coalesceVariableNames \u003d\n+      new PassFactory(\"coalesceVariableNames\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new CoalesceVariableNames(compiler);\n+    }\n+  };\n+\n+  /**\n+   * Some simple, local collapses (e.g., {@code var x; var y;} becomes\n+   * {@code var x,y;}.\n+   */\n+  private final PassFactory collapseVariableDeclarations \u003d\n+      new PassFactory(\"collapseVariableDeclarations\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      compiler.setUnnormalized();\n+      return new CollapseVariableDeclarations(compiler);\n+    }\n+  };\n+\n+  /**\n+   * Extracts common sub-expressions.\n+   */\n+  private final PassFactory extractPrototypeMemberDeclarations \u003d\n+      new PassFactory(\"extractPrototypeMemberDeclarations\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new ExtractPrototypeMemberDeclarations(compiler);\n+    }\n+  };\n+\n+  /** Rewrites common function definitions to be more compact. */\n+  private final PassFactory rewriteFunctionExpressions \u003d\n+      new PassFactory(\"rewriteFunctionExpressions\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new FunctionRewriter(compiler);\n+    }\n+  };\n+\n+  /** Collapses functions to not use the VAR keyword. */\n+  private final PassFactory collapseAnonymousFunctions \u003d\n+      new PassFactory(\"collapseAnonymousFunctions\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new CollapseAnonymousFunctions(compiler);\n+    }\n+  };\n+\n+  /** Moves function declarations to the top, to simulate actual hoisting. */\n+  private final PassFactory moveFunctionDeclarations \u003d\n+      new PassFactory(\"moveFunctionDeclarations\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new MoveFunctionDeclarations(compiler);\n+    }\n+  };\n+\n+  private final PassFactory nameUnmappedAnonymousFunctions \u003d\n+      new PassFactory(\"nameAnonymousFunctions\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new NameAnonymousFunctions(compiler);\n+    }\n+  };\n+\n+  private final PassFactory nameMappedAnonymousFunctions \u003d\n+      new PassFactory(\"nameAnonymousFunctions\", true) {\n+    @Override\n+    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+      return new CompilerPass() {\n+        @Override public void process(Node externs, Node root) {\n+          NameAnonymousFunctionsMapped naf \u003d\n+              new NameAnonymousFunctionsMapped(compiler);\n+          naf.process(externs, root);\n+          anonymousFunctionNameMap \u003d naf.getFunctionMap();\n+        }\n+      };\n+    }\n+  };\n+\n+  /** Alias external symbols. */\n+  private final PassFactory aliasExternals \u003d\n+      new PassFactory(\"aliasExternals\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new AliasExternals(compiler, compiler.getModuleGraph(),\n+          options.unaliasableGlobals, options.aliasableGlobals);\n+    }\n+  };\n+\n+  /**\n+   * Alias string literals with global variables, to avoid creating lots of\n+   * transient objects.\n+   */\n+  private final PassFactory aliasStrings \u003d\n+      new PassFactory(\"aliasStrings\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new AliasStrings(\n+          compiler,\n+          compiler.getModuleGraph(),\n+          options.aliasAllStrings ? null : options.aliasableStrings,\n+          options.aliasStringsBlacklist,\n+          options.outputJsStringUsage);\n+    }\n+  };\n+\n+  /** Aliases common keywords (true, false) */\n+  private final PassFactory aliasKeywords \u003d\n+      new PassFactory(\"aliasKeywords\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new AliasKeywords(compiler);\n+    }\n+  };\n+\n+  /** Handling for the ObjectPropertyString primitive. */\n+  private final PassFactory objectPropertyStringPostprocess \u003d\n+      new PassFactory(\"ObjectPropertyStringPostprocess\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new ObjectPropertyStringPostprocess(compiler);\n+    }\n+  };\n+\n+  /**\n+   * Renames properties so that the two properties that never appear on\n+   * the same object get the same name.\n+   */\n+  private final PassFactory ambiguateProperties \u003d\n+      new PassFactory(\"ambiguateProperties\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new AmbiguateProperties(\n+          compiler, options.anonymousFunctionNaming.getReservedCharacters());\n+    }\n+  };\n+\n+  /** Normalizes the AST for optimizations. */\n+  private final PassFactory normalize \u003d\n+      new PassFactory(\"normalize\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      compiler.setNormalized();\n+      return new Normalize(compiler, false);\n+    }\n+  };\n+\n+  /** Denormalize the AST for code generation. */\n+  private final PassFactory denormalize \u003d\n+      new PassFactory(\"denormalize\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      compiler.setUnnormalized();\n+      return new Denormalize(compiler);\n+    }\n+  };\n+\n+  /** Inverting name normalization. */\n+  private final PassFactory invertContextualRenaming \u003d\n+      new PassFactory(\"invertNames\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return MakeDeclaredNamesUnique.getContextualRenameInverter(compiler);\n+    }\n+  };\n+\n+  /**\n+   * Renames properties.\n+   */\n+  private final PassFactory renameProperties \u003d\n+      new PassFactory(\"renameProperties\", true) {\n+    @Override\n+    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+      VariableMap map \u003d null;\n+      if (options.inputPropertyMapSerialized !\u003d null) {\n+        try {\n+          map \u003d VariableMap.fromBytes(options.inputPropertyMapSerialized);\n+        } catch (ParseException e) {\n+          return new ErrorPass(compiler,\n+              JSError.make(INPUT_MAP_PROP_PARSE, e.getMessage()));\n+        }\n+      }\n+\n+      final VariableMap prevPropertyMap \u003d map;\n+      return new CompilerPass() {\n+        @Override public void process(Node externs, Node root) {\n+          propertyMap \u003d runPropertyRenaming(\n+              compiler, prevPropertyMap, externs, root);\n+        }\n+      };\n+    }\n+  };\n+\n+  private VariableMap runPropertyRenaming(\n+      AbstractCompiler compiler, VariableMap prevPropertyMap,\n+      Node externs, Node root) {\n+    char[] reservedChars \u003d\n+        options.anonymousFunctionNaming.getReservedCharacters();\n+    switch (options.propertyRenaming) {\n+      case HEURISTIC:\n+        RenamePrototypes rproto \u003d new RenamePrototypes(compiler, false,\n+            reservedChars, prevPropertyMap);\n+        rproto.process(externs, root);\n+        return rproto.getPropertyMap();\n+\n+      case AGGRESSIVE_HEURISTIC:\n+        RenamePrototypes rproto2 \u003d new RenamePrototypes(compiler, true,\n+            reservedChars, prevPropertyMap);\n+        rproto2.process(externs, root);\n+        return rproto2.getPropertyMap();\n+\n+      case ALL_UNQUOTED:\n+        RenameProperties rprop \u003d new RenameProperties(\n+            compiler, options.generatePseudoNames, prevPropertyMap,\n+            reservedChars);\n+        rprop.process(externs, root);\n+        return rprop.getPropertyMap();\n+\n+      default:\n+        throw new IllegalStateException(\n+            \"Unrecognized property renaming policy\");\n+    }\n+  }\n+\n+  /** Renames variables. */\n+  private final PassFactory renameVars \u003d\n+      new PassFactory(\"renameVars\", true) {\n+    @Override\n+    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+      VariableMap map \u003d null;\n+      if (options.inputVariableMapSerialized !\u003d null) {\n+        try {\n+          map \u003d VariableMap.fromBytes(options.inputVariableMapSerialized);\n+        } catch (ParseException e) {\n+          return new ErrorPass(compiler,\n+              JSError.make(INPUT_MAP_VAR_PARSE, e.getMessage()));\n+        }\n+      }\n+\n+      final VariableMap prevVariableMap \u003d map;\n+      return new CompilerPass() {\n+        @Override public void process(Node externs, Node root) {\n+          variableMap \u003d runVariableRenaming(\n+              compiler, prevVariableMap, externs, root);\n+        }\n+      };\n+    }\n+  };\n+\n+  private VariableMap runVariableRenaming(\n+      AbstractCompiler compiler, VariableMap prevVariableMap,\n+      Node externs, Node root) {\n+    char[] reservedChars \u003d\n+        options.anonymousFunctionNaming.getReservedCharacters();\n+    boolean preserveAnonymousFunctionNames \u003d\n+        options.anonymousFunctionNaming !\u003d AnonymousFunctionNamingPolicy.OFF;\n+    RenameVars rn \u003d new RenameVars(\n+        compiler,\n+        options.renamePrefix,\n+        options.variableRenaming \u003d\u003d VariableRenamingPolicy.LOCAL,\n+        preserveAnonymousFunctionNames,\n+        options.generatePseudoNames,\n+        prevVariableMap,\n+        reservedChars,\n+        exportedNames);\n+    rn.process(externs, root);\n+    return rn.getVariableMap();\n+  }\n+\n+  /** Renames labels */\n+  private final PassFactory renameLabels \u003d\n+      new PassFactory(\"renameLabels\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new RenameLabels(compiler);\n+    }\n+  };\n+\n+  /** Convert bracket access to dot access */\n+  private final PassFactory convertToDottedProperties \u003d\n+      new PassFactory(\"convertToDottedProperties\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new ConvertToDottedProperties(compiler);\n+    }\n+  };\n+\n+  /** Checks that all variables are defined. */\n+  private final PassFactory sanityCheckVars \u003d\n+      new PassFactory(\"sanityCheckVars\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new VarCheck(compiler, true);\n+    }\n+  };\n+\n+  /** Adds instrumentations according to an instrumentation template. */\n+  private final PassFactory instrumentFunctions \u003d\n+      new PassFactory(\"instrumentFunctions\", true) {\n+    @Override\n+    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+      return new CompilerPass() {\n+        @Override public void process(Node externs, Node root) {\n+          try {\n+            FileReader templateFile \u003d\n+                new FileReader(options.instrumentationTemplate);\n+            (new InstrumentFunctions(\n+                compiler, functionNames,\n+                options.instrumentationTemplate,\n+                options.appNameStr,\n+                templateFile)).process(externs, root);\n+          } catch (IOException e) {\n+            compiler.report(\n+                JSError.make(AbstractCompiler.READ_ERROR,\n+                    options.instrumentationTemplate));\n+          }\n+        }\n+      };\n+    }\n+  };\n+\n   /**\n    * Create a no-op pass that can only run once. Used to break up loops.\n    */\n@@ -1210,16 +1747,20 @@\n   /** A compiler pass that just reports an error. */\n   private static class ErrorPass implements CompilerPass {\n     private final AbstractCompiler compiler;\n-    private final DiagnosticType error;\n+    private final JSError error;\n \n     private ErrorPass(AbstractCompiler compiler, DiagnosticType error) {\n+      this(compiler, JSError.make(error));\n+    }\n+\n+    private ErrorPass(AbstractCompiler compiler, JSError error) {\n       this.compiler \u003d compiler;\n       this.error \u003d error;\n     }\n \n     @Override\n     public void process(Node externs, Node root) {\n-      compiler.report(JSError.make(error));\n+      compiler.report(error);\n     }\n   }\n \ndiff --git a/src/com/google/javascript/jscomp/JsAst.java b/src/com/google/javascript/jscomp/JsAst.java\nindex f3f4b5c..28f4c34 100644\n--- a/src/com/google/javascript/jscomp/JsAst.java\n+++ b/src/com/google/javascript/jscomp/JsAst.java\n@@ -78,7 +78,7 @@\n       parse(compiler, sourceFile.getName(), sourceFile.getCode());\n     } catch (IOException e) {\n       compiler.report(\n-          JSError.make(Compiler.READ_ERROR, sourceFile.getName()));\n+          JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\n     }\n   }\n \n@@ -91,7 +91,7 @@\n           compiler.getDefaultErrorReporter(),\n           logger_);\n     } catch (IOException e) {\n-      compiler.report(JSError.make(Compiler.READ_ERROR, sourceName));\n+      compiler.report(JSError.make(AbstractCompiler.READ_ERROR, sourceName));\n     }\n \n     if (root \u003d\u003d null) {\ndiff --git a/src/com/google/javascript/jscomp/PassConfig.java b/src/com/google/javascript/jscomp/PassConfig.java\nindex 5be9c78..f080f9a 100644\n--- a/src/com/google/javascript/jscomp/PassConfig.java\n+++ b/src/com/google/javascript/jscomp/PassConfig.java\n@@ -17,11 +17,8 @@\n package com.google.javascript.jscomp;\n \n \n-import com.google.common.collect.Maps;\n-import com.google.common.collect.Sets;\n \n import java.io.Serializable;\n-import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n@@ -36,16 +33,6 @@\n   // Used by subclasses in this package.\n   final CompilerOptions options;\n \n-  /** Names exported by goog.exportSymbol. */\n-  private Set\u003cString\u003e exportedNames \u003d null;\n-\n-  /**\n-   * Ids for cross-module method stubbing, so that each method has\n-   * a unique id.\n-   */\n-  private CrossModuleMethodMotion.IdGenerator crossModuleIdGenerator \u003d\n-      new CrossModuleMethodMotion.IdGenerator();\n-\n   /**\n    * A memoized version of scopeCreator. It must be memoized so that\n    * we can make two separate passes over the AST, one for inferring types\n@@ -56,65 +43,10 @@\n   /** The global typed scope. */\n   Scope topScope \u003d null;\n \n-  /**\n-   * Keys are arguments passed to getCssName() found during compilation; values\n-   * are the number of times the key appeared as an argument to getCssName().\n-   */\n-  private Map\u003cString, Integer\u003e cssNames \u003d null;\n-\n   public PassConfig(CompilerOptions options) {\n     this.options \u003d options;\n   }\n \n-  // Setters and getters for intermediate state.\n-  //\n-  // This makes it possible to start and stop the compiler mid-compile.\n-  // Each getter and setter corresponds to a type of state that is produced\n-  // by an earlier pass and consumed by a later pass. When the compiler is\n-  // stopped mid-compile, the getter should return any state which has\n-  // been produced, and the setter should restore that state when the compiler\n-  // is restarted.\n-  //\n-  // TODO(nicksantos): Perhaps we should just make PassConfig serializable.\n-\n-  /**\n-   * Gets a map of CSS names found in the JS code, to the number of times\n-   * they appear.\n-   */\n-  Map\u003cString, Integer\u003e getCssNames() {\n-    return cssNames \u003d\u003d null ? null : Maps.newHashMap(cssNames);\n-  }\n-\n-  /**\n-   * Gets the symbols exported by the passes.\n-   */\n-  Set\u003cString\u003e getExportedNames() {\n-    return exportedNames \u003d\u003d null ? null :\n-        Collections.unmodifiableSet(exportedNames);\n-  }\n-\n-  /**\n-   * Gets a generator for cross-module method ids, so that the ids\n-   * are stable across compiled.\n-   */\n-  CrossModuleMethodMotion.IdGenerator getCrossModuleIdGenerator() {\n-    return crossModuleIdGenerator;\n-  }\n-\n-  /**\n-   * Sets the map of CSS names found in the JS code during previous runs.\n-   */\n-  void setCssNames(Map\u003cString, Integer\u003e newVal) {\n-    cssNames \u003d newVal \u003d\u003d null ? null : Maps.newHashMap(newVal);\n-  }\n-\n-  /**\n-   * Sets the symbols exported by previous passes.\n-   */\n-  void setExportedNames(Set\u003cString\u003e newVal) {\n-    exportedNames \u003d newVal \u003d\u003d null ? null : Sets.newHashSet(newVal);\n-  }\n-\n   /**\n    * Gets the scope creator for typed scopes.\n    */\n@@ -202,20 +134,13 @@\n    * Get intermediate state for a running pass config, so it can\n    * be paused and started again later.\n    */\n-  State getIntermediateState() {\n-    return new State(getCssNames(), getExportedNames(),\n-                     crossModuleIdGenerator);\n-  }\n+  abstract State getIntermediateState();\n \n   /**\n    * Set the intermediate state for a pass config, to restart\n    * a compilation process that had been previously paused.\n    */\n-  void setIntermediateState(State state) {\n-    setCssNames(state.cssNames);\n-    setExportedNames(state.exportedNames);\n-    crossModuleIdGenerator \u003d state.crossModuleIdGenerator;\n-  }\n+  abstract void setIntermediateState(State state);\n \n   /**\n    * An implementation of PassConfig that just proxies all its method calls\n@@ -238,22 +163,6 @@\n       return delegate.getOptimizations();\n     }\n \n-    @Override Map\u003cString, Integer\u003e getCssNames() {\n-      return delegate.getCssNames();\n-    }\n-\n-    @Override Set\u003cString\u003e getExportedNames() {\n-      return delegate.getExportedNames();\n-    }\n-\n-    @Override void setCssNames(Map\u003cString, Integer\u003e newVal) {\n-      delegate.setCssNames(newVal);\n-    }\n-\n-    @Override void setExportedNames(Set\u003cString\u003e newVal) {\n-      delegate.setExportedNames(newVal);\n-    }\n-\n     @Override ScopeCreator getScopeCreator() {\n       return delegate.getScopeCreator();\n     }\n@@ -277,15 +186,25 @@\n   static class State implements Serializable {\n     private static final long serialVersionUID \u003d 1L;\n \n-    private final Map\u003cString, Integer\u003e cssNames;\n-    private final Set\u003cString\u003e exportedNames;\n-    private final CrossModuleMethodMotion.IdGenerator crossModuleIdGenerator;\n+    final Map\u003cString, Integer\u003e cssNames;\n+    final Set\u003cString\u003e exportedNames;\n+    final CrossModuleMethodMotion.IdGenerator crossModuleIdGenerator;\n+    final VariableMap variableMap;\n+    final VariableMap propertyMap;\n+    final VariableMap anonymousFunctionNameMap;\n+    final FunctionNames functionNames;\n \n-    private State(Map\u003cString, Integer\u003e cssNames, Set\u003cString\u003e exportedNames,\n-                  CrossModuleMethodMotion.IdGenerator crossModuleIdGenerator) {\n+    State(Map\u003cString, Integer\u003e cssNames, Set\u003cString\u003e exportedNames,\n+          CrossModuleMethodMotion.IdGenerator crossModuleIdGenerator,\n+          VariableMap variableMap, VariableMap propertyMap,\n+          VariableMap anonymousFunctionNameMap, FunctionNames functionNames) {\n       this.cssNames \u003d cssNames;\n       this.exportedNames \u003d exportedNames;\n       this.crossModuleIdGenerator \u003d crossModuleIdGenerator;\n+      this.variableMap \u003d variableMap;\n+      this.propertyMap \u003d propertyMap;\n+      this.anonymousFunctionNameMap \u003d anonymousFunctionNameMap;\n+      this.functionNames \u003d functionNames;\n     }\n   }\n }\ndiff --git a/src/com/google/javascript/jscomp/TightenTypes.java b/src/com/google/javascript/jscomp/TightenTypes.java\nindex 9fd9512..7e0d309 100644\n--- a/src/com/google/javascript/jscomp/TightenTypes.java\n+++ b/src/com/google/javascript/jscomp/TightenTypes.java\n@@ -107,6 +107,12 @@\n   private final Map\u003cObjectType, ConcreteInstanceType\u003e instanceFromJSType \u003d\n       Maps.newHashMap();\n \n+  /**\n+   * Memoized results of \"createTypeIntersection\" calls.\n+   */\n+  private final Map\u003cConcreteJSTypePair, ConcreteType\u003e typeIntersectionMemos \u003d\n+      Maps.newHashMap();\n+\n   /** Scope storing the top-level variables and functions. */\n   private ConcreteScope topScope;\n \n@@ -433,8 +439,11 @@\n       assigns.add(new Assignment((ConcreteSlot) fType.getThisSlot(), thisType));\n       for (int i \u003d 0; i \u003c argTypes.size(); ++i) {\n         ConcreteSlot variable \u003d (ConcreteSlot) fType.getParameterSlot(i);\n-        Preconditions.checkState(variable !\u003d null);\n-        assigns.add(new Assignment(variable, argTypes.get(i)));\n+        // TODO(johnlenz): Support \"arguments\" references in function bodies.\n+        // For now, ignore anonymous arguments.\n+        if (variable !\u003d null) {\n+          assigns.add(new Assignment(variable, argTypes.get(i)));\n+        }\n       }\n     }\n     return assigns;\n@@ -510,7 +519,11 @@\n              : recvType.getFunctionInstanceTypes()) {\n           thisType \u003d thisType.unionWith(instType);\n         }\n-        allInstantiatedTypes.add(thisType);\n+        boolean added \u003d allInstantiatedTypes.add(thisType);\n+        if (added) {\n+          // A new type instance invalidates the cached type intersections.\n+          typeIntersectionMemos.clear();\n+        }\n       }\n \n       List\u003cConcreteType\u003e argTypes \u003d Lists.newArrayList();\n@@ -537,7 +550,9 @@\n     }\n \n     public Collection\u003cAssignment\u003e getAssignments(ConcreteScope scope) {\n-      ConcreteType thisType \u003d inferConcreteType(scope, firstArgument);\n+      ConcreteType thisType \u003d (firstArgument !\u003d null)\n+          ? inferConcreteType(scope, firstArgument)\n+          : getTopScope().getTypeOfThis();\n       ConcreteType recvType \u003d inferConcreteType(scope, receiver);\n \n       if (recvType instanceof ConcreteInstanceType \u0026\u0026\n@@ -1028,6 +1043,8 @@\n \n   /** Computes the concrete types that can result from the given expression. */\n   ConcreteType inferConcreteType(ConcreteScope scope, Node expr) {\n+    Preconditions.checkNotNull(scope);\n+    Preconditions.checkNotNull(expr);\n     ConcreteType ret;\n     switch (expr.getType()) {\n       case Token.NAME:\n@@ -1161,7 +1178,15 @@\n \n   private ConcreteType createTypeIntersection(\n       ConcreteType concreteType, JSType jsType) {\n-    ConcreteType ret;\n+    // TODO(johnlenz): Even with memoizing all the time of this pass is still \n+    // spent in this function (due to invalidation caused by changes to\n+    // allInstantiatedTypes), specifically calls to ConcreteUnionType.unionWith\n+    ConcreteJSTypePair key \u003d new ConcreteJSTypePair(concreteType, jsType);\n+    ConcreteType ret \u003d typeIntersectionMemos.get(key);\n+    if (ret !\u003d null) {\n+      return ret;\n+    }\n+\n     if (jsType \u003d\u003d null || jsType.isUnknownType() || concreteType.isNone()) {\n       ret \u003d concreteType;\n     } else if (concreteType.isUnion() || concreteType.isSingleton()) {\n@@ -1195,6 +1220,7 @@\n       }\n     }\n \n+    typeIntersectionMemos.put(key, ret);\n     return ret;\n   }\n \n@@ -1330,4 +1356,49 @@\n     }\n     return true;\n   }\n+\n+  /**\n+   * A simple class used to pair a concrete type and a js type.  Used to\n+   * memoize the results of a \"createTypeIntersection\" call.\n+   */\n+  static class ConcreteJSTypePair {\n+    final ConcreteType concrete;\n+    final JSType jstype;\n+    final int hashcode;\n+\n+    ConcreteJSTypePair(ConcreteType concrete, JSType jstype) {\n+      this.concrete \u003d concrete;\n+      this.jstype \u003d jstype;\n+      this.hashcode \u003d concrete.hashCode() + getJSTypeHashCode();\n+    }\n+\n+    private int getJSTypeHashCode() {\n+      return jstype !\u003d null ? jstype.hashCode() : 0;\n+    }\n+\n+    private boolean equalsJSType(JSType jsType) {\n+      if (jsType \u003d\u003d null || jstype \u003d\u003d null) {\n+        return jstype \u003d\u003d jsType;\n+      } else {\n+        return jsType.equals(this.jstype);\n+      }\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (o instanceof ConcreteJSTypePair) {\n+        ConcreteJSTypePair pair \u003d (ConcreteJSTypePair) o;\n+        if ((pair.concrete.equals(this.concrete)\n+            \u0026\u0026 equalsJSType(pair.jstype))) {\n+          return true;\n+        }\n+      }\n+      return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return hashcode;\n+    }\n+  }\n }\n"
    },
    "Closure-73": {
        "Buggy Function": "  static String strEscape(String s, char quote,\n                          String doublequoteEscape,\n                          String singlequoteEscape,\n                          String backslashEscape,\n                          CharsetEncoder outputCharsetEncoder) {\n    StringBuilder sb = new StringBuilder(s.length() + 2);\n    sb.append(quote);\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      switch (c) {\n        case '\\0': sb.append(\"\\\\0\"); break;\n        case '\\n': sb.append(\"\\\\n\"); break;\n        case '\\r': sb.append(\"\\\\r\"); break;\n        case '\\t': sb.append(\"\\\\t\"); break;\n        case '\\\\': sb.append(backslashEscape); break;\n        case '\\\"': sb.append(doublequoteEscape); break;\n        case '\\'': sb.append(singlequoteEscape); break;\n        case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n          if (i >= 2 &&\n              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n            sb.append(\"\\\\>\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        case '<':\n          // Break </script into <\\/script\n          final String END_SCRIPT = \"/script\";\n\n          // Break <!-- into <\\!--\n          final String START_COMMENT = \"!--\";\n\n          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                              END_SCRIPT.length())) {\n            sb.append(\"<\\\\\");\n          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                     START_COMMENT.length())) {\n            sb.append(\"<\\\\\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        default:\n          // If we're given an outputCharsetEncoder, then check if the\n          //  character can be represented in this character set.\n          if (outputCharsetEncoder != null) {\n            if (outputCharsetEncoder.canEncode(c)) {\n              sb.append(c);\n            } else {\n              // Unicode-escape the character.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          } else {\n            // No charsetEncoder provided - pass straight latin characters\n            // through, and escape the rest.  Doing the explicit character\n            // check is measurably faster than using the CharsetEncoder.\n            if (c > 0x1f && c <= 0x7f) {\n              sb.append(c);\n            } else {\n              // Other characters can be misinterpreted by some js parsers,\n              // or perhaps mangled by proxies along the way,\n              // so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          }\n      }\n    }\n    sb.append(quote);\n    return sb.toString();\n  }",
        "Inducing Changes": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex d9496d7..3c97fc4 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -16,12 +16,15 @@\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.base.Charsets;\n import com.google.common.base.Preconditions;\n import com.google.common.base.StringUtil;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.TokenStream;\n \n+import java.nio.charset.Charset;\n+import java.nio.charset.CharsetEncoder;\n \n /**\n  * CodeGenerator generates codes from a parse tree, sending it to the specified\n@@ -34,8 +37,23 @@\n \n   private final CodeConsumer cc;\n \n-  CodeGenerator(CodeConsumer consumer) {\n+  private final CharsetEncoder outputCharsetEncoder;\n+\n+  CodeGenerator(CodeConsumer consumer, Charset outputCharset) {\n     cc = consumer;\n+    if (outputCharset == null || outputCharset == Charsets.US_ASCII) {\n+      // If we want our default (pretending to be UTF-8, but escaping anything\n+      // outside of straight ASCII), then don't use the encoder, but\n+      // just special-case the code.  This keeps the normal path through\n+      // the code identical to how it's been for years.\n+      this.outputCharsetEncoder = null;\n+    } else {\n+      this.outputCharsetEncoder = outputCharset.newEncoder();\n+    }\n+  }\n+\n+  CodeGenerator(CodeConsumer consumer) {\n+    this(consumer, null);\n   }\n \n   void add(String str) {\n@@ -221,7 +239,7 @@\n           throw new Error(\"Expected children to be strings\");\n         }\n \n-        String regexp = regexpEscape(first.getString());\n+        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n \n         // I only use one .add because whitespace matters\n         if (childCount == 2) {\n@@ -495,7 +513,7 @@\n \n       case Token.STRING:\n         Preconditions.checkState(childCount == 0);\n-        add(jsString(n.getString()));\n+        add(jsString(n.getString(), outputCharsetEncoder));\n         break;\n \n       case Token.DELPROP:\n@@ -730,7 +748,7 @@\n   }\n \n   /** Outputs a js string, using the optimal (single/double) quote character */\n-  static String jsString(String s) {\n+  static String jsString(String s, CharsetEncoder outputCharsetEncoder) {\n     int singleq = 0, doubleq = 0;\n \n     // could count the quotes and pick the optimal quote character\n@@ -755,19 +773,28 @@\n       singlequote = \"\\'\";\n     }\n \n-    return strEscape(s, quote, doublequote, singlequote, \"\\\\\\\\\");\n+    return strEscape(s, quote, doublequote, singlequote, \"\\\\\\\\\",\n+        outputCharsetEncoder);\n   }\n \n   /** Escapes regular expression */\n+  static String regexpEscape(String s, CharsetEncoder outputCharsetEncoder) {\n+    return strEscape(s, '/', \"\\\"\", \"'\", \"\\\\\", outputCharsetEncoder);\n+  }\n+\n+  /* If the user doesn't want to specify an output charset encoder, assume\n+     they want Latin/ASCII characters only.\n+   */\n   static String regexpEscape(String s) {\n-    return strEscape(s, '/', \"\\\"\", \"'\", \"\\\\\");\n+    return regexpEscape(s, null);\n   }\n \n   /** Helper to escape javascript string as well as regular expression */\n   static String strEscape(String s, char quote,\n                           String doublequoteEscape,\n                           String singlequoteEscape,\n-                          String backslashEscape) {\n+                          String backslashEscape,\n+                          CharsetEncoder outputCharsetEncoder) {\n     StringBuilder sb = new StringBuilder();\n     sb.append(quote);\n     for (int i = 0; i < s.length(); i++) {\n@@ -798,15 +825,27 @@\n           }\n           break;\n         default:\n-          // Please keep in sync with the same code in identifierEscape().\n-          if (c > 0x1F && c < 0x7F) {\n-            // Non-control ASCII characters are safe to transmit\n-            sb.append(c);\n+          // If we're given an outputCharsetEncoder, then check if the\n+          //  character can be represented in this character set.\n+          if (outputCharsetEncoder != null) {\n+            if (outputCharsetEncoder.canEncode(c)) {\n+              sb.append(c);\n+            } else {\n+              // Unicode-escape the character.\n+              StringUtil.appendHexJavaScriptRepresentation(sb, c);\n+            }\n           } else {\n-            // Other characters can be misinterpreted by some js parsers,\n-            // or perhaps mangled by proxies along the way,\n-            // so we play it safe and unicode escape them.\n-            StringUtil.appendHexJavaScriptRepresentation(sb, c);\n+            // No charsetEncoder provided - pass straight latin characters\n+            // through, and escape the rest.  Doing the explicit character\n+            // check is measurably faster than using the CharsetEncoder.\n+            if (c > 0x1f && c <= 0x7f) {\n+              sb.append(c);\n+            } else {\n+              // Other characters can be misinterpreted by some js parsers,\n+              // or perhaps mangled by proxies along the way,\n+              // so we play it safe and unicode escape them.\n+              StringUtil.appendHexJavaScriptRepresentation(sb, c);\n+            }\n           }\n       }\n     }\n@@ -824,7 +863,9 @@\n     StringBuilder sb = new StringBuilder();\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n-      // See comments for the same code in strEscape(). Please keep in sync.\n+      // Identifiers should always go to Latin1/ ASCII characters because\n+      // different browser's rules for valid identifier characters are\n+      // crazy.\n       if (c > 0x1F && c < 0x7F) {\n         sb.append(c);\n       } else {\n\n"
    },
    "Closure-74": {
        "Buggy Function": "",
        "Inducing Changes": ""
    },
    "Closure-75": {
        "Buggy Function": "static Double getStringNumberValue(String rawJsString) {\nString s = trimJsWhiteSpace(rawJsString);\n// return ScriptRuntime.toNumber(s);\nif (s.length() == 0) {\n  return 0.0;\n}\n\nif (s.length() > 2\n    && s.charAt(0) == '0'\n    && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {\n  // Attempt to convert hex numbers.\n  try {\n    return Double.valueOf(Integer.parseInt(s.substring(2), 16));\n  } catch (NumberFormatException e) {\n    return Double.NaN;\n  }\n}\n\nif (s.length() > 3\n    && (s.charAt(0) == '-' || s.charAt(0) == '+')\n    && s.charAt(1) == '0'\n    && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {\n  // hex numbers with explicit signs vary between browsers.\n  return null;\n}\n\n// FireFox and IE treat the \"Infinity\" differently. FireFox is case\n// insensitive, but IE treats \"infinity\" as NaN.  So leave it alone.\nif (s.equals(\"infinity\")\n    || s.equals(\"-infinity\")\n    || s.equals(\"+infinity\")) {\n  return null;\n}\n\ntry {\n  return Double.parseDouble(s);\n} catch (NumberFormatException e) {\n  return Double.NaN;\n}\n}\nstatic boolean isStrWhiteSpaceChar(int c) {\nswitch (c) {\n  case ' ': // <SP>\n  case '\\n': // <LF>\n  case '\\r': // <CR>\n  case '\\t': // <TAB>\n  case '\\u00A0': // <NBSP>\n  case '\\u000C': // <FF>\n  case '\\u000B': // <VT>\n  case '\\u2028': // <LS>\n  case '\\u2029': // <PS>\n  case '\\uFEFF': // <BOM>\n    return true;\n  default:\n    return Character.getType(c) == Character.SPACE_SEPARATOR;\n}\n}",
        "Inducing Changes": "diff --git a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\nindex fce4f17..de6b020 100644\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n@@ -18,6 +18,7 @@\n \n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n+import com.google.javascript.jscomp.mozilla.rhino.ScriptRuntime;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.TernaryValue;\n@@ -77,11 +78,14 @@\n         return tryFoldTypeof(subtree);\n \n       case Token.NOT:\n+      case Token.POS:\n       case Token.NEG:\n       case Token.BITNOT:\n+        tryReduceOperandsForOp(subtree);\n         return tryFoldUnaryOperator(subtree);\n \n       default:\n+        tryReduceOperandsForOp(subtree);\n         return tryFoldBinaryOperator(subtree);\n     }\n   }\n@@ -155,6 +159,98 @@\n     }\n   }\n \n+  private void tryReduceOperandsForOp(Node n) {\n+    switch (n.getType()) {\n+      case Token.ADD:\n+        Node left \u003d n.getFirstChild();\n+        Node right \u003d n.getLastChild();\n+        if (!NodeUtil.mayBeString(left) \u0026\u0026 !NodeUtil.mayBeString(right)) {\n+          tryConvertOperandsToNumber(n);\n+        }\n+        break;\n+      case Token.ASSIGN_BITOR:\n+      case Token.ASSIGN_BITXOR:\n+      case Token.ASSIGN_BITAND:\n+        // TODO(johnlenz): convert these to integers.\n+      case Token.ASSIGN_LSH:\n+      case Token.ASSIGN_RSH:\n+      case Token.ASSIGN_URSH:\n+      case Token.ASSIGN_SUB:\n+      case Token.ASSIGN_MUL:\n+      case Token.ASSIGN_MOD:\n+      case Token.ASSIGN_DIV:\n+        tryConvertToNumber(n.getLastChild());\n+        break;\n+      case Token.BITNOT:\n+      case Token.BITOR:\n+      case Token.BITXOR:\n+      case Token.BITAND:\n+      case Token.LSH:\n+      case Token.RSH:\n+      case Token.URSH:\n+      case Token.SUB:\n+      case Token.MUL:\n+      case Token.MOD:\n+      case Token.DIV:\n+      case Token.POS:\n+      case Token.NEG:\n+        tryConvertOperandsToNumber(n);\n+        break;\n+    }\n+  }\n+\n+  private void tryConvertOperandsToNumber(Node n) {\n+    Node next;\n+    for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d next) {\n+      next \u003d c.getNext();\n+      tryConvertToNumber(c);\n+    }\n+  }\n+\n+  private void tryConvertToNumber(Node n) {\n+    switch (n.getType()) {\n+      case Token.NUMBER:\n+        // Nothing to do\n+        return;\n+      case Token.AND:\n+      case Token.OR:\n+      case Token.COMMA:\n+        tryConvertToNumber(n.getLastChild());\n+        return;\n+      case Token.HOOK:\n+        tryConvertToNumber(n.getChildAtIndex(1));\n+        tryConvertToNumber(n.getLastChild());\n+        return;\n+      case Token.NAME:\n+        if (!NodeUtil.isUndefined(n)) {\n+          return;\n+        }\n+        break;\n+    }\n+\n+    Double result \u003d NodeUtil.getNumberValue(n);\n+    if (result \u003d\u003d null) {\n+      return;\n+    }\n+\n+    double value \u003d result;\n+\n+    Node replacement;\n+    if (Double.isNaN(value)) {\n+      replacement \u003d Node.newString(Token.NAME, \"NaN\");\n+    } else if (value \u003d\u003d Double.POSITIVE_INFINITY) {\n+      replacement \u003d Node.newString(Token.NAME, \"Infinity\");\n+    } else if (value \u003d\u003d Double.NEGATIVE_INFINITY) {\n+      replacement \u003d new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n+      replacement.copyInformationFromForTree(n);\n+    } else {\n+      replacement \u003d Node.newNumber(value);\n+    }\n+\n+    n.getParent().replaceChild(n, replacement);\n+    reportCodeChange();\n+  }\n+\n   /**\n    * Folds \u0027typeof(foo)\u0027 if foo is a literal, e.g.\n    * typeof(\"bar\") --\u003e \"string\"\n@@ -234,6 +330,14 @@\n         parent.replaceChild(n, replacementNode);\n         reportCodeChange();\n         return replacementNode;\n+      case Token.POS:\n+        if (NodeUtil.isNumericResult(left)) {\n+          // POS does nothing to numeric values.\n+          parent.replaceChild(n, left.detachFromParent());\n+          reportCodeChange();\n+          return left;\n+        }\n+        return n;\n       case Token.NEG:\n         try {\n           if (left.getType() \u003d\u003d Token.NAME) {\n@@ -506,6 +610,7 @@\n   private Node tryFoldArithmeticOp(Node n, Node left, Node right) {\n     Node result \u003d performArithmeticOp(n.getType(), left, right);\n     if (result !\u003d null) {\n+      result.copyInformationFromForTree(n);\n       n.getParent().replaceChild(n, result);\n       reportCodeChange();\n       return result;\n@@ -527,6 +632,9 @@\n \n     double result;\n \n+    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n+    // to zero so this is a little akward here.\n+\n     Double lValObj \u003d NodeUtil.getNumberValue(left);\n     if (lValObj \u003d\u003d null) {\n       return null;\n@@ -541,22 +649,13 @@\n \n     switch (opType) {\n       case Token.BITAND:\n-        if (!areValidInts(lval, rval)) {\n-          return null;\n-        }\n-        result \u003d (int)lval \u0026 (int)rval;\n+        result \u003d ScriptRuntime.toInt32(lval) \u0026 ScriptRuntime.toInt32(rval);\n         break;\n       case Token.BITOR:\n-        if (!areValidInts(lval, rval)) {\n-          return null;\n-        }\n-        result \u003d (int)lval | (int)rval;\n+        result \u003d ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n         break;\n       case Token.BITXOR:\n-        if (!areValidInts(lval, rval)) {\n-          return null;\n-        }\n-        result \u003d (int)lval ^ (int)rval;\n+        result \u003d ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n         break;\n       case Token.ADD:\n         result \u003d lval + rval;\n@@ -607,22 +706,6 @@\n   }\n \n   /**\n-   * @return Whether the double can be precisely represented as a int.\n-   */\n-  private boolean isValidInt(double val) {\n-    return !(val \u003c Integer.MIN_VALUE || val \u003e Integer.MAX_VALUE)\n-        \u0026\u0026 val \u003d\u003d (int)val;\n-  }\n-\n-  /**\n-   * @return Whether the parameters are doubles can be precisely represented\n-   * as a int.\n-   */\n-  private boolean areValidInts(double val1, double val2) {\n-    return isValidInt(val1) \u0026\u0026 isValidInt(val2);\n-  }\n-\n-  /**\n    * Expressions such as [foo() * 10 * 20] generate parse trees\n    * where no node has two const children ((foo() * 10) * 20), so\n    * performArithmeticOp() won\u0027t fold it -- tryFoldLeftChildOp() will.\n@@ -633,30 +716,33 @@\n    */\n   private Node tryFoldLeftChildOp(Node n, Node left, Node right) {\n     int opType \u003d n.getType();\n-    // Note: ADD is not associative when used as a string concat operator.\n+    // TODO(johnlenz): Add support for ADD in numberic contexts.\n     Preconditions.checkState(\n       NodeUtil.isAssociative(opType) \u0026\u0026 NodeUtil.isCommutative(opType));\n-    // TODO(johnlenz): create and use a getNumberValue.\n-    if (right.getType() \u003d\u003d Token.NUMBER \u0026\u0026 left.getType() \u003d\u003d opType) {\n+\n+    // Use getNumberValue to handle constants like \"NaN\" and \"Infinity\"\n+    // other values are converted to numbers elsewhere.\n+    Double rightValObj \u003d NodeUtil.getNumberValue(right);\n+    if (rightValObj !\u003d null \u0026\u0026 left.getType() \u003d\u003d opType) {\n       Preconditions.checkState(left.getChildCount() \u003d\u003d 2);\n \n       Node ll \u003d left.getFirstChild();\n       Node lr \u003d ll.getNext();\n \n-      Node valueToCombine;\n-      if (ll.getType() \u003d\u003d Token.NUMBER) {\n-        valueToCombine \u003d ll;\n-      } else if (lr.getType() \u003d\u003d Token.NUMBER) {\n-        valueToCombine \u003d lr;\n-      } else {\n-        // Nothing to do.\n-        return n;\n-      }\n-\n+      Node valueToCombine \u003d ll;\n       Node replacement \u003d performArithmeticOp(opType, valueToCombine, right);\n+      if (replacement \u003d\u003d null) {\n+        valueToCombine \u003d lr;\n+        replacement \u003d performArithmeticOp(opType, valueToCombine, right);\n+      }\n       if (replacement !\u003d null) {\n+        // Remove the child that has been combined\n         left.removeChild(valueToCombine);\n+        // Replace the left op with the remaining child.\n         n.replaceChild(left, left.removeFirstChild());\n+        // New \"-Infinity\" node need location info explicitly\n+        // added.\n+        replacement.copyInformationFromForTree(right);\n         n.replaceChild(right, replacement);\n         reportCodeChange();\n       }\n"
    },
    "Closure-76": {
        "Buggy Function": "private boolean isVariableStillLiveWithinExpression(\n  Node n, Node exprRoot, String variable) {\nwhile (n != exprRoot) {\n  for(Node sibling = n.getNext(); sibling != null;\n      sibling = sibling.getNext()) {\n    if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {\n      VariableLiveness state = isVariableReadBeforeKill(sibling, variable);\n\n      // If we see a READ or KILL there is no need to continue.\n      if (state == VariableLiveness.READ) {\n        return true;\n      } else if (state == VariableLiveness.KILL) {\n        return false;\n      }\n    }\n  }\n  n = n.getParent();\n}\nreturn false;\n}\nprivate VariableLiveness isVariableReadBeforeKill(\n  Node n, String variable) {\nif (NodeUtil.isName(n) && variable.equals(n.getString())) {\n  if (NodeUtil.isLhs(n, n.getParent())) {\n    Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);\n    // The expression to which the assignment is made is evaluated before\n    // the RHS is evaluated (normal left to right evaluation) but the KILL\n    // occurs after the RHS is evaluated.\n    Node rhs = n.getNext();\n    VariableLiveness state = isVariableReadBeforeKill(rhs, variable);\n    if (state == VariableLiveness.READ) {\n      return state;\n    }\n    return VariableLiveness.KILL;\n  } else {\n    return VariableLiveness.READ;\n  }\n}\n\n// Expressions are evaluated left-right, depth first.\nfor (Node child = n.getFirstChild();\n    child != null; child = child.getNext()) {\n  if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION\n    VariableLiveness state = isVariableReadBeforeKill(child, variable);\n    if (state != VariableLiveness.MAYBE_LIVE) {\n      return state;\n    }\n  }\n}\nreturn VariableLiveness.MAYBE_LIVE;\n}",
        "Inducing Changes": "diff --git a/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java b/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\nnew file mode 100644\nindex 0000000..d554f78\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n@@ -0,0 +1,296 @@\n+/*\n+ * Copyright 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.javascript.jscomp.ControlFlowGraph.Branch;\n+import com.google.javascript.jscomp.DataFlowAnalysis.FlowState;\n+import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\n+import com.google.javascript.jscomp.LiveVariablesAnalysis.LiveVariableLattice;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n+import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import java.util.List;\n+\n+/**\n+ * Removes local variable assignments that are useless based on information from\n+ * {@link LiveVariablesAnalysis}. If there is an assignment to variable\n+ * {@code x} and {@code x} is dead after this assignment, we know that the\n+ * current content of {@code x} will not be read and this assignment is useless.\n+ *\n+*\n+ */\n+class DeadAssignmentsElimination extends AbstractPostOrderCallback implements\n+    CompilerPass, ScopedCallback {\n+\n+  private final AbstractCompiler compiler;\n+  private LiveVariablesAnalysis liveness;\n+\n+  public DeadAssignmentsElimination(AbstractCompiler compiler) {\n+    this.compiler = compiler;\n+  }\n+\n+  @Override\n+  public void process(Node externs, Node root) {\n+    Preconditions.checkNotNull(externs);\n+    Preconditions.checkNotNull(root);\n+    NodeTraversal.traverse(compiler, root, this);\n+  }\n+\n+  @Override\n+  public void enterScope(NodeTraversal t) {\n+    Scope scope = t.getScope();\n+    // Global scope _SHOULD_ work, however, liveness won't finish without\n+    // -Xmx1024 in closure. We might have to look at coding conventions for\n+    // exported variables as well.\n+    if (scope.isGlobal()) {\n+      return;\n+    }\n+    \n+    // We are not going to do any dead assignment elimination in when there is\n+    // at least one inner function because in most browsers, when there is a\n+    // closure, ALL the variables are saved (escaped).\n+    if (!NodeUtil.containsFunctionDeclaration(\n+        t.getScopeRoot().getLastChild())) {\n+      // Computes liveness information first.\n+      ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n+      liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n+      liveness.analyze();\n+      tryRemoveDeadAssignments(t, cfg);\n+    }\n+  }\n+\n+  @Override\n+  public void exitScope(NodeTraversal t) {\n+  }\n+\n+  @Override\n+  public void visit(NodeTraversal t, Node n, Node parent) {\n+  }\n+\n+  /**\n+   * Try to remove useless assignments from a control flow graph that has been\n+   * annotated with liveness information.\n+   *\n+   * @param t The node traversal.\n+   * @param cfg The control flow graph of the program annotated with liveness\n+   *        information.\n+   */\n+  private void tryRemoveDeadAssignments(NodeTraversal t,\n+      ControlFlowGraph<Node> cfg) {\n+    List<DiGraphNode<Node, Branch>> nodes = cfg.getDirectedGraphNodes();\n+\n+    for (DiGraphNode<Node, Branch> cfgNode : nodes) {\n+      FlowState<LiveVariableLattice> state =\n+          cfgNode.getAnnotation();\n+      Node n = cfgNode.getValue();\n+      if (n == null) {\n+        continue;\n+      }\n+      switch (n.getType()) {\n+        case Token.IF:\n+        case Token.WHILE:\n+        case Token.DO:\n+          tryRemoveAssignment(t, NodeUtil.getConditionExpression(n), state);\n+          continue;\n+        case Token.FOR:\n+          if (n.getChildCount() == 4) {\n+            tryRemoveAssignment(\n+                t, NodeUtil.getConditionExpression(n), state);\n+          }\n+          continue;\n+        case Token.SWITCH:\n+        case Token.CASE:\n+        case Token.RETURN:\n+          if (n.hasChildren()) {\n+            tryRemoveAssignment(t, n.getFirstChild(), state);\n+          }\n+          continue;\n+        // TODO(user): case Token.VAR: Remove var a=1;a=2;.....\n+      }\n+      \n+      tryRemoveAssignment(t, n, state);\n+    }\n+  }\n+\n+  private void tryRemoveAssignment(NodeTraversal t, Node n,\n+      FlowState<LiveVariableLattice> state) {\n+    tryRemoveAssignment(t, n, n, state);\n+  }\n+  \n+  /**\n+   * Determines if any local variables are dead after the instruction {@code n}\n+   * and are assigned within the subtree of {@code n}. Removes those assignments\n+   * if there are any.\n+   *\n+   * @param n Target instruction.\n+   * @param exprRoot The CFG node where the liveness information in state is\n+   *     still correct.\n+   * @param state The liveness information at {@code n}.\n+   */\n+  private void tryRemoveAssignment(NodeTraversal t, Node n, Node exprRoot,\n+      FlowState<LiveVariableLattice> state) {\n+\n+    // TODO(user): Add implemenation to handle x++ and ++x by replacing\n+    // them with x or x+1 respectively.\n+    if (NodeUtil.isAssignmentOp(n)) {\n+\n+      Node lhs = n.getFirstChild();\n+      Node rhs = lhs.getNext();\n+      \n+      // Recurse first. Example: dead_x = dead_y = 1; We try to clean up dead_y\n+      // first.\n+      if (rhs != null) {\n+        tryRemoveAssignment(t, rhs, exprRoot, state);\n+        rhs = lhs.getNext();\n+      }\n+\n+      Scope scope = t.getScope();\n+      if (!NodeUtil.isName(lhs)) {\n+        return; // Not a local variable assignment.\n+      }\n+      String name = lhs.getString();\n+      if (!scope.isDeclared(name, false)) {\n+        return;\n+      }\n+      Var var = scope.getVar(name);\n+      if (liveness.getEscapedLocals().contains(var)) {\n+        return; // Local variable that might be escaped due to closures.\n+      }\n+      if (state.getOut().isLive(var)) {\n+        return; // Variable not dead.\n+      }\n+      if (state.getIn().isLive(var) &&\n+          isVariableStillLiveWithinExpression(n, exprRoot, var.name)) {\n+        // The variable is killed here but it is also live before it.\n+        // This is possible if we have say:\n+        //    if (X = a && a = C) {..} ; .......; a = S;\n+        // In this case we are safe to remove \"a = C\" because it is dead.\n+        // However if we have:\n+        //    if (a = C && X = a) {..} ; .......; a = S;\n+        // removing \"a = C\" is NOT correct, although the live set at the node\n+        // is exactly the same.\n+        // TODO(user): We need more fine grain CFA or we need to keep track\n+        // of GEN sets when we recurse here.\n+        return;\n+      }\n+      \n+      if (NodeUtil.isAssign(n)) {\n+        n.removeChild(rhs);\n+        n.getParent().replaceChild(n, rhs);\n+      } else if (NodeUtil.isAssignmentOp(n)) {\n+        n.removeChild(rhs);\n+        n.removeChild(lhs);\n+        Node op = new Node(NodeUtil.getOpFromAssignmentOp(n), lhs, rhs);\n+        n.getParent().replaceChild(n, op);\n+      } else {\n+        // TODO(user): this is where the code that handles dead x++ and x--\n+        // should go.\n+        \n+        // Not reachable.\n+        Preconditions.checkState(false, \"Unknow statement\");\n+      }\n+      \n+      compiler.reportCodeChange();\n+      return;\n+\n+    } else {\n+      for (Node c = n.getFirstChild(); c != null;) {\n+        Node next = c.getNext();\n+        if (!ControlFlowGraph.isEnteringNewCfgNode(c)) {\n+          tryRemoveAssignment(t, c, exprRoot, state);\n+        }\n+        c = next;\n+      }\n+      return;\n+    }\n+  }\n+  \n+  /**\n+   * Given a variable, node n in the tree and a sub-tree denoted by exprRoot as\n+   * the root, this function returns true if there exists a read of that\n+   * variable before a write to that variable that is on the right side of n.\n+   * \n+   * For example, suppose the node is x = 1:\n+   * \n+   * y = 1, x = 1; // false, there is no reads at all.\n+   * y = 1, x = 1, print(x) // true, there is a read right of n.\n+   * y = 1, x = 1, x = 2, print(x) // false, there is a read right of n but \n+   *                               // it is after a write.\n+   * \n+   * @param n The current node we should look at.\n+   * @param exprRoot The node\n+   */\n+  private boolean isVariableStillLiveWithinExpression(\n+      Node n, Node exprRoot, String variable) {\n+    while (n != exprRoot) {\n+      for(Node sibling = n.getNext(); sibling != null;\n+          sibling = sibling.getNext()) {\n+        if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {\n+          VariableLiveness state = readVariableBeforeKilling(sibling, variable);\n+          \n+          // If we see a READ or KILL there is no need to continue.\n+          if (state == VariableLiveness.READ) {\n+            return true;\n+          } else if (state == VariableLiveness.KILL) {\n+            return false;\n+          }\n+        }\n+      }\n+      n = n.getParent();\n+    }\n+    return false;\n+  }\n+  \n+  // The current liveness of the variable\n+  private enum VariableLiveness {\n+    MAYBE_LIVE, // May be still live in the current expression tree.\n+    READ, // Known there is a read left of it.\n+    KILL, // Known there is a write before any read.\n+  }\n+\n+  /**\n+   * Give an expression and a variable. It returns READ, if the right-most\n+   * reference of that variable is a read. It returns KILL, if the right-most\n+   * reference of that variable is an assignment. It returns MAY_LIVE otherwise.\n+   * \n+   * This need to be a pre-order traversal so we cannot use the normal node\n+   * traversals.\n+   */\n+  private VariableLiveness readVariableBeforeKilling(Node n, String variable) {\n+    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n+      if (NodeUtil.isLhs(n, n.getParent())) {\n+        return VariableLiveness.KILL;\n+      } else {\n+        return VariableLiveness.READ;\n+      }\n+    }\n+    for (Node child = n.getFirstChild();\n+        child != null; child = child.getNext()) {\n+      if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\n+        VariableLiveness state = readVariableBeforeKilling(child, variable);\n+        if (state != VariableLiveness.MAYBE_LIVE) {\n+          return state;\n+        }\n+      }\n+    }\n+    return VariableLiveness.MAYBE_LIVE;\n+  }\n+}\n\n"
    },
    "Closure-80": {
        "Buggy Function": "static boolean isBooleanResultHelper(Node n) {\nswitch (n.getType()) {\n  // Primitives\n  case Token.TRUE:\n  case Token.FALSE:\n  // Comparisons\n  case Token.EQ:\n  case Token.NE:\n  case Token.SHEQ:\n  case Token.SHNE:\n  case Token.LT:\n  case Token.GT:\n  case Token.LE:\n  case Token.GE:\n  // Queryies\n  case Token.IN:\n  case Token.INSTANCEOF:\n  // Inversion\n  case Token.NOT:\n    return true;\n  default:\n    return false;\n}\n}\nstatic boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\nswitch (value.getType()) {\n  case Token.ASSIGN:\n    // A result that is aliased by a non-local name, is the effectively the\n    // same as returning a non-local name, but this doesn't matter if the\n    // value is immutable.\n    return NodeUtil.isImmutableValue(value.getLastChild())\n        || (locals.apply(value)\n            && evaluatesToLocalValue(value.getLastChild(), locals));\n  case Token.COMMA:\n    return evaluatesToLocalValue(value.getLastChild(), locals);\n  case Token.AND:\n  case Token.OR:\n    return evaluatesToLocalValue(value.getFirstChild(), locals)\n       && evaluatesToLocalValue(value.getLastChild(), locals);\n  case Token.HOOK:\n    return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n       && evaluatesToLocalValue(value.getLastChild(), locals);\n  case Token.INC:\n  case Token.DEC:\n    if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n      return evaluatesToLocalValue(value.getFirstChild(), locals);\n    } else {\n      return true;\n    }\n  case Token.THIS:\n    return locals.apply(value);\n  case Token.NAME:\n    return isImmutableValue(value) || locals.apply(value);\n  case Token.GETELEM:\n  case Token.GETPROP:\n    // There is no information about the locality of object properties.\n    return locals.apply(value);\n  case Token.CALL:\n    return callHasLocalResult(value)\n        || isToStringMethodCall(value)\n        || locals.apply(value);\n  case Token.NEW:\n    return newHasLocalResult(value)\n           || locals.apply(value);\n  case Token.FUNCTION:\n  case Token.REGEXP:\n  case Token.ARRAYLIT:\n  case Token.OBJECTLIT:\n    // Literals objects with non-literal children are allowed.\n    return true;\n  case Token.IN:\n    // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n    return true;\n  default:\n    // Other op force a local value:\n    //  x = '' + g (x is now an local string)\n    //  x -= g (x is now an local number)\n    if (isAssignmentOp(value)\n        || isSimpleOperator(value)\n        || isImmutableValue(value)) {\n      return true;\n    }\n\n    throw new IllegalStateException(\n        \"Unexpected expression node\" + value +\n        \"\\n parent:\" + value.getParent());\n}\n}",
        "Inducing Changes": "diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex 470635f..cec8b2d 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -530,6 +530,11 @@\n         }\n \n         if (isAssignmentOp(n)) {\n+          Node assignTarget = n.getFirstChild();\n+          if (isName(assignTarget)) {\n+            return true;\n+          }\n+\n           // Assignments will have side effects if\n           // a) The RHS has side effects, or\n           // b) The LHS has side effects, or\n@@ -541,13 +546,32 @@\n             return true;\n           }\n \n-          Node current = n.getFirstChild();\n-          for (;\n-               current.getType() == Token.GETPROP ||\n-               current.getType() == Token.GETELEM;\n-               current = current.getFirstChild()) { }\n+          if (isGet(assignTarget)) {\n+            // If the object being assigned to is a local object, don't\n+            // consider this a side-effect as it can't be referenced\n+            // elsewhere.  Don't do this recursively as the property might\n+            // be an alias of another object, unlike a literal below.\n+            Node current = assignTarget.getFirstChild();\n+            if (evaluatesToLocalValue(current)) {\n+              return false;\n+            }\n \n-          return !isLiteralValue(current, true);\n+            // A literal value as defined by \"isLiteralValue\" is guaranteed\n+            // not to be an alias, or any components which are aliases of\n+            // other objects.\n+            // If the root object is a literal don't consider this a\n+            // side-effect.\n+            while (isGet(current)) {\n+              current = current.getFirstChild();\n+            }\n+\n+            return !isLiteralValue(current, true);\n+          } else {\n+            // TODO(johnlenz): remove this code and make this an exception. This\n+            // is here only for legacy reasons, the AST is not valid but\n+            // preserve existing behavior.\n+            return !isLiteralValue(assignTarget, true);\n+          }\n         }\n \n         return true;\n@@ -637,6 +661,11 @@\n         return false;\n       }\n     } else if (nameNode.getType() == Token.GETPROP) {\n+      if (callNode.isOnlyModifiesThisCall()\n+          && evaluatesToLocalValue(nameNode.getFirstChild())) {\n+        return false;\n+      }\n+\n       // Functions in the \"Math\" namespace have no side effects.\n       if (nameNode.getFirstChild().getType() == Token.NAME) {\n         String namespaceName = nameNode.getFirstChild().getString();\n@@ -2213,4 +2242,79 @@\n     }\n     return call;\n   }\n+\n+  /**\n+   * @return Whether the node is known to be a value that is not referenced\n+   * elsewhere.\n+   */\n+  static boolean evaluatesToLocalValue(Node value) {\n+    return evaluatesToLocalValue(value, Predicates.<Node>alwaysFalse());\n+  }\n+\n+  /**\n+   * @param locals A predicate to apply to unknown local values.\n+   * @return Whether the node is known to be a value that is not a reference\n+   *     outside the expression scope.\n+   */\n+  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n+    switch (value.getType()) {\n+      case Token.ASSIGN:\n+        // A result that is aliased by a non-local name, is the effectively the\n+        // same as returning a non-local name, but this doesn't matter if the\n+        // value is immutable.\n+        return NodeUtil.isImmutableValue(value.getLastChild())\n+            || (locals.apply(value)\n+                && evaluatesToLocalValue(value.getLastChild(), locals));\n+      case Token.COMMA:\n+        return evaluatesToLocalValue(value.getLastChild(), locals);\n+      case Token.AND:\n+      case Token.OR:\n+        return evaluatesToLocalValue(value.getFirstChild(), locals)\n+           && evaluatesToLocalValue(value.getLastChild(), locals);\n+      case Token.HOOK:\n+        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n+           && evaluatesToLocalValue(value.getLastChild(), locals);\n+      case Token.INC:\n+      case Token.DEC:\n+        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n+          return evaluatesToLocalValue(value.getFirstChild(), locals);\n+        } else {\n+          return true;\n+        }\n+      case Token.THIS:\n+        return locals.apply(value);\n+      case Token.NAME:\n+        return isImmutableValue(value) || locals.apply(value);\n+      case Token.GETELEM:\n+      case Token.GETPROP:\n+        // There is no information about the locality of object properties.\n+        return locals.apply(value);\n+      case Token.CALL:\n+        return callHasLocalResult(value) || locals.apply(value);\n+      case Token.NEW:\n+        return true;\n+      case Token.FUNCTION:\n+      case Token.REGEXP:\n+      case Token.ARRAYLIT:\n+      case Token.OBJECTLIT:\n+        // Literals objects with non-literal children are allowed.\n+        return true;\n+      case Token.IN:\n+        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n+        return true;\n+      default:\n+        // Other op force a local value:\n+        //  x = '' + g (x is now an local string)\n+        //  x -= g (x is now an local number)\n+        if (isAssignmentOp(value)\n+            || isSimpleOperator(value)\n+            || isImmutableValue(value)) {\n+          return true;\n+        }\n+\n+        throw new IllegalStateException(\n+            \"Unexpected expression node\" + value +\n+            \"\\n parent:\" + value.getParent());\n+    }\n+  }\n }\n\n"
    },
    "Closure-82": {
        "Buggy Function": "  public final boolean isEmptyType() {\n    return isNoType() || isNoObjectType() || isNoResolvedType();\n  }",
        "Inducing Changes": "diff --git a/src/com/google/javascript/rhino/jstype/JSType.java b/src/com/google/javascript/rhino/jstype/JSType.java\nindex a705a98..920e5d3 100644\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n@@ -41,6 +41,7 @@\n \n import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN;\n \n+import com.google.common.base.Predicate;\n import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.jstype.JSTypeRegistry.ResolveMode;\n@@ -62,8 +63,6 @@\n  * order of types. All types are united at the top of the lattice by the\n  * {@link AllType} and at the bottom by the {@link NoType}.<p>\n  *\n- *\n- *\n  */\n public abstract class JSType implements Serializable {\n   private static final long serialVersionUID = 1L;\n@@ -121,6 +120,27 @@\n   }\n \n   /**\n+   * Returns a user meaningful label for the JSType instance.  For example,\n+   * Functions and Enums will return their declaration name (if they have one).\n+   * Some types will not have a meaningful display name.  Calls to\n+   * hasDisplayName() will return true IFF getDisplayName() will return null\n+   * or a zero length string.\n+   *\n+   * @return the display name of the type, or null if one is not available\n+   */\n+  public String getDisplayName() {\n+    return null;\n+  }\n+\n+  /**\n+   * @return true if the JSType has a user meaningful label.\n+   */\n+  public boolean hasDisplayName() {\n+    String displayName = getDisplayName();\n+    return displayName != null && !displayName.isEmpty();\n+  }\n+\n+  /**\n    * If we see a type name without braces, it might be legacy jsdoc.\n    * So we shouldn't emit warnings about it. This method is how we skip\n    * those warnings.\n@@ -486,24 +506,30 @@\n    * </ul>\n    */\n   public TernaryValue testForEquality(JSType that) {\n-    if (that.isAllType() || that.isNoType() || that.isUnknownType()) {\n+    return testForEqualityHelper(this, that);\n+  }\n+\n+  TernaryValue testForEqualityHelper(JSType aType, JSType bType) {\n+    if (bType.isAllType() || bType.isEmptyType() || bType.isUnknownType()) {\n       return UNKNOWN;\n     }\n-    if (that.isEnumElementType()) {\n-      return that.testForEquality(this);\n-    }\n-    if (that instanceof UnionType) {\n-      UnionType union = (UnionType) that;\n-      TernaryValue result = null;\n-      for (JSType t : union.alternates) {\n-        TernaryValue test = this.testForEquality(t);\n-        if (result == null) {\n-          result = test;\n-        } else if (!result.equals(test)) {\n-          return UNKNOWN;\n-        }\n+    if (aType.isFunctionType() || bType.isFunctionType()) {\n+      JSType otherType = aType.isFunctionType() ? bType : aType;\n+      // In theory, functions are comparable to anything except\n+      // null/undefined. For example, on FF3:\n+      // function() {} == 'function () {\\n}'\n+      // In practice, how a function serializes to a string is\n+      // implementation-dependent, so it does not really make sense to test\n+      // for equality with a string.\n+      if (otherType.isSubtype(getNativeType(JSTypeNative.OBJECT_TYPE))) {\n+        return TernaryValue.UNKNOWN;\n+      } else {\n+        return TernaryValue.FALSE;\n       }\n     }\n+    if (bType.isEnumElementType() || bType.isUnionType()) {\n+      return bType.testForEquality(aType);\n+    }\n     return null;\n   }\n \n@@ -837,7 +863,7 @@\n     }\n     // named types\n     if (thatType instanceof NamedType) {\n-      return thisType.isSubtype(((NamedType)thatType).referencedType);\n+      return thisType.isSubtype(((NamedType)thatType).getReferencedType());\n     }\n     return false;\n   }\n@@ -921,6 +947,16 @@\n     return type == null ? null : type.resolve(t, scope);\n   }\n \n+  /**\n+   * Certain types have constraints on them at resolution-time.\n+   * For example, a type in an {@code @extends} annotation must be an\n+   * object. Clients should inject a validator that emits a warning\n+   * if the type does not validate, and return false.\n+   */\n+  public boolean setValidator(Predicate<JSType> validator) {\n+    return validator.apply(this);\n+  }\n+\n   public static class TypePair {\n     public final JSType typeA;\n     public final JSType typeB;\n\n"
    },
    "Closure-85": {
        "Buggy Function": "@SuppressWarnings(\"fallthrough\")\nprivate Node tryRemoveUnconditionalBranching(Node n) {\n/*\n * For each of the unconditional branching control flow node, check to see\n * if the ControlFlowAnalysis.computeFollowNode of that node is same as\n * the branching target. If it is, the branch node is safe to be removed.\n *\n * This is not as clever as MinimizeExitPoints because it doesn't do any\n * if-else conversion but it handles more complicated switch statements\n * much nicer.\n */\n\n// If n is null the target is the end of the function, nothing to do.\nif (n == null) {\n   return n;\n}\n\nDiGraphNode<Node, Branch> gNode = curCfg.getDirectedGraphNode(n);\n\nif (gNode == null) {\n  return n;\n}\n\n// If the parent is null, this mean whatever node it was there is now\n// useless and it has been removed by other logics in this pass. That node\n// while no longer exists in the AST, is still in the CFG because we\n// never update the graph as nodes are removed.\nif (n.getParent() == null) {\n  List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n  if (outEdges.size() == 1) {\n    return tryRemoveUnconditionalBranching(\n      outEdges.get(0).getDestination().getValue());\n  }\n}\n\nswitch (n.getType()) {\n  case Token.BLOCK:\n    if (n.hasChildren()) {\n      Node first = n.getFirstChild();\n      return tryRemoveUnconditionalBranching(first);\n    } else {\n      return tryRemoveUnconditionalBranching(\n        ControlFlowAnalysis.computeFollowNode(n));\n    }\n  case Token.RETURN:\n    if (n.hasChildren()) {\n      break;\n    }\n  case Token.BREAK:\n  case Token.CONTINUE:\n\n    // We are looking for a control flow changing statement that always\n    // branches to the same node. If removing it the control flow still\n    // branches to that same node. It is safe to remove it.\n    List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n    if (outEdges.size() == 1 &&\n\n        // If there is a next node, there is no chance this jump is useless.\n        (n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {\n      Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);\n      Node fallThrough = tryRemoveUnconditionalBranching(\n        ControlFlowAnalysis.computeFollowNode(n));\n      Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n      if (nextCfgNode == fallThrough) {\n        removeDeadExprStatementSafely(n);\n        return fallThrough;\n      }\n    }\n}\nreturn n;\n}",
        "Inducing Changes": "diff --git a/src/com/google/javascript/jscomp/UnreachableCodeElimination.java b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\nnew file mode 100644\nindex 0000000..0a986b3\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n@@ -0,0 +1,243 @@\n+/*\n+ * Copyright 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.javascript.jscomp.ControlFlowGraph.Branch;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n+import com.google.javascript.jscomp.graph.GraphReachability;\n+import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n+import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import java.util.Deque;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * Removes dead code from a parse tree. The kinds of dead code that this pass\n+ * removes are:\n+ *  - Any code following a return statement, such as the <code>alert</code>\n+ *    call in: <code>if (x) { return; alert('unreachable'); }</code>.\n+ *  - Statements that have no side effects, such as:\n+ *    <code>a.b.MyClass.prototype.propertyName;</code> or <code>true;</code>.\n+ *    That first kind of statement sometimes appears intentionally, so that\n+ *    prototype properties can be annotated using JSDoc without actually\n+ *    being initialized.\n+ *\n+*\n+ */\n+class UnreachableCodeElimination extends AbstractPostOrderCallback\n+    implements CompilerPass, ScopedCallback  {\n+  private static final Logger logger =\n+    Logger.getLogger(UnreachableCodeElimination.class.getName());\n+\n+  private final AbstractCompiler compiler;\n+  private final boolean removeNoOpStatements;\n+\n+  Deque<ControlFlowGraph<Node>> cfgStack =\n+      new LinkedList<ControlFlowGraph<Node>>();\n+\n+  ControlFlowGraph<Node> curCfg = null;\n+\n+  UnreachableCodeElimination(AbstractCompiler compiler,\n+      boolean removeNoOpStatements) {\n+    this.compiler = compiler;\n+    this.removeNoOpStatements = removeNoOpStatements;\n+  }\n+\n+  @Override\n+  public void enterScope(NodeTraversal t) {\n+    Scope scope = t.getScope();\n+\n+    // Computes the control flow graph.\n+    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false);\n+    cfa.process(null, scope.getRootNode());\n+    cfgStack.push(curCfg);\n+    curCfg = cfa.getCfg();\n+\n+    new GraphReachability<Node, ControlFlowGraph.Branch>(curCfg)\n+        .compute(curCfg.getEntry().getValue());\n+  }\n+\n+  @Override\n+  public void exitScope(NodeTraversal t) {\n+    curCfg = cfgStack.pop();\n+  }\n+\n+  @Override\n+  public void process(Node externs, Node root) {\n+    NodeTraversal.traverse(compiler, root, this);\n+  }\n+\n+  @Override\n+  public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (parent == null) {\n+      return;\n+    }\n+    if (n.getType() == Token.FUNCTION || n.getType() == Token.SCRIPT) {\n+      return;\n+    }\n+    // Removes TRYs that had its CATCH removed and/or empty FINALLY.\n+    // TODO(dcc): Move the parts of this that don't require a control flow\n+    // graph to PeepholeRemoveDeadCode\n+    if (n.getType() == Token.TRY) {\n+      Node body = n.getFirstChild();\n+      Node catchOrFinallyBlock = body.getNext();\n+      Node finallyBlock = catchOrFinallyBlock.getNext();\n+\n+      if (!catchOrFinallyBlock.hasChildren() &&\n+          (finallyBlock == null || !finallyBlock.hasChildren())) {\n+        n.removeChild(body);\n+        parent.replaceChild(n, body);\n+        compiler.reportCodeChange();\n+        n = body;\n+      }\n+    }\n+    DiGraphNode<Node, Branch> gNode = curCfg.getDirectedGraphNode(n);\n+    if (gNode == null) { // Not in CFG.\n+      return;\n+    }\n+    if (gNode.getAnnotation() != GraphReachability.REACHABLE ||\n+        (removeNoOpStatements && !NodeUtil.mayHaveSideEffects(n))) {\n+      removeDeadExprStatementSafely(n);\n+      return;\n+    }\n+\n+    tryRemoveUnconditionalBranching(n);\n+  }\n+\n+  /**\n+   * Tries to remove n if an unconditional branch node (break, continue or\n+   * return) if the target of n is the same as the the follow of n. That is, if\n+   * we remove n, the control flow remains the same. Also if n targets to\n+   * another unconditional branch, this function will recursively try to remove\n+   * the target branch as well. The reason why we want to cascade this removal\n+   * is because we only run this pass once. If we have code such as\n+   *\n+   * break -> break -> break\n+   *\n+   * where all 3 break's are useless. The order of removal matters. When we\n+   * first look at the first break, we see that it branches to the 2nd break.\n+   * However, if we remove the last break, the 2nd break becomes useless and\n+   * finally the first break becomes useless as well.\n+   *\n+   * @return The target of this jump. If the target is also useless jump,\n+   *     the target of that useless jump recursively.\n+   */\n+  @SuppressWarnings(\"fallthrough\")\n+  private Node tryRemoveUnconditionalBranching(Node n) {\n+    /*\n+     * For each of the unconditional branching control flow node, check to see\n+     * if the ControlFlowAnalysis.computeFollowNode of that node is same as\n+     * the branching target. If it is, the branch node is safe to be removed.\n+     *\n+     * This is not as clever as MinimizeExitPoints because it doesn't do any\n+     * if-else conversion but it handles more complicated switch statements\n+     * much nicer.\n+     */\n+\n+    // If n is null the target is the end of the function, nothing to do.\n+    if (n == null) {\n+       return n;\n+    }\n+\n+    DiGraphNode<Node, Branch> gNode = curCfg.getDirectedGraphNode(n);\n+\n+    if (gNode == null) {\n+      return n;\n+    }\n+\n+    // If the parent is null, this mean whatever node it was there is now\n+    // useless and it has been removed by other logics in this pass. That node\n+    // while no longer exists in the AST, is still in the CFG because we\n+    // never update the graph as nodes are removed.\n+    if (n.getParent() == null) {\n+      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n+      if (outEdges.size() == 1) {\n+        return tryRemoveUnconditionalBranching(\n+          outEdges.get(0).getDestination().getValue());\n+      }\n+    }\n+\n+    switch (n.getType()) {\n+      case Token.BLOCK:\n+        if (n.hasChildren()) {\n+          Node first = n.getFirstChild();\n+          return tryRemoveUnconditionalBranching(first);\n+        } else {\n+          return tryRemoveUnconditionalBranching(\n+            ControlFlowAnalysis.computeFollowNode(n));\n+        }\n+      case Token.RETURN:\n+        if (n.hasChildren()) {\n+          break;\n+        }\n+      case Token.BREAK:\n+      case Token.CONTINUE:\n+\n+        // We are looking for a control flow changing statement that always\n+        // branches to the same node. If removing it the control flow still\n+        // branches to that same node. It is safe to remove it.\n+        List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n+        if (outEdges.size() == 1 &&\n+\n+            // If there is a next node, there is no chance this jump is useless.\n+            (n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {\n+          Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);\n+          Node fallThrough = tryRemoveUnconditionalBranching(\n+            ControlFlowAnalysis.computeFollowNode(n));\n+          Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n+          if (nextCfgNode == fallThrough) {\n+            removeDeadExprStatementSafely(n);\n+            return fallThrough;\n+          }\n+\n+        }\n+    }\n+    return n;\n+  }\n+\n+  private void removeDeadExprStatementSafely(Node n) {\n+    if (n.getType() == Token.EMPTY ||\n+        (n.getType() == Token.BLOCK && !n.hasChildren())) {\n+      // Not always trivial to remove, let FoldContants work its magic later.\n+      return;\n+    }\n+    // Removing an unreachable DO node is messy because it means we still have\n+    // to execute one iteration. If the DO's body has breaks in the middle, it\n+    // can get even more trickier and code size might actually increase.\n+    switch (n.getType()) {\n+      case Token.DO:\n+      case Token.TRY:\n+      case Token.CATCH:\n+      case Token.FINALLY:\n+        return;\n+    }\n+\n+    NodeUtil.redeclareVarsInsideBranch(n);\n+    compiler.reportCodeChange();\n+    if (logger.isLoggable(Level.FINE)) {\n+      logger.fine(\"Removing \" + n.toString());\n+    }\n+    NodeUtil.removeChild(n.getParent(), n);\n+  }\n+}\n\n"
    },
    "Closure-91": {
        "Buggy Function": "  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n    if (n.getType() == Token.FUNCTION) {\n      // Don't traverse functions that are constructors or have the @this\n      // or @override annotation.\n      JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n      if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.isInterface() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }\n\n      // Don't traverse functions unless they would normally\n      // be able to have a @this annotation associated with them. e.g.,\n      // var a = function() { }; // or\n      // function a() {} // or\n      // a.x = function() {}; // or\n      // var a = {x: function() {}};\n      int pType = parent.getType();\n      if (!(pType == Token.BLOCK ||\n            pType == Token.SCRIPT ||\n            pType == Token.NAME ||\n            pType == Token.ASSIGN ||\n\n            // object literal keys\n            pType == Token.STRING ||\n            pType == Token.NUMBER)) {\n        return false;\n      }\n\n      // Don't traverse functions that are getting lent to a prototype.\n    }\n\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n      Node lhs = parent.getFirstChild();\n      Node rhs = lhs.getNext();\n\n      if (n == lhs) {\n        // Always traverse the left side of the assignment. To handle\n        // nested assignments properly (e.g., (a = this).property = c;),\n        // assignLhsChild should not be overridden.\n        if (assignLhsChild == null) {\n          assignLhsChild = lhs;\n        }\n      } else {\n        // Only traverse the right side if it's not an assignment to a prototype\n        // property or subproperty.\n        if (NodeUtil.isGet(lhs)) {\n          if (lhs.getType() == Token.GETPROP &&\n              lhs.getLastChild().getString().equals(\"prototype\")) {\n            return false;\n          }\n          Node llhs = lhs.getFirstChild();\n          if (llhs.getType() == Token.GETPROP &&\n              llhs.getLastChild().getString().equals(\"prototype\")) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  }",
        "Inducing Changes": "diff --git a/src/com/google/javascript/jscomp/CheckGlobalThis.java b/src/com/google/javascript/jscomp/CheckGlobalThis.java\nindex 514f19e..604526e 100644\n--- a/src/com/google/javascript/jscomp/CheckGlobalThis.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalThis.java\n@@ -99,12 +99,14 @@\n       // be able to have a @this annotation associated with them. e.g.,\n       // var a = function() { }; // or\n       // function a() {} // or\n-      // a.x = function() {};\n+      // a.x = function() {}; // or\n+      // var a = {x: function() {}};\n       int pType = parent.getType();\n       if (!(pType == Token.BLOCK ||\n             pType == Token.SCRIPT ||\n             pType == Token.NAME ||\n-            pType == Token.ASSIGN)) {\n+            pType == Token.ASSIGN ||\n+            pType == Token.OBJECTLIT)) {\n         return false;\n       }\n     }\n\n"
    },
    "Closure-92": {
        "Buggy Function": "    void replace() {\n      if (firstNode == null) {\n        // Don't touch the base case ('goog').\n        replacementNode = candidateDefinition;\n        return;\n      }\n\n      // Handle the case where there is a duplicate definition for an explicitly\n      // provided symbol.\n      if (candidateDefinition != null && explicitNode != null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n\n        // Does this need a VAR keyword?\n        replacementNode = candidateDefinition;\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n          Node assignNode = candidateDefinition.getFirstChild();\n          Node nameNode = assignNode.getFirstChild();\n          if (nameNode.getType() == Token.NAME) {\n            // Need to convert this assign to a var declaration.\n            Node valueNode = nameNode.getNext();\n            assignNode.removeChild(nameNode);\n            assignNode.removeChild(valueNode);\n            nameNode.addChildToFront(valueNode);\n            Node varNode = new Node(Token.VAR, nameNode);\n            varNode.copyInformationFrom(candidateDefinition);\n            candidateDefinition.getParent().replaceChild(\n                candidateDefinition, varNode);\n            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n            compiler.reportCodeChange();\n            replacementNode = varNode;\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        replacementNode = createDeclarationNode();\n        if (firstModule == minimumModule) {\n          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n          // In this case, the name was implicitly provided by two independent\n          // modules. We need to move this code up to a common module.\n          int indexOfDot = namespace.indexOf('.');\n          if (indexOfDot == -1) {\n            // Any old place is fine.\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(replacementNode);\n          } else {\n            // Add it after the parent namespace.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName);\n            Preconditions.checkNotNull(parentName.replacementNode);\n            parentName.replacementNode.getParent().addChildAfter(\n                replacementNode, parentName.replacementNode);\n          }\n        }\n        if (explicitNode != null) {\n          explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n      }\n    }",
        "Inducing Changes": "diff --git a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\nindex 1d738b5..c929a36 100644\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n@@ -786,7 +786,7 @@\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.lastIndexOf('.');\n+          int indexOfDot = namespace.indexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n\n"
    },
    "Closure-99": {
        "Buggy Function": "  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n    if (n.getType() == Token.FUNCTION) {\n      // Don't traverse functions that are constructors or have the @this\n      // or @override annotation.\n      JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n      if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }\n\n      // Don't traverse functions unless they would normally\n      // be able to have a @this annotation associated with them. e.g.,\n      // var a = function() { }; // or\n      // function a() {} // or\n      // a.x = function() {};\n      int pType = parent.getType();\n      if (!(pType == Token.BLOCK ||\n            pType == Token.SCRIPT ||\n            pType == Token.NAME ||\n            pType == Token.ASSIGN)) {\n        return false;\n      }\n    }\n\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n      Node lhs = parent.getFirstChild();\n      Node rhs = lhs.getNext();\n      \n      if (n == lhs) {\n        // Always traverse the left side of the assignment. To handle\n        // nested assignments properly (e.g., (a = this).property = c;),\n        // assignLhsChild should not be overridden.\n        if (assignLhsChild == null) {\n          assignLhsChild = lhs;\n        }\n      } else {\n        // Only traverse the right side if it's not an assignment to a prototype\n        // property or subproperty.\n          if (lhs.getType() == Token.GETPROP &&\n              lhs.getLastChild().getString().equals(\"prototype\")) {\n            return false;\n          }\n          if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains(\".prototype.\")) {\n            return false;\n          }\n      }\n    }\n\n    return true;\n  }",
        "Inducing Changes": "diff --git a/src/com/google/javascript/jscomp/CheckGlobalThis.java b/src/com/google/javascript/jscomp/CheckGlobalThis.java\nnew file mode 100644\nindex 0000000..1b6c93f\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/CheckGlobalThis.java\n@@ -0,0 +1,183 @@\n+/*\n+ * Copyright 2007 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.javascript.jscomp.CheckLevel;\n+import com.google.javascript.jscomp.NodeTraversal.Callback;\n+import com.google.javascript.rhino.JSDocInfo;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+/**\n+ * Checks for certain uses of the {@code this} keyword that are considered\n+ * unsafe because they are likely to reference the global {@code this} object\n+ * unintentionally.\n+ *\n+ * <p>A use of {@code this} is considered unsafe if it's on the left side of an\n+ * assignment or a property access, and not inside one of the following:\n+ * <ol>\n+ * <li>a prototype method\n+ * <li>a function annotated with {@code @constructor}\n+ * <li>a function annotated with {@code @this}.\n+ * <li>a function where there's no logical place to put a\n+ *     {@code this} annotation.\n+ * </ol>\n+ *\n+ * <p>Note that this check does not track assignments of {@code this} to\n+ * variables or objects. The code\n+ * <pre>\n+ * function evil() {\n+ *   var a = this;\n+ *   a.useful = undefined;\n+ * }\n+ * </pre>\n+ * will not get flagged, even though it is semantically equivalent to\n+ * <pre>\n+ * function evil() {\n+ *   this.useful = undefined;\n+ * }\n+ * </pre>\n+ * which would get flagged.\n+ *\n+*\n+*\n+ */\n+final class CheckGlobalThis implements Callback {\n+\n+  static final DiagnosticType GLOBAL_THIS = DiagnosticType.warning(\n+      \"JSC_USED_GLOBAL_THIS\",\n+      \"dangerous use of the global 'this' object\");\n+\n+  private final AbstractCompiler compiler;\n+  private final CheckLevel level;\n+  \n+  /**\n+   * If {@code assignLhsChild != null}, then the node being traversed is\n+   * a descendant of the first child of an ASSIGN node. assignLhsChild's\n+   * parent is this ASSIGN node.\n+   */\n+  private Node assignLhsChild = null;\n+\n+  CheckGlobalThis(AbstractCompiler compiler, CheckLevel level) {\n+    this.compiler = compiler;\n+    this.level = level;\n+  }\n+\n+  /**\n+   * Since this pass reports errors only when a global {@code this} keyword\n+   * is encountered, there is no reason to traverse non global contexts.\n+   */\n+  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n+\n+    if (n.getType() == Token.FUNCTION) {\n+      // Don't traverse functions that are constructors or have the @this\n+      // annotation.\n+      JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n+      if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n+        return false;\n+      }\n+\n+      // Don't traverse functions unless they would normally\n+      // be able to have a @this annotation associated with them. e.g.,\n+      // var a = function() { }; // or\n+      // function a() {} // or\n+      // a.x = function() {};\n+      int pType = parent.getType();\n+      if (!(pType == Token.BLOCK ||\n+            pType == Token.SCRIPT ||\n+            pType == Token.NAME ||\n+            pType == Token.ASSIGN)) {\n+        return false;\n+      }\n+    }\n+\n+    if (parent != null && parent.getType() == Token.ASSIGN) {\n+      Node lhs = parent.getFirstChild();\n+      Node rhs = lhs.getNext();\n+      \n+      if (n == lhs) {\n+        // Always traverse the left side of the assignment. To handle\n+        // nested assignments properly (e.g., (a = this).property = c;),\n+        // assignLhsChild should not be overridden.\n+        if (assignLhsChild == null) {\n+          assignLhsChild = lhs;\n+        }\n+      } else {\n+        // Only traverse the right side if it's not an assignment to a prototype\n+        // property or subproperty.\n+        if (lhs.getType() == Token.GETPROP) {\n+          if (lhs.getLastChild().getString().equals(\"prototype\")) {\n+            return false;\n+          }\n+          String leftName = lhs.getQualifiedName();\n+          if (leftName != null && leftName.contains(\".prototype.\")) {\n+            return false;\n+          }\n+        }\n+      }\n+    }\n+\n+    return true;\n+  }\n+\n+  public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (n.getType() == Token.THIS && shouldReportThis(n, parent)) {\n+      compiler.report(t.makeError(n, level, GLOBAL_THIS));\n+    }\n+    if (n == assignLhsChild) {\n+      assignLhsChild = null;\n+    }\n+  }\n+\n+  private boolean shouldReportThis(Node n, Node parent) {\n+    if (assignLhsChild != null) {\n+      // Always report a THIS on the left side of an assign.\n+      return true;\n+    }\n+\n+    // Also report a THIS with a property access.\n+    return parent != null && NodeUtil.isGet(parent);\n+  }\n+\n+  /**\n+   * Gets a function's JSDoc information, if it has any. Checks for a few\n+   * patterns (ellipses show where JSDoc would be):\n+   * <pre>\n+   * ... function() {}\n+   * ... x = function() {};\n+   * var ... x = function() {};\n+   * ... var x = function() {};\n+   * </pre>\n+   */\n+  private JSDocInfo getFunctionJsDocInfo(Node n) {\n+    JSDocInfo jsDoc = n.getJSDocInfo();\n+    Node parent = n.getParent();\n+    if (jsDoc == null) {\n+      int parentType = parent.getType();\n+      if (parentType == Token.NAME || parentType == Token.ASSIGN) {\n+        jsDoc = parent.getJSDocInfo();\n+        if (jsDoc == null && parentType == Token.NAME) {\n+          Node gramps = parent.getParent();\n+          if (gramps.getType() == Token.VAR) {\n+            jsDoc = gramps.getJSDocInfo();\n+          }\n+        }\n+      }\n+    }\n+    return jsDoc;\n+  }\n+}\n\n"
    },
    "Closure-104": {
        "Buggy Function": "  JSType meet(JSType that) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n    for (JSType alternate : alternates) {\n      if (alternate.isSubtype(that)) {\n        builder.addAlternate(alternate);\n      }\n    }\n\n    if (that instanceof UnionType) {\n      for (JSType otherAlternate : ((UnionType) that).alternates) {\n        if (otherAlternate.isSubtype(this)) {\n          builder.addAlternate(otherAlternate);\n        }\n      }\n    } else if (that.isSubtype(this)) {\n      builder.addAlternate(that);\n    }\n    JSType result = builder.build();\n    if (result != null) {\n      return result;\n    } else if (this.isObject() && that.isObject()) {\n      return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n    } else {\n      return getNativeType(JSTypeNative.NO_TYPE);\n    }\n  }",
        "Inducing Changes": "diff --git a/src/com/google/javascript/rhino/jstype/UnionType.java b/src/com/google/javascript/rhino/jstype/UnionType.java\nindex d0bda12..c200b64 100644\n--- a/src/com/google/javascript/rhino/jstype/UnionType.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionType.java\n@@ -271,28 +271,31 @@\n     return getLeastSupertype(this, that);\n   }\n \n-  @Override\n-  public JSType getGreatestSubtype(JSType that) {\n-    if (that instanceof UnionType) {\n-      return meet((UnionType) that);\n-    }\n-    return getGreatestSubtype(this, that);\n-  }\n-\n-  private JSType meet(UnionType that) {\n+  JSType meet(JSType that) {\n     UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n     for (JSType alternate : alternates) {\n       if (alternate.isSubtype(that)) {\n         builder.addAlternate(alternate);\n       }\n     }\n-    for (JSType otherAlternate : that.alternates) {\n-      if (otherAlternate.isSubtype(this)) {\n-        builder.addAlternate(otherAlternate);\n+\n+    if (that instanceof UnionType) {\n+      for (JSType otherAlternate : ((UnionType) that).alternates) {\n+        if (otherAlternate.isSubtype(this)) {\n+          builder.addAlternate(otherAlternate);\n+        }\n       }\n+    } else if (that.isSubtype(this)) {\n+      builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    return result == null ? getNativeType(JSTypeNative.NO_TYPE) : result;\n+    if (result != null) {\n+      return result;\n+    } else if (this.isObject() && that.isObject()) {\n+      return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n+    } else {\n+      return getNativeType(JSTypeNative.NO_TYPE);\n+    }\n   }\n \n   /**\n\n"
    },
    "Closure-107": {
        "Buggy Function": "  protected CompilerOptions createOptions() {\n    CompilerOptions options = new CompilerOptions();\n    if (flags.processJqueryPrimitives) {\n      options.setCodingConvention(new JqueryCodingConvention());\n    } else {\n      options.setCodingConvention(new ClosureCodingConvention());\n    }\n\n    options.setExtraAnnotationNames(flags.extraAnnotationName);\n\n    CompilationLevel level = flags.compilationLevel;\n    level.setOptionsForCompilationLevel(options);\n\n    if (flags.debug) {\n      level.setDebugOptionsForCompilationLevel(options);\n    }\n\n    if (flags.useTypesForOptimization) {\n      level.setTypeBasedOptimizationOptions(options);\n    }\n\n    if (flags.generateExports) {\n      options.setGenerateExports(flags.generateExports);\n    }\n\n    WarningLevel wLevel = flags.warningLevel;\n    wLevel.setOptionsForWarningLevel(options);\n    for (FormattingOption formattingOption : flags.formatting) {\n      formattingOption.applyToOptions(options);\n    }\n\n    options.closurePass = flags.processClosurePrimitives;\n\n    options.jqueryPass = CompilationLevel.ADVANCED_OPTIMIZATIONS == level &&\n        flags.processJqueryPrimitives;\n\n    options.angularPass = flags.angularPass;\n\n    if (!flags.translationsFile.isEmpty()) {\n      try {\n        options.messageBundle = new XtbMessageBundle(\n            new FileInputStream(flags.translationsFile),\n            flags.translationsProject);\n      } catch (IOException e) {\n        throw new RuntimeException(\"Reading XTB file\", e);\n      }\n    } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {\n      // In SIMPLE or WHITESPACE mode, if the user hasn't specified a\n      // translations file, they might reasonably try to write their own\n      // implementation of goog.getMsg that makes the substitution at\n      // run-time.\n      //\n      // In ADVANCED mode, goog.getMsg is going to be renamed anyway,\n      // so we might as well inline it. But shut off the i18n warnings,\n      // because the user didn't really ask for i18n.\n      options.messageBundle = new EmptyMessageBundle();\n    }\n\n    return options;\n  }",
        "Inducing Changes": "diff --git a/src/com/google/javascript/jscomp/CommandLineRunner.java b/src/com/google/javascript/jscomp/CommandLineRunner.java\nindex 6224434..a544ceb 100644\n--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n@@ -34,6 +34,7 @@\n import org.kohsuke.args4j.spi.StringOptionHandler;\n \n import java.io.File;\n+import java.io.FileInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.PrintStream;\n@@ -346,6 +347,16 @@\n         usage = \"Prints the compiler version to stderr.\")\n     private boolean version = false;\n \n+    @Option(name = \"--translations_file\",\n+        usage = \"Source of translated messages. Currently only supports XTB.\")\n+    private String translationsFile = \"\";\n+\n+    @Option(name = \"--translations_project\",\n+        usage = \"Scopes all translations to the specified project.\" +\n+        \"When specified, we will use different message ids so that messages \" +\n+        \"in different projects can have different translations.\")\n+    private String translationsProject = null;\n+\n     @Option(name = \"--flagfile\",\n         usage = \"A file containing additional command-line options.\")\n     private String flag_file = \"\";\n@@ -626,7 +637,7 @@\n       level.setDebugOptionsForCompilationLevel(options);\n     }\n \n-    if(flags.generate_exports) {\n+    if (flags.generate_exports) {\n       options.setGenerateExports(flags.generate_exports);\n     }\n \n@@ -637,6 +648,26 @@\n     }\n \n     options.closurePass = flags.process_closure_primitives;\n+\n+    if (!flags.translationsFile.isEmpty()) {\n+      try {\n+        options.messageBundle = new XtbMessageBundle(\n+            new FileInputStream(flags.translationsFile),\n+            flags.translationsProject);\n+      } catch (IOException e) {\n+        throw new RuntimeException(\"Reading XTB file\", e);\n+      }\n+    } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {\n+      // In SIMPLE or WHITESPACE mode, if the user hasn't specified a\n+      // translations file, they might reasonably try to write their own\n+      // implementation of goog.getMsg that makes the substitution at\n+      // run-time.\n+      //\n+      // In ADVANCED mode, goog.getMsg is going to be renamed anyway,\n+      // so we might as well inline it.\n+      options.messageBundle = new EmptyMessageBundle();\n+    }\n+\n     return options;\n   }\n \n\n"
    },
    "Closure-113": {
        "Buggy Function": "  private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n    Node left = n.getFirstChild();\n    Node arg = left.getNext();\n    if (verifyLastArgumentIsString(t, left, arg)) {\n      String ns = arg.getString();\n      ProvidedName provided = providedNames.get(ns);\n      if (provided == null || !provided.isExplicitlyProvided()) {\n        unrecognizedRequires.add(\n            new UnrecognizedRequire(n, ns, t.getSourceName()));\n      } else {\n        JSModule providedModule = provided.explicitModule;\n\n        // This must be non-null, because there was an explicit provide.\n        Preconditions.checkNotNull(providedModule);\n\n        JSModule module = t.getModule();\n        if (moduleGraph != null &&\n            module != providedModule &&\n            !moduleGraph.dependsOn(module, providedModule)) {\n          compiler.report(\n              t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                  providedModule.getName(),\n                  module.getName()));\n        }\n      }\n\n      maybeAddToSymbolTable(left);\n      maybeAddStringNodeToSymbolTable(arg);\n\n      // Requires should be removed before further processing.\n      // Some clients run closure pass multiple times, first with\n      // the checks for broken requires turned off. In these cases, we\n      // allow broken requires to be preserved by the first run to\n      // let them be caught in the subsequent run.\n      if (provided != null) {\n        parent.detachFromParent();\n        compiler.reportCodeChange();\n      }\n    }\n  }",
        "Inducing Changes": "diff --git a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\nindex e8eacab..6f69dff 100644\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n@@ -322,12 +322,11 @@\n       maybeAddStringNodeToSymbolTable(arg);\n \n       // Requires should be removed before runtime.  The one\n-      // exception is if the type has not been provided yet and\n-      // errors for broken requires are turned off, in which case,\n+      // exception is if the type has not been provided yet, in which case,\n       // we will be doing a later pass that may error, so we can\n       // leave this here this time and let it error next time if it\n       // is still not provided.\n-      if (provided != null || requiresLevel.isOn()) {\n+      if (provided != null) {\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }\n\n"
    },
    "Closure-114": {
        "Buggy Function": "    private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n      Node nameNode = n.getFirstChild();\n      Node parent = n.getParent();\n      NameInformation ns = createNameInformation(t, nameNode);\n      if (ns != null) {\n        if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n          // Patch for assignments that appear in the init,\n          // condition or iteration part of a FOR loop.  Without\n          // this change, all 3 of those parts try to claim the for\n          // loop as their dependency scope.  The last assignment in\n          // those three fields wins, which can result in incorrect\n          // reference edges between referenced and assigned variables.\n          //\n          // TODO(user) revisit the dependency scope calculation\n          // logic.\n          if (parent.getFirstChild().getNext() != n) {\n            recordDepScope(recordNode, ns);\n          } else {\n            recordDepScope(nameNode, ns);\n          }\n        } else {\n          // The rhs of the assignment is the caller, so it's used by the\n          // context. Don't associate it w/ the lhs.\n          // FYI: this fixes only the specific case where the assignment is the\n          // caller expression, but it could be nested deeper in the caller and\n          // we would still get a bug.\n          // See testAssignWithCall2 for an example of this.\n          recordDepScope(recordNode, ns);\n        }\n      }\n    }",
        "Inducing Changes": "diff --git a/src/com/google/javascript/jscomp/NameAnalyzer.java b/src/com/google/javascript/jscomp/NameAnalyzer.java\nindex 8a2c0ee..9069c01 100644\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n@@ -518,7 +518,7 @@\n               recordDepScope(nameNode, ns);\n             }\n           } else {\n-            recordDepScope(parent, ns);\n+            recordDepScope(n, ns);\n           }\n         }\n       } else if (NodeUtil.isVarDeclaration(n)) {\n@@ -1506,10 +1506,7 @@\n       }\n \n       if (parent.getType() == Token.ASSIGN) {\n-        Node gramp = parent.getParent();\n-        if (gramp != null && gramp.getType() == Token.EXPR_RESULT) {\n-          return scopes.get(gramp);\n-        }\n+        return scopes.get(parent);\n       }\n     }\n \n\n"
    },
    "Closure-115": {
        "Buggy Function": "  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n    boolean hasSideEffects = false;\n    if (block.hasChildren()) {\n      Preconditions.checkState(block.hasOneChild());\n      Node stmt = block.getFirstChild();\n      if (stmt.isReturn()) {\n        hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);\n      }\n    }\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Functions called via 'call' and 'apply' have a this-object as\n    // the first parameter, but this is not part of the called function's\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // TODO(johnlenz): Support replace this with a value.\n        if (cArg == null || !cArg.isThis()) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      } else {\n        // \".apply\" call should be filtered before this.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n      // For each named parameter check if a mutable argument use more than one.\n      if (fnParam != null) {\n        if (cArg != null) {\n          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n            return CanInlineResult.NO;\n          }\n          // Check for arguments that are evaluated more than once.\n          // Note: Unlike block inlining, there it is not possible that a\n          // parameter reference will be in a loop.\n          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n              && NodeUtil.getNameReferenceCount(\n                  block, fnParam.getString()) > 1) {\n            return CanInlineResult.NO;\n          }\n        }\n\n        // Move to the next name.\n        fnParam = fnParam.getNext();\n      }\n\n      // For every call argument check for side-effects, even if there\n      // isn't a named parameter to match.\n      if (cArg != null) {\n        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      }\n    }\n\n    return CanInlineResult.YES;\n  }",
        "Inducing Changes": "diff --git a/src/com/google/javascript/jscomp/FunctionInjector.java b/src/com/google/javascript/jscomp/FunctionInjector.java\nindex 5b38600..accf4c5 100644\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n@@ -694,6 +694,16 @@\n \n     Node block = fnNode.getLastChild();\n \n+    boolean hasSideEffects = false;  // empty function case\n+    if (block.hasChildren()) {\n+      Preconditions.checkState(block.hasOneChild());\n+      Node stmt = block.getFirstChild();\n+      if (stmt.isReturn()) {\n+        hasSideEffects = NodeUtil.mayHaveSideEffects(\n+            stmt.getFirstChild(), compiler);\n+      }\n+    }\n+\n     // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n     Node cArg = callNode.getFirstChild().getNext();\n \n@@ -719,6 +729,10 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n+          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n+            return CanInlineResult.NO;\n+          }\n+\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n"
    },
    "Closure-120": {
        "Buggy Function": "    boolean isAssignedOnceInLifetime() {\n      Reference ref = getOneAndOnlyAssignment();\n      if (ref == null) {\n        return false;\n      }\n\n      // Make sure this assignment is not in a loop.\n      for (BasicBlock block = ref.getBasicBlock();\n           block != null; block = block.getParent()) {\n        if (block.isFunction) {\n          break;\n        } else if (block.isLoop) {\n          return false;\n        }\n      }\n\n      return true;\n    }",
        "Inducing Changes": "diff --git a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\nindex f89f10c..cdacc5f 100644\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n@@ -423,7 +423,7 @@\n       if (ref == null) {\n         return false;\n       }\n-      \n+\n       // Make sure this assignment is not in a loop.\n       for (BasicBlock block = ref.getBasicBlock();\n            block != null; block = block.getParent()) {\n@@ -436,29 +436,6 @@\n \n       return true;\n     }\n-    \n-    /**\n-     * @return Whether the variable is only assigned a value once for its\n-     *     lifetime.\n-     */\n-    boolean isOnlyAssignmentSameScopeAsDeclaration() {\n-      Reference ref = getOneAndOnlyAssignment();\n-      Preconditions.checkNotNull(ref);\n-      \n-      // Make sure the declaration is the same scope as the assignment.\n-      // Otherwise, the variable can be assigned multiple times and possibly\n-      // with a different variable.\n-      for (BasicBlock block = ref.getBasicBlock();\n-           block != null; block = block.getParent()) {\n-        if (block.isFunction) {\n-          if (ref.getSymbol().getScope() != ref.scope) {\n-            return false;\n-          }\n-        }\n-      }\n-\n-      return true;\n-    }\n \n     /**\n      * @return The one and only assignment. Returns if there are 0 or 2+\n\n"
    },
    "Closure-121": {
        "Buggy Function": "    private void inlineNonConstants(\n        Var v, ReferenceCollection referenceInfo,\n        boolean maybeModifiedArguments) {\n      int refCount = referenceInfo.references.size();\n      Reference declaration = referenceInfo.references.get(0);\n      Reference init = referenceInfo.getInitializingReference();\n      int firstRefAfterInit = (declaration == init) ? 2 : 3;\n\n      if (refCount > 1 &&\n          isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n        // if the variable is referenced more than once, we can only\n        // inline it if it's immutable and never defined before referenced.\n        Node value;\n        if (init != null) {\n          value = init.getAssignedValue();\n        } else {\n          // Create a new node for variable that is never initialized.\n          Node srcLocation = declaration.getNode();\n          value = NodeUtil.newUndefinedNode(srcLocation);\n        }\n        Preconditions.checkNotNull(value);\n        inlineWellDefinedVariable(v, value, referenceInfo.references);\n        staleVars.add(v);\n      } else if (refCount == firstRefAfterInit) {\n        // The variable likely only read once, try some more\n        // complex inlining heuristics.\n        Reference reference = referenceInfo.references.get(\n            firstRefAfterInit - 1);\n        if (canInline(declaration, init, reference)) {\n          inline(v, declaration, init, reference);\n          staleVars.add(v);\n        }\n      } else if (declaration != init && refCount == 2) {\n        if (isValidDeclaration(declaration) && isValidInitialization(init)) {\n          // The only reference is the initialization, remove the assignment and\n          // the variable declaration.\n          Node value = init.getAssignedValue();\n          Preconditions.checkNotNull(value);\n          inlineWellDefinedVariable(v, value, referenceInfo.references);\n          staleVars.add(v);\n        }\n      }\n\n      // If this variable was not inlined normally, check if we can\n      // inline an alias of it. (If the variable was inlined, then the\n      // reference data is out of sync. We're better off just waiting for\n      // the next pass.)\n      if (!maybeModifiedArguments &&\n          !staleVars.contains(v) &&\n          referenceInfo.isWellDefined() &&\n          referenceInfo.isAssignedOnceInLifetime()) {\n          // Inlining the variable based solely on well-defined and assigned\n          // once is *NOT* correct. We relax the correctness requirement if\n          // the variable is declared constant.\n        List<Reference> refs = referenceInfo.references;\n        for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n          Node nameNode = refs.get(i).getNode();\n          if (aliasCandidates.containsKey(nameNode)) {\n            AliasCandidate candidate = aliasCandidates.get(nameNode);\n            if (!staleVars.contains(candidate.alias) &&\n                !isVarInlineForbidden(candidate.alias)) {\n              Reference aliasInit;\n              aliasInit = candidate.refInfo.getInitializingReference();\n              Node value = aliasInit.getAssignedValue();\n              Preconditions.checkNotNull(value);\n              inlineWellDefinedVariable(candidate.alias,\n                  value,\n                  candidate.refInfo.references);\n              staleVars.add(candidate.alias);\n            }\n          }\n        }\n      }\n    }",
        "Inducing Changes": "diff --git a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\nindex 8eccd0f..28d6763 100644\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n@@ -16,6 +16,7 @@\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.base.Preconditions;\n import com.google.common.base.Predicate;\n import com.google.common.base.Predicates;\n import com.google.common.collect.ImmutableSet;\n@@ -247,14 +248,15 @@\n \n       // If this is a declaration that does not instantiate the variable,\n       // it's not well-defined.\n-      Reference decl = references.get(0);\n-      if (!decl.isInitializingDeclaration()) {\n+      Reference init = getInitializingReference();\n+      if (init == null) {\n         return false;\n       }\n \n-      BasicBlock declBlock = decl.getBasicBlock();\n+      Preconditions.checkState(references.get(0).isDeclaration());\n+      BasicBlock initBlock = init.getBasicBlock();\n       for (int i = 1; i < size; i++) {\n-        if (!declBlock.provablyExecutesBefore(\n+        if (!initBlock.provablyExecutesBefore(\n                 references.get(i).getBasicBlock())) {\n           return false;\n         }\n@@ -263,15 +265,98 @@\n       return true;\n     }\n \n-    boolean isNeverReassigned() {\n-      int size = references.size();\n-      for (int i = 1; i < size; i++) {\n-        if (references.get(i).isLvalue()) {\n-          return false;\n+    /**\n+     * @param index The index into the references array to look for an \n+     * assigning declaration.\n+     *\n+     * This is either the declaration if a value is assigned (such as\n+     * \"var a = 2\", \"function a()...\", \"... catch (a)...\").\n+     */\n+    private boolean isInitializingDeclarationAt(int index) {\n+      Reference maybeInit = references.get(index);\n+      if (maybeInit.isInitializingDeclaration()) {\n+        // This is a declaration that represents the initial value. \n+        // Specifically, var declarations without assignments such as \"var a;\"\n+        // are not.\n+        return true;\n+      }\n+      return false;\n+    }\n+    \n+    /**\n+     * @param index The index into the references array to look for an \n+     * initialized assignment reference. That is, an assignment immediately\n+     * follow a variable declaration that itself does not initialize the\n+     * variable.\n+     */\n+    private boolean isInitializingAssignmentAt(int index) {\n+      if (index < references.size() && index > 0) {\n+        Reference maybeDecl = references.get(index-1);\n+        if (maybeDecl.isVarDeclaration()) {\n+          Preconditions.checkState(!maybeDecl.isInitializingDeclaration());\n+          Reference maybeInit = references.get(index);\n+          if (maybeInit.isSimpleAssignmentToName()) {\n+            return true;\n+          }\n         }\n       }\n+      return false;\n+    }    \n \n-      return true;\n+    /**\n+     * @return The reference that provides the value for the variable at the\n+     * time of the first read, if known, otherwise null.\n+     *\n+     * This is either the variable declaration (\"var a = ...\") or first\n+     * reference following the declaration if it is an assignment.\n+     */\n+    Reference getInitializingReference() {\n+      if (isInitializingDeclarationAt(0)) {\n+        return references.get(0);\n+      } else if (isInitializingAssignmentAt(1)) {\n+        return references.get(1);\n+      }\n+      return null;\n+    }\n+\n+    /**\n+     * Constants are allowed to be defined after their first use.\n+     */\n+    Reference getInitializingReferenceForConstants() {\n+      int size = references.size();\n+      for (int i = 0; i < size; i++) {\n+        if (isInitializingDeclarationAt(i) || isInitializingAssignmentAt(i)) {\n+          return references.get(i);\n+        }\n+      }\n+      return null;\n+    }\n+\n+    /**\n+     * @return Whether the variable is only assigned a value once.\n+     */\n+    boolean isAssignedOnce() {\n+      boolean assigned = false;\n+      int size = references.size();\n+      for (int i = 0; i < size; i++) {\n+        Reference ref = references.get(i);\n+        if (ref.isLvalue() || ref.isInitializingDeclaration()) {\n+          if (!assigned) {\n+            assigned = true;\n+          } else {\n+            return false;\n+          }\n+        }\n+      }\n+      return assigned;\n+    }\n+\n+    boolean firstReferenceIsAssigningDeclaration() {\n+      int size = references.size();\n+      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n+        return true;\n+      }\n+      return false;\n     }\n   }\n \n@@ -320,6 +405,16 @@\n           grandparent.getType() == Token.FUNCTION;\n     }\n \n+    boolean isVarDeclaration() {\n+      return parent.getType() == Token.VAR;\n+    }\n+\n+    boolean isHoistedFunction() {\n+      return NodeUtil.isFunctionDeclaration(parent) &&\n+          (grandparent.getType() == Token.SCRIPT ||\n+           grandparent.getParent().getType() == Token.FUNCTION);\n+    }\n+\n     /**\n      * Determines whether the variable is initialized at the declaration.\n      */\n@@ -330,6 +425,14 @@\n           (parent.getType() != Token.VAR || nameNode.getFirstChild() != null);\n     }\n \n+   /**\n+    * @return For an assignment or variable declaration return the assigned\n+    * value, otherwise null.\n+    */\n+    Node getAssignedValue() {\n+      return NodeUtil.getAssignedValue(getNameNode());\n+    }\n+\n     BasicBlock getBasicBlock() {\n       return basicBlock;\n     }\n@@ -349,18 +452,23 @@\n     private static boolean isForIn(Node n) {\n       return n.getType() == Token.FOR && n.getChildCount() == 3;\n     }\n-    \n+\n     private static boolean isLhsOfForInExpression(Node n) {\n       Node parent = n.getParent();\n       if (parent.getType() == Token.VAR) {\n         return isLhsOfForInExpression(parent);\n-      } \n+      }\n       return isForIn(parent) && parent.getFirstChild() == n;\n     }\n-    \n+\n+    boolean isSimpleAssignmentToName() {\n+      return parent.getType() == Token.ASSIGN\n+          && parent.getFirstChild() == nameNode;\n+    }\n+\n     boolean isLvalue() {\n       int parentType = parent.getType();\n-      return parentType == Token.VAR \n+      return (parentType == Token.VAR && nameNode.getFirstChild() != null)\n           || parentType == Token.INC\n           || parentType == Token.DEC\n           || (NodeUtil.isAssignmentOp(parent)\n\n"
    },
    "Closure-125": {
        "Buggy Function": "  private void visitNew(NodeTraversal t, Node n) {\n    Node constructor = n.getFirstChild();\n    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n    if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n      FunctionType fnType = type.toMaybeFunctionType();\n      if (fnType != null) {\n        visitParameterList(t, n, fnType);\n        ensureTyped(t, n, fnType.getInstanceType());\n      } else {\n        ensureTyped(t, n);\n      }\n    } else {\n      report(t, n, NOT_A_CONSTRUCTOR);\n      ensureTyped(t, n);\n    }\n  }",
        "Inducing Changes": ""
    },
    "Closure-128": {
        "Buggy Function": "  static boolean isSimpleNumber(String s) {\n    int len = s.length();\n    for (int index = 0; index < len; index++) {\n      char c = s.charAt(index);\n      if (c < '0' || c > '9') {\n        return false;\n      }\n    }\n    return len > 0 && s.charAt(0) != '0';\n  }",
        "Inducing Changes": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex ac6299d..535148c 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -742,7 +742,7 @@\n         return false;\n       }\n     }\n-    return len > 0;\n+    return len > 0 && s.charAt(0) != '0';\n   }\n \n   static double getSimpleNumber(String s) {\n\n"
    },
    "Closure-131": {
        "Buggy Function": "    public static boolean isJSIdentifier(String s) {\n      int length = s.length();\n\n      if (length == 0 ||\n          !Character.isJavaIdentifierStart(s.charAt(0))) {\n        return false;\n      }\n\n      for (int i = 1; i < length; i++) {\n        if (\n            !Character.isJavaIdentifierPart(s.charAt(i))) {\n          return false;\n        }\n      }\n\n      return true;\n    }",
        "Inducing Changes": "diff --git a/src/com/google/javascript/rhino/TokenStream.java b/src/com/google/javascript/rhino/TokenStream.java\nindex b215cfb..23e3149 100644\n--- a/src/com/google/javascript/rhino/TokenStream.java\n+++ b/src/com/google/javascript/rhino/TokenStream.java\n@@ -193,24 +193,43 @@\n                 else if (c=='o') { if (s.charAt(0)=='d') {id=Id_do; break L0;} }\n                 break L;\n             case 3: switch (s.charAt(0)) {\n-                case 'f': if (s.charAt(2)=='r' && s.charAt(1)=='o') {id=Id_for; break L0;} break L;\n-                case 'i': if (s.charAt(2)=='t' && s.charAt(1)=='n') {id=Id_int; break L0;} break L;\n-                case 'n': if (s.charAt(2)=='w' && s.charAt(1)=='e') {id=Id_new; break L0;} break L;\n-                case 't': if (s.charAt(2)=='y' && s.charAt(1)=='r') {id=Id_try; break L0;} break L;\n-                case 'v': if (s.charAt(2)=='r' && s.charAt(1)=='a') {id=Id_var; break L0;} break L;\n+                case 'f':\n+                  if (s.charAt(2)=='r' && s.charAt(1)=='o') {\n+                    id=Id_for; break L0;\n+                  } break L;\n+                case 'i':\n+                  if (s.charAt(2)=='t' && s.charAt(1)=='n') {\n+                    id=Id_int; break L0;\n+                  } break L;\n+                case 'n':\n+                  if (s.charAt(2)=='w' && s.charAt(1)=='e') {\n+                    id=Id_new; break L0;\n+                  } break L;\n+                case 't':\n+                  if (s.charAt(2)=='y' && s.charAt(1)=='r') {\n+                    id=Id_try; break L0;\n+                  } break L;\n+                case 'v':\n+                  if (s.charAt(2)=='r' && s.charAt(1)=='a') {\n+                    id=Id_var; break L0;\n+                  } break L;\n                 } break L;\n             case 4: switch (s.charAt(0)) {\n                 case 'b': X=\"byte\";id=Id_byte; break L;\n                 case 'c': c=s.charAt(3);\n                     if (c=='e') { if (s.charAt(2)=='s' && s.charAt(1)=='a') {\n                             id=Id_case; break L0;} }\n-                    else if (c=='r') { if (s.charAt(2)=='a' && s.charAt(1)=='h') {\n-                            id=Id_char; break L0;} }\n+                    else if (c=='r') {\n+                      if (s.charAt(2)=='a' && s.charAt(1)=='h') {\n+                        id=Id_char; break L0;\n+                      }\n+                    }\n                     break L;\n                 case 'e': c=s.charAt(3);\n                     if (c=='e') { if (s.charAt(2)=='s' && s.charAt(1)=='l') {\n                             id=Id_else; break L0;} }\n-                    else if (c=='m') { if (s.charAt(2)=='u' && s.charAt(1)=='n') {\n+                    else if (c=='m') {\n+                      if (s.charAt(2)=='u' && s.charAt(1)=='n') {\n                             id=Id_enum; break L0;} }\n                     break L;\n                 case 'g': X=\"goto\";id=Id_goto; break L;\n@@ -219,7 +238,8 @@\n                 case 't': c=s.charAt(3);\n                     if (c=='e') { if (s.charAt(2)=='u' && s.charAt(1)=='r') {\n                             id=Id_true; break L0;} }\n-                    else if (c=='s') { if (s.charAt(2)=='i' && s.charAt(1)=='h') {\n+                    else if (c=='s') {\n+                      if (s.charAt(2)=='i' && s.charAt(1)=='h') {\n                             id=Id_this; break L0;} }\n                     break L;\n                 case 'v': X=\"void\";id=Id_void; break L;\n\n"
    },
    "Closure-133": {
        "Buggy Function": "  private String getRemainingJSDocLine() {\n    String result = stream.getRemainingJSDocLine();\n    return result;\n  }",
        "Inducing Changes": "diff --git a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\nindex 3bf7d47..4539ef5 100644\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n@@ -714,30 +714,6 @@\n                   token = eatTokensUntilEOL();\n                   continue retry;\n \n-                case PRIVATE:\n-                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n-                    parser.addParserWarning(\"msg.jsdoc.visibility.private\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case PROTECTED:\n-                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n-                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case PUBLIC:\n-                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n-                    parser.addParserWarning(\"msg.jsdoc.visibility.public\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n                 case NO_SHADOW:\n                   if (!jsdocBuilder.recordNoShadow()) {\n                     parser.addParserWarning(\"msg.jsdoc.noshadow\",\n@@ -841,6 +817,9 @@\n \n                 case DEFINE:\n                 case RETURN:\n+                case PRIVATE:\n+                case PROTECTED:\n+                case PUBLIC:\n                 case THIS:\n                 case TYPE:\n                 case TYPEDEF:\n@@ -848,26 +827,45 @@\n                   charno = stream.getCharno();\n \n                   Node typeNode = null;\n-                  if (!lookAheadForTypeAnnotation() &&\n-                      annotation == Annotation.RETURN) {\n-                    // If RETURN doesn't have a type annotation, record\n-                    // it as the unknown type.\n-                    typeNode = newNode(Token.QMARK);\n-                  } else {\n+                  boolean hasType = lookAheadForTypeAnnotation();\n+                  boolean isVisibilityAnnotation =\n+                      (annotation == Annotation.PRIVATE ||\n+                       annotation == Annotation.PROTECTED ||\n+                       annotation == Annotation.PUBLIC);\n+                  boolean canSkipTypeAnnotation =\n+                      (isVisibilityAnnotation ||\n+                       annotation == Annotation.RETURN);\n+                  type = null;\n+                  if (hasType || !canSkipTypeAnnotation) {\n                     skipEOLs();\n                     token = next();\n                     typeNode = parseAndRecordTypeNode(token);\n+\n+                    if (annotation == Annotation.THIS) {\n+                      typeNode = wrapNode(Token.BANG, typeNode);\n+                    }\n+                    type = createJSTypeExpression(typeNode);\n                   }\n \n-                  if (annotation == Annotation.THIS) {\n-                    typeNode = wrapNode(Token.BANG, typeNode);\n-                  }\n-                  type = createJSTypeExpression(typeNode);\n+                  // The error was reported during recursive descent\n+                  // recovering parsing\n+                  boolean hasError = type == null && !canSkipTypeAnnotation;\n+                  if (!hasError) {\n+                    // Record types for @type.\n+                    // If the @private, @protected, or @public annotations\n+                    // have a type attached, pretend that they actually wrote:\n+                    // @type {type}\\n@private\n+                    // This will have some weird behavior in some cases\n+                    // (for example, @private can now be used as a type-cast),\n+                    // but should be mostly OK.\n+                    if ((type != null && isVisibilityAnnotation)\n+                        || annotation == Annotation.TYPE) {\n+                      if (!jsdocBuilder.recordType(type)) {\n+                        parser.addTypeWarning(\n+                            \"msg.jsdoc.incompat.type\", lineno, charno);\n+                      }\n+                    }\n \n-                  if (type == null) {\n-                    // error reported during recursive descent\n-                    // recovering parsing\n-                  } else {\n                     switch (annotation) {\n                       case DEFINE:\n                         if (!jsdocBuilder.recordDefineType(type)) {\n@@ -876,7 +874,35 @@\n                         }\n                         break;\n \n+                      case PRIVATE:\n+                        if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n+                          parser.addParserWarning(\n+                              \"msg.jsdoc.visibility.private\",\n+                              lineno, charno);\n+                        }\n+                        break;\n+\n+                      case PROTECTED:\n+                        if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n+                          parser.addParserWarning(\n+                              \"msg.jsdoc.visibility.protected\",\n+                              lineno, charno);\n+                        }\n+                        break;\n+\n+                      case PUBLIC:\n+                        if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n+                          parser.addParserWarning(\n+                              \"msg.jsdoc.visibility.public\",\n+                              lineno, charno);\n+                        }\n+                        break;\n+\n                       case RETURN:\n+                        if (type == null) {\n+                          type = createJSTypeExpression(newNode(Token.QMARK));\n+                        }\n+\n                         if (!jsdocBuilder.recordReturnType(type)) {\n                           parser.addTypeWarning(\n                               \"msg.jsdoc.incompat.type\", lineno, charno);\n@@ -909,13 +935,6 @@\n                         }\n                         break;\n \n-                      case TYPE:\n-                        if (!jsdocBuilder.recordType(type)) {\n-                          parser.addTypeWarning(\n-                              \"msg.jsdoc.incompat.type\", lineno, charno);\n-                        }\n-                        break;\n-\n                       case TYPEDEF:\n                         if (!jsdocBuilder.recordTypedef(type)) {\n                           parser.addTypeWarning(\n\n"
    },
    "Lang-4": {
        "Buggy Function": "public LookupTranslator(final CharSequence[]... lookup) {\n    lookupMap = new HashMap<CharSequence, CharSequence>();\n    int _shortest = Integer.MAX_VALUE;\n    int _longest = 0;\n    if (lookup != null) {\n        for (final CharSequence[] seq : lookup) {\n            this.lookupMap.put(seq[0], seq[1]);\n            final int sz = seq[0].length();\n            if (sz < _shortest) {\n                _shortest = sz;\n            }\n            if (sz > _longest) {\n                _longest = sz;\n            }\n        }\n    }\n    shortest = _shortest;\n    longest = _longest;\n}\n@Override\npublic int translate(final CharSequence input, final int index, final Writer out) throws IOException {\n    int max = longest;\n    if (index + longest > input.length()) {\n        max = input.length() - index;\n    }\n    // descend so as to get a greedy algorithm\n    for (int i = max; i >= shortest; i--) {\n        final CharSequence subSeq = input.subSequence(index, index + i);\n        final CharSequence result = lookupMap.get(subSeq);\n        if (result != null) {\n            out.write(result.toString());\n            return i;\n        }\n    }\n    return 0;\n}",
        "Inducing Changes": "diff --git a/src/java/org/apache/commons/lang/text/translate/LookupTranslator.java b/src/java/org/apache/commons/lang/text/translate/LookupTranslator.java\nindex ea45ab6..5e707cd 100644\n--- a/src/java/org/apache/commons/lang/text/translate/LookupTranslator.java\n+++ b/src/java/org/apache/commons/lang/text/translate/LookupTranslator.java\n@@ -18,14 +18,18 @@\n \n import java.io.IOException;\n import java.io.Writer;\n+import java.util.HashMap;\n \n /**\n  * Translates a value using a lookup table. \n  * @since 3.0\n  */\n+// TODO: Replace with a RegexLookup? Performance test.\n public class LookupTranslator extends CharSequenceTranslator {\n \n-    protected CharSequence[][] lookup;\n+    private HashMap\u003cCharSequence, CharSequence\u003e lookupMap;\n+    private int shortest \u003d Integer.MAX_VALUE;\n+    private int longest \u003d 0;\n \n     /**\n      * Define the lookup table to be used in translation\n@@ -33,18 +37,34 @@\n      * @param CharSequence[][] Lookup table of size [*][2]\n      */\n     public LookupTranslator(CharSequence[][] lookup) {\n-        this.lookup \u003d lookup;\n+        lookupMap \u003d new HashMap\u003cCharSequence, CharSequence\u003e();\n+        for(CharSequence[] seq : lookup) {\n+            this.lookupMap.put(seq[0], seq[1]);\n+            int sz \u003d seq[0].length();\n+            if(sz \u003c shortest) {\n+                shortest \u003d sz;\n+            }\n+            if(sz \u003e longest) {\n+                longest \u003d sz;\n+            }\n+        }\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     public int translate(CharSequence input, int index, Writer out) throws IOException {\n-        CharSequence subsequence \u003d input.subSequence(index, input.length());\n-        for(CharSequence[] seq : lookup) {\n-            if( subsequence.toString().startsWith(seq[0].toString()) ) {\n-                out.write(seq[1].toString());\n-                return seq[0].length();\n+        int max \u003d longest;\n+        if(index + longest \u003e input.length()) {\n+            max \u003d input.length() - index;\n+        }\n+        // descend so as to get a greedy algorithm\n+        for(int i\u003dmax; i \u003e\u003d shortest; i--) {\n+            CharSequence subSeq \u003d input.subSequence(index, index + i);\n+            CharSequence result \u003d lookupMap.get(subSeq);\n+            if(result !\u003d null) {\n+                out.write(result.toString());\n+                return i;\n             }\n         }\n         return 0;\n"
    },
    "Lang-6": {
        "Buggy Function": "    public final void translate(CharSequence input, Writer out) throws IOException {\n        if (out == null) {\n            throw new IllegalArgumentException(\"The Writer must not be null\");\n        }\n        if (input == null) {\n            return;\n        }\n        int pos = 0;\n        int len = input.length();\n        while (pos < len) {\n            int consumed = translate(input, pos, out);\n            if (consumed == 0) {\n                char[] c = Character.toChars(Character.codePointAt(input, pos));\n                out.write(c);\n                pos+= c.length;\n                continue;\n            }\n//          // contract with translators is that they have to understand codepoints \n//          // and they just took care of a surrogate pair\n            for (int pt = 0; pt < consumed; pt++) {\n                pos += Character.charCount(Character.codePointAt(input, pos));\n            }\n        }\n    }",
        "Inducing Changes": "diff --git a/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java b/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\nindex 0cb2ca8..4d010ea 100644\n--- a/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\n@@ -79,27 +79,20 @@\n         if (input == null) {\n             return;\n         }\n-        int sz = Character.codePointCount(input, 0, input.length());\n-        for (int i = 0; i < sz; i++) {\n-\n-            // consumed is the number of codepoints consumed\n-            int consumed = translate(input, i, out);\n-\n+        int pos = 0;\n+        int len = input.length();\n+        while (pos < len) {\n+            int consumed = translate(input, pos, out);\n             if (consumed == 0) {\n-                out.write(Character.toChars(Character.codePointAt(input, i)));\n-            } else {\n-                // contract with translators is that they have to understand codepoints \n-                // and they just took care of a surrogate pair\n-                for (int j = 0; j < consumed; j++) {\n-                    if (i < sz - 2) {\n-                        i += Character.charCount(Character.codePointAt(input, i));\n-                    } else {\n-                        // If the String ends with a high surrogate, just add the 1 and don't worry about such things\n-                        i++;\n-                    }\n-                }\n-                // for loop will increment 1 anyway, so remove 1 to account for that\n-                i--;\n+                char[] c = Character.toChars(Character.codePointAt(input, pos));\n+                out.write(c);\n+                pos+= c.length;\n+                continue;\n+            }\n+//          // contract with translators is that they have to understand codepoints \n+//          // and they just took care of a surrogate pair\n+            for (int pt = 0; pt < consumed; pt++) {\n+                pos += Character.charCount(Character.codePointAt(input, pos));\n             }\n         }\n     }\n\n"
    },
    "Lang-13": {
        "Buggy Function": "static class ClassLoaderAwareObjectInputStream extends ObjectInputStream {\n    private ClassLoader classLoader;\n\n    public ClassLoaderAwareObjectInputStream(InputStream in, ClassLoader classLoader) throws IOException {\n        super(in);\n        this.classLoader = classLoader;\n    }\n\n    @Override\n    protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n        String name = desc.getName();\n        try {\n            return Class.forName(name, false, classLoader);\n        } catch (ClassNotFoundException ex) {\n            return Class.forName(name, false, Thread.currentThread().getContextClassLoader());\n        }\n    }\n}",
        "Inducing Changes": "diff --git a/src/main/java/org/apache/commons/lang3/SerializationUtils.java b/src/main/java/org/apache/commons/lang3/SerializationUtils.java\nindex bd8238a..9cf3891 100644\n--- a/src/main/java/org/apache/commons/lang3/SerializationUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/SerializationUtils.java\n@@ -22,6 +22,7 @@\n import java.io.InputStream;\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n+import java.io.ObjectStreamClass;\n import java.io.OutputStream;\n import java.io.Serializable;\n \n@@ -73,14 +74,36 @@\n      * @throws SerializationException (runtime) if the serialization fails\n      */\n     public static <T extends Serializable> T clone(T object) {\n-        /*\n-         * when we serialize and deserialize an object,\n-         * it is reasonable to assume the deserialized object\n-         * is of the same type as the original serialized object\n-         */\n-        @SuppressWarnings(\"unchecked\")\n-        final T result = (T) deserialize(serialize(object));\n-        return result;\n+        if (object == null) {\n+            return null;\n+        }\n+        byte[] objectData = serialize(object);\n+        ByteArrayInputStream bais = new ByteArrayInputStream(objectData);\n+\n+        ClassLoaderAwareObjectInputStream in = null;\n+        try {\n+            // stream closed in the finally\n+            in = new ClassLoaderAwareObjectInputStream(bais, object.getClass().getClassLoader());\n+            /*\n+             * when we serialize and deserialize an object,\n+             * it is reasonable to assume the deserialized object\n+             * is of the same type as the original serialized object\n+             */\n+            return (T) in.readObject();\n+\n+        } catch (ClassNotFoundException ex) {\n+            throw new SerializationException(\"ClassNotFoundException while reading cloned object data\", ex);\n+        } catch (IOException ex) {\n+            throw new SerializationException(\"IOException while reading cloned object data\", ex);\n+        } finally {\n+            try {\n+                if (in != null) {\n+                    in.close();\n+                }\n+            } catch (IOException ex) {\n+                throw new SerializationException(\"IOException on closing cloned object data InputStream.\", ex);\n+            }\n+        }\n     }\n \n     // Serialize\n@@ -195,4 +218,52 @@\n         return deserialize(bais);\n     }\n \n+    /**\n+     * <p>Custom specialization of the standard JDK {@link java.io.ObjectInputStream}\n+     * that uses a custom  <code>ClassLoader</code> to resolve a class.\n+     * If the specified <code>ClassLoader</code> is not able to resolve the class,\n+     * the context classloader of the current thread will be used.\n+     * This way, the standard deserialization work also in web-application\n+     * containers and application servers, no matter in which of the\n+     * <code>ClassLoader</code> the particular class that encapsulates\n+     * serialization/deserialization lives. </p>\n+     * \n+     * <p>For more in-depth information about the problem for which this\n+     * class here is a workaround, see the JIRA issue LANG-626. </p>\n+     */\n+     static class ClassLoaderAwareObjectInputStream extends ObjectInputStream {\n+        private ClassLoader classLoader;\n+\n+        /**\n+         * Constructor.\n+         * @param in The <code>InputStream</code>.\n+         * @param classLoader classloader to use\n+         * @throws IOException if an I/O error occurs while reading stream header.\n+         * @see java.io.ObjectInputStream\n+         */\n+        public ClassLoaderAwareObjectInputStream(InputStream in, ClassLoader classLoader) throws IOException {\n+            super(in);\n+            this.classLoader = classLoader;\n+        }\n+\n+        /**\n+         * Overriden version that uses the parametrized <code>ClassLoader</code> or the <code>ClassLoader</code>\n+         * of the current <code>Thread</code> to resolve the class.\n+         * @param desc An instance of class <code>ObjectStreamClass</code>.\n+         * @return A <code>Class</code> object corresponding to <code>desc</code>.\n+         * @throws IOException Any of the usual Input/Output exceptions.\n+         * @throws ClassNotFoundException If class of a serialized object cannot be found.\n+         */\n+        @Override\n+        protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n+            String name = desc.getName();\n+            try {\n+                return Class.forName(name, false, classLoader);\n+            } catch (ClassNotFoundException ex) {\n+                return Class.forName(name, false, Thread.currentThread().getContextClassLoader());\n+            }\n+        }\n+\n+    }\n+\n }\n\n"
    },
    "Lang-46": {
        "Buggy Function": "public static String escapeJava(String str) {\n    return escapeJavaStyleString(str, false);\n}\npublic static void escapeJava(Writer out, String str) throws IOException {\n    escapeJavaStyleString(out, str, false);\n}\npublic static String escapeJavaScript(String str) {\n    return escapeJavaStyleString(str, true);\n}\npublic static void escapeJavaScript(Writer out, String str) throws IOException {\n    escapeJavaStyleString(out, str, true);\n}\nprivate static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {\n    if (str == null) {\n        return null;\n    }\n    try {\n        StringWriter writer = new StringWriter(str.length() * 2);\n        escapeJavaStyleString(writer, str, escapeSingleQuotes);\n        return writer.toString();\n    } catch (IOException ioe) {\n        // this should never ever happen while writing to a StringWriter\n        ioe.printStackTrace();\n        return null;\n    }\n}\nprivate static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (str == null) {\n        return;\n    }\n    int sz;\n    sz = str.length();\n    for (int i = 0; i < sz; i++) {\n        char ch = str.charAt(i);\n\n        // handle unicode\n        if (ch > 0xfff) {\n            out.write(\"\\\\u\" + hex(ch));\n        } else if (ch > 0xff) {\n            out.write(\"\\\\u0\" + hex(ch));\n        } else if (ch > 0x7f) {\n            out.write(\"\\\\u00\" + hex(ch));\n        } else if (ch < 32) {\n            switch (ch) {\n                case '\\b':\n                    out.write('\\\\');\n                    out.write('b');\n                    break;\n                case '\\n':\n                    out.write('\\\\');\n                    out.write('n');\n                    break;\n                case '\\t':\n                    out.write('\\\\');\n                    out.write('t');\n                    break;\n                case '\\f':\n                    out.write('\\\\');\n                    out.write('f');\n                    break;\n                case '\\r':\n                    out.write('\\\\');\n                    out.write('r');\n                    break;\n                default :\n                    if (ch > 0xf) {\n                        out.write(\"\\\\u00\" + hex(ch));\n                    } else {\n                        out.write(\"\\\\u000\" + hex(ch));\n                    }\n                    break;\n            }\n        } else {\n            switch (ch) {\n                case '\\'':\n                    if (escapeSingleQuote) {\n                      out.write('\\\\');\n                    }\n                    out.write('\\'');\n                    break;\n                case '\"':\n                    out.write('\\\\');\n                    out.write('\"');\n                    break;\n                case '\\\\':\n                    out.write('\\\\');\n                    out.write('\\\\');\n                    break;\n                case '/':\n                    out.write('\\\\');\n                    out.write('/');\n                    break;\n                default :\n                    out.write(ch);\n                    break;\n            }\n        }\n    }\n}",
        "Inducing Changes": "diff --git a/src/java/org/apache/commons/lang/StringEscapeUtils.java b/src/java/org/apache/commons/lang/StringEscapeUtils.java\nindex 4fda091..db2d7bd 100644\n--- a/src/java/org/apache/commons/lang/StringEscapeUtils.java\n+++ b/src/java/org/apache/commons/lang/StringEscapeUtils.java\n@@ -233,6 +233,10 @@\n                         out.write('\\\\');\n                         out.write('\\\\');\n                         break;\n+                    case '/':\n+                        out.write('\\\\');\n+                        out.write('/');\n+                        break;\n                     default :\n                         out.write(ch);\n                         break;\n\n"
    },
    "Lang-51": {
        "Buggy Function": "    public static boolean toBoolean(String str) {\n        // Previously used equalsIgnoreCase, which was fast for interned 'true'.\n        // Non interned 'true' matched 15 times slower.\n        // \n        // Optimisation provides same performance as before for interned 'true'.\n        // Similar performance for null, 'false', and other strings not length 2/3/4.\n        // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.\n        if (str == \"true\") {\n            return true;\n        }\n        if (str == null) {\n            return false;\n        }\n        switch (str.length()) {\n            case 2: {\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                return \n                    (ch0 == 'o' || ch0 == 'O') &&\n                    (ch1 == 'n' || ch1 == 'N');\n            }\n            case 3: {\n                char ch = str.charAt(0);\n                if (ch == 'y') {\n                    return \n                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                        (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                }\n                if (ch == 'Y') {\n                    return \n                        (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                        (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                }\n            }\n            case 4: {\n                char ch = str.charAt(0);\n                if (ch == 't') {\n                    return \n                        (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                        (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                        (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n                }\n                if (ch == 'T') {\n                    return \n                        (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n                        (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n                        (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n                }\n            }\n        }\n        return false;\n    }",
        "Inducing Changes": "diff --git a/src/java/org/apache/commons/lang/BooleanUtils.java b/src/java/org/apache/commons/lang/BooleanUtils.java\nindex 4b2a06f..14b1607 100644\n--- a/src/java/org/apache/commons/lang/BooleanUtils.java\n+++ b/src/java/org/apache/commons/lang/BooleanUtils.java\n@@ -66,7 +66,7 @@\n  * @author Matthew Hawthorne\n  * @author Gary Gregory\n  * @since 2.0\n- * @version $Id: BooleanUtils.java,v 1.16 2003/09/23 19:45:14 fredrik Exp $\n+ * @version $Id: BooleanUtils.java,v 1.17 2003/10/21 23:23:06 scolebourne Exp $\n  */\n public class BooleanUtils {\n \n@@ -502,12 +502,14 @@\n      * Otherwise, <code>null</code> is returned.</p>\n      *\n      * <pre>\n+     *   BooleanUtils.toBooleanObject(null)    = null\n      *   BooleanUtils.toBooleanObject(\"true\")  = Boolean.TRUE\n      *   BooleanUtils.toBooleanObject(\"false\") = Boolean.FALSE\n      *   BooleanUtils.toBooleanObject(\"on\")    = Boolean.TRUE\n      *   BooleanUtils.toBooleanObject(\"ON\")    = Boolean.TRUE\n      *   BooleanUtils.toBooleanObject(\"off\")   = Boolean.FALSE\n      *   BooleanUtils.toBooleanObject(\"oFf\")   = Boolean.FALSE\n+     *   BooleanUtils.toBooleanObject(\"blue\")  = null\n      * </pre>\n      *\n      * @param str  the String to check\n@@ -574,34 +576,94 @@\n     // String to boolean methods\n     //-----------------------------------------------------------------------\n     /**\n-     * <p>Converts a String to a boolean.</p>\n+     * <p>Converts a String to a boolean (optimised for performance).</p>\n      * \n      * <p><code>'true'</code>, <code>'on'</code> or <code>'yes'</code>\n      * (case insensitive) will return <code>true</code>. Otherwise,\n      * <code>false</code> is returned.</p>\n+     * \n+     * <p>This method performs 4 times faster (JDK1.4) than\n+     * <code>Boolean.valueOf(String)</code>. However, this method accepts\n+     * 'on' and 'yes' as true values.\n      *\n      * <pre>\n+     *   BooleanUtils.toBoolean(null)    = false\n      *   BooleanUtils.toBoolean(\"true\")  = true\n+     *   BooleanUtils.toBoolean(\"TRUE\")  = true\n+     *   BooleanUtils.toBoolean(\"tRUe\")  = true\n      *   BooleanUtils.toBoolean(\"on\")    = true\n      *   BooleanUtils.toBoolean(\"yes\")   = true\n      *   BooleanUtils.toBoolean(\"false\") = false\n+     *   BooleanUtils.toBoolean(\"x gti\") = false\n      * </pre>\n      *\n      * @param str  the String to check\n      * @return the boolean value of the string, <code>false</code> if no match\n      */\n     public static boolean toBoolean(String str) {\n-        if (\"true\".equalsIgnoreCase(str)) {\n-            return true;\n-        } else if (\"on\".equalsIgnoreCase(str)) {\n-            return true;\n-        } else if (\"yes\".equalsIgnoreCase(str)) {\n+        // Previously used equalsIgnoreCase, which was fast for interned 'true'.\n+        // Non interned 'true' matched 15 times slower.\n+        // \n+        // Optimisation provides same performance as before for interned 'true'.\n+        // Similar performance for null, 'false', and other strings not length 2/3/4.\n+        // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.\n+        if (str == \"true\") {\n             return true;\n         }\n-        // no match\n+        if (str == null) {\n+            return false;\n+        }\n+        switch (str.length()) {\n+            case 2: {\n+                char ch0 = str.charAt(0);\n+                char ch1 = str.charAt(1);\n+                return \n+                    (ch0 == 'o' || ch0 == 'O') &&\n+                    (ch1 == 'n' || ch1 == 'N');\n+            }\n+            case 3: {\n+                char ch = str.charAt(0);\n+                if (ch == 'y') {\n+                    return \n+                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n+                        (str.charAt(2) == 's' || str.charAt(2) == 'S');\n+                }\n+                if (ch == 'Y') {\n+                    return \n+                        (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n+                        (str.charAt(2) == 'S' || str.charAt(2) == 's');\n+                }\n+            }\n+            case 4: {\n+                char ch = str.charAt(0);\n+                if (ch == 't') {\n+                    return \n+                        (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n+                        (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n+                        (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n+                }\n+                if (ch == 'T') {\n+                    return \n+                        (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n+                        (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n+                        (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n+                }\n+            }\n+        }\n         return false;\n     }\n-\n+    \n+//    public static void main(String[] args) {\n+//        long start = System.currentTimeMillis();\n+//        boolean flag = true;\n+//        int count = 0;\n+//        for (int i = 0; i < 100000000; i++) {\n+//            flag = toBoolean(\"YES\");\n+//        }\n+//        long end = System.currentTimeMillis();\n+//        System.out.println((end - start) + \" \" + flag + \" \" + count);\n+//    }\n+    \n     /**\n      * <p>Converts a String to a Boolean throwing an exception if no match found.</p>\n      * \n\n"
    },
    "Lang-53": {
        "Buggy Function": "    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        if (field == Calendar.MILLISECOND) {\n            return;\n        }\n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods.\n\n        Date date = val.getTime();\n        long time = date.getTime();\n        boolean done = false;\n\n        // truncate milliseconds\n        int millisecs = val.get(Calendar.MILLISECOND);\n        if (!round || millisecs < 500) {\n            time = time - millisecs;\n        if (field == Calendar.SECOND) {\n            done = true;\n            }\n        }\n\n        // truncate seconds\n        int seconds = val.get(Calendar.SECOND);\n        if (!done && (!round || seconds < 30)) {\n            time = time - (seconds * 1000L);\n        if (field == Calendar.MINUTE) {\n            done = true;\n            }\n        }\n\n        // truncate minutes\n        int minutes = val.get(Calendar.MINUTE);\n        if (!done && (!round || minutes < 30)) {\n            time = time - (minutes * 60000L);\n        }\n\n        // reset time\n        if (date.getTime() != time) {\n            date.setTime(time);\n            val.setTime(date);\n        }\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp = false;\n        for (int i = 0; i < fields.length; i++) {\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    //This is our field... we stop looping\n                    if (round && roundUp) {\n                        if (field == DateUtils.SEMI_MONTH) {\n                            //This is a special case that's hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset = 0;\n            boolean offsetSet = false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] == Calendar.DATE) {\n                        //If we're going to drop the DATE field's value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset = val.get(Calendar.DATE) - 1;\n                        //If we're above 15 days adjustment, that means we're in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset >= 15) {\n                            offset -= 15;\n                        }\n                        //Record whether we're in the top or bottom half of that range\n                        roundUp = offset > 7;\n                        offsetSet = true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                        //If we're going to drop the HOUR field's value,\n                        //  we want to do this our own way.\n                        offset = val.get(Calendar.HOUR_OF_DAY);\n                        if (offset >= 12) {\n                            offset -= 12;\n                        }\n                        roundUp = offset > 6;\n                        offsetSet = true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min = val.getActualMinimum(fields[i][0]);\n                int max = val.getActualMaximum(fields[i][0]);\n                //Calculate the offset from the minimum allowed value\n                offset = val.get(fields[i][0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp = offset > ((max - min) / 2);\n            }\n            //We need to remove this field\n            if (offset != 0) {\n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }",
        "Inducing Changes": "diff --git a/src/java/org/apache/commons/lang/time/DateUtils.java b/src/java/org/apache/commons/lang/time/DateUtils.java\nindex f042237..79c13f0 100644\n--- a/src/java/org/apache/commons/lang/time/DateUtils.java\n+++ b/src/java/org/apache/commons/lang/time/DateUtils.java\n@@ -621,6 +621,51 @@\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n         \n+        if (field == Calendar.MILLISECOND) {\n+            return;\n+        }\n+\n+        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n+        // see http://issues.apache.org/jira/browse/LANG-59\n+        //\n+        // Manually truncate milliseconds, seconds and minutes, rather than using\n+        // Calendar methods.\n+\n+        Date date = val.getTime();\n+        long time = date.getTime();\n+        boolean done = false;\n+\n+        // truncate milliseconds\n+        int millisecs = val.get(Calendar.MILLISECOND);\n+        if (!round || millisecs < 500) {\n+            time = time - millisecs;\n+            if (field == Calendar.SECOND) {\n+                done = true;\n+            }\n+        }\n+\n+        // truncate seconds\n+        int seconds = val.get(Calendar.SECOND);\n+        if (!done && (!round || seconds < 30)) {\n+            time = time - (seconds * 1000L);\n+            if (field == Calendar.MINUTE) {\n+                done = true;\n+            }\n+        }\n+\n+        // truncate minutes\n+        int minutes = val.get(Calendar.MINUTE);\n+        if (!done && (!round || minutes < 30)) {\n+            time = time - (minutes * 60000L);\n+        }\n+\n+        // reset time\n+        if (date.getTime() != time) {\n+            date.setTime(time);\n+            val.setTime(date);\n+        }\n+        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n+\n         boolean roundUp = false;\n         for (int i = 0; i < fields.length; i++) {\n             for (int j = 0; j < fields[i].length; j++) {\n@@ -689,7 +734,9 @@\n                 roundUp = offset > ((max - min) / 2);\n             }\n             //We need to remove this field\n-            val.set(fields[i][0], val.get(fields[i][0]) - offset);\n+            if (offset != 0) {\n+                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n+            }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n\n"
    },
    "Math-2": {
        "Buggy Function": "    public double getNumericalMean() {\n        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n    }",
        "Inducing Changes":  "diff --git a/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java b/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\nindex 793f72b..7f87f36 100644\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n@@ -20,10 +20,11 @@\n \n import org.apache.commons.math.exception.MathInternalError;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n-import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.random.RandomDataImpl;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Base class for integer-valued discrete distributions.  Default\n@@ -49,85 +50,105 @@\n      * {@inheritDoc}\n      *\n      * The default implementation uses the identity\n-     * \u003cp\u003e{@code P(x0 \u003c\u003d X \u003c\u003d x1) \u003d P(X \u003c\u003d x1) - P(X \u003c\u003d x0 - 1)}\u003c/p\u003e\n+     * \u003cp\u003e{@code P(x0 \u003c X \u003c\u003d x1) \u003d P(X \u003c\u003d x1) - P(X \u003c\u003d x0)}\u003c/p\u003e\n      */\n-    public double cumulativeProbability(int x0, int x1) {\n+    public double cumulativeProbability(int x0, int x1) throws NumberIsTooLargeException {\n         if (x1 \u003c x0) {\n-            throw new NumberIsTooSmallException(\n-                    LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT,\n-                    x1, x0, true);\n+            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT,\n+                    x0, x1, true);\n         }\n-        return cumulativeProbability(x1) - cumulativeProbability(x0 - 1);\n+        return cumulativeProbability(x1) - cumulativeProbability(x0);\n     }\n \n-    /** {@inheritDoc} */\n-    public int inverseCumulativeProbability(final double p) {\n-        if (p \u003c 0 || p \u003e 1) {\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The default implementation returns\n+     * \u003cul\u003e\n+     * \u003cli\u003e{@link #getSupportLowerBound()} for {@code p \u003d 0},\u003c/li\u003e\n+     * \u003cli\u003e{@link #getSupportUpperBound()} for {@code p \u003d 1}, and\u003c/li\u003e\n+     * \u003cli\u003e{@link #solveInverseCumulativeProbability(double, int, int)} for\n+     *     {@code 0 \u003c p \u003c 1}.\u003c/li\u003e\n+     * \u003c/ul\u003e\n+     */\n+    public int inverseCumulativeProbability(final double p) throws OutOfRangeException {\n+        if (p \u003c 0.0 || p \u003e 1.0) {\n             throw new OutOfRangeException(p, 0, 1);\n         }\n \n-        // by default, do simple bisection.\n-        // subclasses can override if there is a better method.\n-        int x0 \u003d getDomainLowerBound(p);\n-        int x1 \u003d getDomainUpperBound(p);\n-        double pm;\n-        while (x0 \u003c x1) {\n-            int xm \u003d x0 + (x1 - x0) / 2;\n-            pm \u003d checkedCumulativeProbability(xm);\n-            if (pm \u003e p) {\n-                // update x1\n-                if (xm \u003d\u003d x1) {\n-                    // this can happen with integer division\n-                    // simply decrement x1\n-                    --x1;\n-                } else {\n-                    // update x1 normally\n-                    x1 \u003d xm;\n-                }\n-            } else {\n-                // update x0\n-                if (xm \u003d\u003d x0) {\n-                    // this can happen with integer division\n-                    // simply increment x0\n-                    ++x0;\n-                } else {\n-                    // update x0 normally\n-                    x0 \u003d xm;\n-                }\n+        int lower \u003d getSupportLowerBound();\n+        if (p \u003d\u003d 0.0) {\n+            return lower;\n+        }\n+        if (lower \u003d\u003d Integer.MIN_VALUE) {\n+            if (checkedCumulativeProbability(lower) \u003e\u003d p) {\n+                return lower;\n+            }\n+        } else {\n+            lower -\u003d 1; // this ensures cumulativeProbability(lower) \u003c p, which\n+                        // is important for the solving step\n+        }\n+\n+        int upper \u003d getSupportUpperBound();\n+        if (p \u003d\u003d 1.0) {\n+            return upper;\n+        }\n+\n+        // use the one-sided Chebyshev inequality to narrow the bracket\n+        // cf. AbstractRealDistribution.inverseCumulativeProbability(double)\n+        final double mu \u003d getNumericalMean();\n+        final double sigma \u003d FastMath.sqrt(getNumericalVariance());\n+        final boolean chebyshevApplies \u003d !(Double.isInfinite(mu) || Double.isNaN(mu) ||\n+                Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma \u003d\u003d 0.0);\n+        if (chebyshevApplies) {\n+            double k \u003d FastMath.sqrt((1.0 - p) / p);\n+            double tmp \u003d mu - k * sigma;\n+            if (tmp \u003e lower) {\n+                lower \u003d ((int) Math.ceil(tmp)) - 1;\n+            }\n+            k \u003d 1.0 / k;\n+            tmp \u003d mu + k * sigma;\n+            if (tmp \u003c upper) {\n+                upper \u003d ((int) Math.ceil(tmp)) - 1;\n             }\n         }\n \n-        // insure x0 is the correct critical point\n-        pm \u003d checkedCumulativeProbability(x0);\n-        while (pm \u003e p) {\n-            --x0;\n-            pm \u003d checkedCumulativeProbability(x0);\n-        }\n-\n-        return x0;\n+        return solveInverseCumulativeProbability(p, lower, upper);\n     }\n \n     /**\n-     * Access the domain value lower bound, based on {@code p}, used to\n-     * bracket a CDF root. This method is used by\n-     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * This is a utility function used by {@link\n+     * #inverseCumulativeProbability(double)}. It assumes {@code 0 \u003c p \u003c 1} and\n+     * that the inverse cumulative probability lies in the bracket {@code\n+     * (lower, upper]}. The implementation does simple bisection to find the\n+     * smallest {@code p}-quantile \u003ccode\u003einf{x in Z | P(X\u003c\u003dx) \u003e\u003d p}\u003c/code\u003e.\n      *\n-     * @param p the desired probability for the critical value ({@code 0 \u003c p \u003c 1})\n-     * @return a domain value lower bound, i.e. a value {@code x} such that\n-     * {@code P(X \u003c\u003d x) \u003c p}\n+     * @param p the cumulative probability\n+     * @param lower a value satisfying {@code cumulativeProbability(lower) \u003c p}\n+     * @param upper a value satisfying {@code p \u003c\u003d cumulativeProbability(upper)}\n+     * @return the smallest {@code p}-quantile of this distribution\n      */\n-    protected abstract int getDomainLowerBound(double p);\n+    protected int solveInverseCumulativeProbability(final double p, int lower, int upper) {\n+        while (lower + 1 \u003c upper) {\n+            int xm \u003d (lower + upper) / 2;\n+            if (xm \u003c lower || xm \u003e upper) {\n+                /*\n+                 * Overflow.\n+                 * There will never be an overflow in both calculation methods\n+                 * for xm at the same time\n+                 */\n+                xm \u003d lower + (upper - lower) / 2;\n+            }\n \n-    /**\n-     * Access the domain value upper bound, based on {@code p}, used to\n-     * bracket a CDF root. This method is used by\n-     * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     *\n-     * @param p the desired probability for the critical value ({@code 0 \u003c p \u003c 1})\n-     * @return a domain value upper bound, i.e. a value {@code x} such that\n-     * {@code P(X \u003c\u003d x) \u003e\u003d p}\n-     */\n-    protected abstract int getDomainUpperBound(double p);\n+            double pm \u003d checkedCumulativeProbability(xm);\n+            if (pm \u003e\u003d p) {\n+                upper \u003d xm;\n+            } else {\n+                lower \u003d xm;\n+            }\n+        }\n+        return upper;\n+    }\n \n     /** {@inheritDoc} */\n     public void reseedRandomGenerator(long seed) {\ndiff --git a/src/main/java/org/apache/commons/math/distribution/BinomialDistribution.java b/src/main/java/org/apache/commons/math/distribution/BinomialDistribution.java\nindex 3d6cc39..906592b 100644\n--- a/src/main/java/org/apache/commons/math/distribution/BinomialDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/BinomialDistribution.java\n@@ -98,7 +98,7 @@\n         } else if (x \u003e\u003d numberOfTrials) {\n             ret \u003d 1.0;\n         } else {\n-            ret \u003d 1.0 - Beta.regularizedBeta(getProbabilityOfSuccess(),\n+            ret \u003d 1.0 - Beta.regularizedBeta(probabilityOfSuccess,\n                     x + 1.0, numberOfTrials - x);\n         }\n         return ret;\n@@ -107,43 +107,11 @@\n     /**\n      * {@inheritDoc}\n      *\n-     * This implementation return -1 when {@code p \u003d\u003d 0} and\n-     * {@code Integer.MAX_VALUE} when {@code p \u003d\u003d 1}.\n-     */\n-    @Override\n-    public int inverseCumulativeProbability(final double p) {\n-        // handle extreme values explicitly\n-        if (p \u003d\u003d 0) {\n-            return -1;\n-        }\n-        if (p \u003d\u003d 1) {\n-            return Integer.MAX_VALUE;\n-        }\n-\n-        // use default bisection impl\n-        return super.inverseCumulativeProbability(p);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected int getDomainLowerBound(double p) {\n-        return -1;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected int getDomainUpperBound(double p) {\n-        return numberOfTrials;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n      * For {@code n} trials and probability parameter {@code p}, the mean is\n      * {@code n * p}.\n      */\n     public double getNumericalMean() {\n-        return getNumberOfTrials() * getProbabilityOfSuccess();\n+        return numberOfTrials * probabilityOfSuccess;\n     }\n \n     /**\n@@ -153,31 +121,32 @@\n      * {@code n * p * (1 - p)}.\n      */\n     public double getNumericalVariance() {\n-        final double p \u003d getProbabilityOfSuccess();\n-        return getNumberOfTrials() * p * (1 - p);\n+        final double p \u003d probabilityOfSuccess;\n+        return numberOfTrials * p * (1 - p);\n     }\n \n     /**\n      * {@inheritDoc}\n      *\n-     * The lower bound of the support is always 0 no matter the number of trials\n-     * and probability parameter.\n+     * The lower bound of the support is always 0 except for the probability\n+     * parameter {@code p \u003d 1}.\n      *\n-     * @return lower bound of the support (always 0)\n+     * @return lower bound of the support (0 or the number of trials)\n      */\n     public int getSupportLowerBound() {\n-        return 0;\n+        return probabilityOfSuccess \u003c 1.0 ? 0 : numberOfTrials;\n     }\n \n     /**\n      * {@inheritDoc}\n      *\n-     * The upper bound of the support is the number of trials.\n+     * The upper bound of the support is the number of trials except for the\n+     * probability parameter {@code p \u003d 0}.\n      *\n-     * @return upper bound of the support (equal to number of trials)\n+     * @return upper bound of the support (number of trials or 0)\n      */\n     public int getSupportUpperBound() {\n-        return getNumberOfTrials();\n+        return probabilityOfSuccess \u003e 0.0 ? numberOfTrials : 0;\n     }\n \n     /**\ndiff --git a/src/main/java/org/apache/commons/math/distribution/HypergeometricDistribution.java b/src/main/java/org/apache/commons/math/distribution/HypergeometricDistribution.java\nindex 99cb892..0217c96 100644\n--- a/src/main/java/org/apache/commons/math/distribution/HypergeometricDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/HypergeometricDistribution.java\n@@ -121,18 +121,6 @@\n         return new int[] { getLowerDomain(n, m, k), getUpperDomain(m, k) };\n     }\n \n-    /** {@inheritDoc} */\n-    @Override\n-    protected int getDomainLowerBound(double p) {\n-        return getLowerDomain(populationSize, numberOfSuccesses, sampleSize);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected int getDomainUpperBound(double p) {\n-        return getUpperDomain(sampleSize, numberOfSuccesses);\n-    }\n-\n     /**\n      * Return the lowest domain value for the given hypergeometric distribution\n      * parameters.\ndiff --git a/src/main/java/org/apache/commons/math/distribution/IntegerDistribution.java b/src/main/java/org/apache/commons/math/distribution/IntegerDistribution.java\nindex b0d9c66..c18d381 100644\n--- a/src/main/java/org/apache/commons/math/distribution/IntegerDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/IntegerDistribution.java\n@@ -16,6 +16,9 @@\n  */\n package org.apache.commons.math.distribution;\n \n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+\n /**\n  * Interface for distributions on the integers.\n  *\n@@ -25,61 +28,56 @@\n     /**\n      * For a random variable {@code X} whose values are distributed according\n      * to this distribution, this method returns {@code P(X \u003d x)}. In other\n-     * words, this method represents the probability mass function for the\n-     * distribution.\n+     * words, this method represents the probability mass function (PMF)\n+     * for the distribution.\n      *\n-     * @param x the point at which the probability density function is evaluated.\n-     * @return the value of the probability density function at {@code x}\n+     * @param x the point at which the PMF is evaluated\n+     * @return the value of the probability mass function at {@code x}\n      */\n     double probability(int x);\n \n     /**\n      * For a random variable {@code X} whose values are distributed according\n      * to this distribution, this method returns {@code P(X \u003c\u003d x)}.  In other\n-     * words, this method represents the probability distribution function, or\n-     * PDF for the distribution.\n+     * words, this method represents the (cumulative) distribution function\n+     * (CDF) for this distribution.\n      *\n-     * @param x the point at which the PDF is evaluated\n-     * @return PDF for this distribution.\n+     * @param x the point at which the CDF is evaluated\n+     * @return the probability that a random variable with this\n+     * distribution takes a value less than or equal to {@code x}\n      */\n     double cumulativeProbability(int x);\n \n     /**\n      * For a random variable {@code X} whose values are distributed according\n-     * to this distribution, this method returns {@code P(x0 \u003c\u003d X \u003c\u003d x1)}.\n+     * to this distribution, this method returns {@code P(x0 \u003c X \u003c\u003d x1)}.\n      *\n-     * @param x0 the inclusive lower bound\n+     * @param x0 the exclusive lower bound\n      * @param x1 the inclusive upper bound\n-     * @return the cumulative probability\n-     * @throws IllegalArgumentException if {@code x0 \u003e x1}\n+     * @return the probability that a random variable with this distribution\n+     * will take a value between {@code x0} and {@code x1},\n+     * excluding the lower and including the upper endpoint\n+     * @throws NumberIsTooLargeException if {@code x0 \u003e x1}\n      */\n-    double cumulativeProbability(int x0, int x1);\n+    double cumulativeProbability(int x0, int x1) throws NumberIsTooLargeException;\n \n     /**\n-     * For this distribution, {@code X}, this method returns the largest\n-     * {@code x} such that {@code P(X \u003c\u003d x) \u003c\u003d p}.\n-     * \u003cbr/\u003e\n-     * Note that this definition implies:\n+     * Computes the quantile function of this distribution.\n+     * For a random variable {@code X} distributed according to this distribution,\n+     * the returned value is\n      * \u003cul\u003e\n-     *  \u003cli\u003e If there is a minimum value, {@code m}, with positive\n-     *   probability under (the density of) {@code X}, then {@code m - 1} is\n-     *   returned by {@code inverseCumulativeProbability(0).}  If there is\n-     *   no such value {@code m},  {@code Integer.MIN_VALUE} is returned.\n-     *  \u003c/li\u003e\n-     *  \u003cli\u003e If there is a maximum value, {@code M}, such that\n-     *   {@code P(X \u003c\u003d M) \u003d 1}, then {@code M} is returned by\n-     *   {@code inverseCumulativeProbability(1)}.\n-     *   If there is no such value, {@code M}, {@code Integer.MAX_VALUE} is\n-     *   returned.\n-     *  \u003c/li\u003e\n+     * \u003cli\u003e\u003ccode\u003einf{x in Z | P(X\u003c\u003dx) \u003e\u003d p}\u003c/code\u003e for {@code 0 \u003c p \u003c\u003d 1},\u003c/li\u003e\n+     * \u003cli\u003e\u003ccode\u003einf{x in Z | P(X\u003c\u003dx) \u003e 0}\u003c/code\u003e for {@code p \u003d 0}.\u003c/li\u003e\n      * \u003c/ul\u003e\n+     * If the result exceeds the range of the data type {@code int},\n+     * then {@code Integer.MIN_VALUE} or {@code Integer.MAX_VALUE} is returned.\n      *\n      * @param p the cumulative probability\n-     * @return the largest {@code x} such that {@code P(X \u003c x) \u003c\u003d p}\n-     * @throws IllegalArgumentException if {@code p} is not between 0 and 1\n-     * (inclusive)\n+     * @return the smallest {@code p}-quantile of this distribution\n+     * (largest 0-quantile for {@code p \u003d 0})\n+     * @throws OutOfRangeException if {@code p \u003c 0} or {@code p \u003e 1}\n      */\n-    int inverseCumulativeProbability(double p);\n+    int inverseCumulativeProbability(double p) throws OutOfRangeException;\n \n     /**\n      * Use this method to get the numerical value of the mean of this\n@@ -99,7 +97,10 @@\n     double getNumericalVariance();\n \n     /**\n-     * Access the lower bound of the support.\n+     * Access the lower bound of the support. This method must return the same\n+     * value as {@code inverseCumulativeProbability(0)}. In other words, this\n+     * method must return\n+     * \u003cp\u003e\u003ccode\u003einf {x in Z | P(X \u003c\u003d x) \u003e 0}\u003c/code\u003e.\u003c/p\u003e\n      *\n      * @return lower bound of the support ({@code Integer.MIN_VALUE}\n      * for negative infinity)\n@@ -107,7 +108,10 @@\n     int getSupportLowerBound();\n \n     /**\n-     * Access the upper bound of the support.\n+     * Access the upper bound of the support. This method must return the same\n+     * value as {@code inverseCumulativeProbability(1)}. In other words, this\n+     * method must return\n+     * \u003cp\u003e\u003ccode\u003einf {x in R | P(X \u003c\u003d x) \u003d 1}\u003c/code\u003e.\u003c/p\u003e\n      *\n      * @return upper bound of the support ({@code Integer.MAX_VALUE}\n      * for positive infinity)\ndiff --git a/src/main/java/org/apache/commons/math/distribution/PascalDistribution.java b/src/main/java/org/apache/commons/math/distribution/PascalDistribution.java\nindex 3170b57..57d79f7 100644\n--- a/src/main/java/org/apache/commons/math/distribution/PascalDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PascalDistribution.java\n@@ -16,8 +16,8 @@\n  */\n package org.apache.commons.math.distribution;\n \n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.OutOfRangeException;\n-import org.apache.commons.math.exception.NotPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.special.Beta;\n import org.apache.commons.math.util.ArithmeticUtils;\n@@ -68,19 +68,19 @@\n     private final double probabilityOfSuccess;\n \n     /**\n-     * Create a Pascal distribution with the given number of trials and\n+     * Create a Pascal distribution with the given number of successes and\n      * probability of success.\n      *\n      * @param r Number of successes.\n      * @param p Probability of success.\n-     * @throws NotPositiveException if the number of successes is not positive\n+     * @throws NotStrictlyPositiveException if the number of successes is not positive\n      * @throws OutOfRangeException if the probability of success is not in the\n      * range [0, 1]\n      */\n     public PascalDistribution(int r, double p)\n-        throws NotPositiveException, OutOfRangeException {\n-        if (r \u003c 0) {\n-            throw new NotPositiveException(LocalizedFormats.NUMBER_OF_SUCCESSES,\n+        throws NotStrictlyPositiveException, OutOfRangeException {\n+        if (r \u003c\u003d 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SUCCESSES,\n                                            r);\n         }\n         if (p \u003c 0 || p \u003e 1) {\n@@ -138,41 +138,6 @@\n     /**\n      * {@inheritDoc}\n      *\n-     * Returns {@code -1} when {@code p \u003d\u003d 0} and\n-     * {@code Integer.MAX_VALUE} when {@code p \u003d\u003d 1}.\n-     */\n-    @Override\n-    public int inverseCumulativeProbability(final double p) {\n-        int ret;\n-\n-        // handle extreme values explicitly\n-        if (p \u003d\u003d 0) {\n-            ret \u003d -1;\n-        } else if (p \u003d\u003d 1) {\n-            ret \u003d Integer.MAX_VALUE;\n-        } else {\n-            ret \u003d super.inverseCumulativeProbability(p);\n-        }\n-\n-        return ret;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected int getDomainLowerBound(double p) {\n-        return -1;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected int getDomainUpperBound(double p) {\n-        // use MAX - 1 because MAX causes loop\n-        return Integer.MAX_VALUE - 1;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n      * For number of successes {@code r} and probability of success {@code p},\n      * the mean is {@code r * (1 - p) / p}.\n      */\n@@ -209,7 +174,7 @@\n      * {@inheritDoc}\n      *\n      * The upper bound of the support is always positive infinity no matter the\n-     * parameters. Positive infinity is symbolised by {@code Integer.MAX_VALUE}.\n+     * parameters. Positive infinity is symbolized by {@code Integer.MAX_VALUE}.\n      *\n      * @return upper bound of the support (always {@code Integer.MAX_VALUE}\n      * for positive infinity)\ndiff --git a/src/main/java/org/apache/commons/math/distribution/PoissonDistribution.java b/src/main/java/org/apache/commons/math/distribution/PoissonDistribution.java\nindex 7353448..0fafe65 100644\n--- a/src/main/java/org/apache/commons/math/distribution/PoissonDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PoissonDistribution.java\n@@ -174,18 +174,6 @@\n         return normal.cumulativeProbability(x + 0.5);\n     }\n \n-    /** {@inheritDoc} */\n-    @Override\n-    protected int getDomainLowerBound(double p) {\n-        return 0;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected int getDomainUpperBound(double p) {\n-        return Integer.MAX_VALUE;\n-    }\n-\n     /**\n      * {@inheritDoc}\n      *\ndiff --git a/src/main/java/org/apache/commons/math/distribution/ZipfDistribution.java b/src/main/java/org/apache/commons/math/distribution/ZipfDistribution.java\nindex ea12588..dfa3441 100644\n--- a/src/main/java/org/apache/commons/math/distribution/ZipfDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ZipfDistribution.java\n@@ -111,18 +111,6 @@\n         return generalizedHarmonic(x, exponent) / generalizedHarmonic(numberOfElements, exponent);\n     }\n \n-    /** {@inheritDoc} */\n-    @Override\n-    protected int getDomainLowerBound(final double p) {\n-        return 0;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected int getDomainUpperBound(final double p) {\n-        return numberOfElements;\n-    }\n-\n     /**\n      * {@inheritDoc}\n      *\n@@ -176,7 +164,7 @@\n     }\n \n     /**\n-     * used by {@link #getNumericalVariance()}\n+     * Used by {@link #getNumericalVariance()}.\n      *\n      * @return the variance of this distribution\n      */\ndiff --git a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\nindex 908c47d..237e923 100644\n--- a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n@@ -1076,13 +1076,7 @@\n      * @since 2.2\n      */\n     public int nextInversionDeviate(IntegerDistribution distribution) {\n-        final double target \u003d nextUniform(0, 1);\n-        final int glb \u003d distribution.inverseCumulativeProbability(target);\n-        if (distribution.cumulativeProbability(glb) \u003d\u003d 1.0d) { // No mass above\n-            return glb;\n-        } else {\n-            return glb + 1;\n-        }\n+        return distribution.inverseCumulativeProbability(nextUniform(0, 1));\n     }\n \n     // ------------------------Private methods----------------------------------\n"
    },
    "Math-10": {
        "Buggy Function": "    public void atan2(final double[] y, final int yOffset,\n                      final double[] x, final int xOffset,\n                      final double[] result, final int resultOffset) {\n\n        // compute r = sqrt(x^2+y^2)\n        double[] tmp1 = new double[getSize()];\n        multiply(x, xOffset, x, xOffset, tmp1, 0);      // x^2\n        double[] tmp2 = new double[getSize()];\n        multiply(y, yOffset, y, yOffset, tmp2, 0);      // y^2\n        add(tmp1, 0, tmp2, 0, tmp2, 0);                 // x^2 + y^2\n        rootN(tmp2, 0, 2, tmp1, 0);                     // r = sqrt(x^2 + y^2)\n\n        if (x[xOffset] >= 0) {\n\n            // compute atan2(y, x) = 2 atan(y / (r + x))\n            add(tmp1, 0, x, xOffset, tmp2, 0);          // r + x\n            divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r + x)\n            atan(tmp1, 0, tmp2, 0);                     // atan(y / (r + x))\n            for (int i = 0; i < tmp2.length; ++i) {\n                result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x))\n            }\n\n        } else {\n\n            // compute atan2(y, x) = +/- pi - 2 atan(y / (r - x))\n            subtract(tmp1, 0, x, xOffset, tmp2, 0);     // r - x\n            divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r - x)\n            atan(tmp1, 0, tmp2, 0);                     // atan(y / (r - x))\n            result[resultOffset] =\n                    ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0]; // +/-pi - 2 * atan(y / (r - x))\n            for (int i = 1; i < tmp2.length; ++i) {\n                result[resultOffset + i] = -2 * tmp2[i]; // +/-pi - 2 * atan(y / (r - x))\n            }\n\n        }\n\n        // fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly\n\n    }",
        "Inducing Changes": "diff --git a/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java b/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java\nindex 110036a..91a5377 100644\n--- a/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java\n@@ -1286,14 +1286,36 @@\n                       final double[] x, final int xOffset,\n                       final double[] result, final int resultOffset) {\n \n-        final double y0 = y[yOffset];\n-        final double x0 = x[xOffset];\n-        result[resultOffset] = FastMath.atan2(y0, x0);\n-        if (order > 0) {\n-            for (int i = 1; i <= order; ++i) {\n-                // TODO compute higher order derivatives\n-                result[resultOffset + i] = Double.NaN;\n+        // compute r = sqrt(x^2+y^2)\n+        double[] tmp1 = new double[getSize()];\n+        multiply(x, xOffset, x, xOffset, tmp1, 0);      // x^2\n+        double[] tmp2 = new double[getSize()];\n+        multiply(y, yOffset, y, yOffset, tmp2, 0);      // y^2\n+        add(tmp1, 0, tmp2, 0, tmp2, 0);                 // x^2 + y^2\n+        rootN(tmp2, 0, 2, tmp1, 0);                     // r = sqrt(x^2 + y^2)\n+\n+        if (x[xOffset] >= 0) {\n+\n+            // compute atan2(y, x) = 2 atan(y / (r + x))\n+            add(tmp1, 0, x, xOffset, tmp2, 0);          // r + x\n+            divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r + x)\n+            atan(tmp1, 0, tmp2, 0);                     // atan(y / (r + x))\n+            for (int i = 0; i < tmp2.length; ++i) {\n+                result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x))\n             }\n+\n+        } else {\n+\n+            // compute atan2(y, x) = +/- pi - 2 atan(y / (r - x))\n+            subtract(tmp1, 0, x, xOffset, tmp2, 0);     // r - x\n+            divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r - x)\n+            atan(tmp1, 0, tmp2, 0);                     // atan(y / (r - x))\n+            result[resultOffset] =\n+                    ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0]; // +/-pi - 2 * atan(y / (r - x))\n+            for (int i = 1; i < tmp2.length; ++i) {\n+                result[resultOffset + i] = -2 * tmp2[i]; // +/-pi - 2 * atan(y / (r - x))\n+            }\n+\n         }\n \n     }\n\n"
    },
    "Math-14": {
        "Buggy Function": "//buggy function from src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.java\npublic Weight(double[] weight) {\n    final int dim = weight.length;\n    weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(dim, dim);\n    for (int i = 0; i < dim; i++) {\n        weightMatrix.setEntry(i, i, weight[i]);\n    }\n}\n//buggy function from src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java\nprivate RealMatrix squareRoot(RealMatrix m) {\n    final EigenDecomposition dec = new EigenDecomposition(m);\n    return dec.getSquareRoot();\n}",
        "Inducing Changes": "diff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java\nindex 7b2c6b5..b7bb6f5 100644\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java\n@@ -19,18 +19,16 @@\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.TooManyEvaluationsException;\n import org.apache.commons.math3.linear.ArrayRealVector;\n+import org.apache.commons.math3.linear.RealMatrix;\n import org.apache.commons.math3.linear.DecompositionSolver;\n-import org.apache.commons.math3.linear.EigenDecomposition;\n import org.apache.commons.math3.linear.MatrixUtils;\n import org.apache.commons.math3.linear.QRDecomposition;\n-import org.apache.commons.math3.linear.RealMatrix;\n-import org.apache.commons.math3.optim.ConvergenceChecker;\n+import org.apache.commons.math3.linear.EigenDecomposition;\n import org.apache.commons.math3.optim.OptimizationData;\n+import org.apache.commons.math3.optim.ConvergenceChecker;\n import org.apache.commons.math3.optim.PointVectorValuePair;\n-import org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer;\n-import org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer;\n-import org.apache.commons.math3.optim.nonlinear.vector.NonCorrelatedWeight;\n import org.apache.commons.math3.optim.nonlinear.vector.Weight;\n+import org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer;\n import org.apache.commons.math3.util.FastMath;\n \n /**\n@@ -42,13 +40,8 @@\n  */\n public abstract class AbstractLeastSquaresOptimizer\n     extends JacobianMultivariateVectorOptimizer {\n-    /** Square-root of the weight matrix.\n-     * @deprecated as of 3.1.1, replaced by {@link #weight}\n-     */\n-    @Deprecated\n+    /** Square-root of the weight matrix. */\n     private RealMatrix weightMatrixSqrt;\n-    /** Square-root of the weight vector. */\n-    private double[] weightSquareRoot;\n     /** Cost value (square root of the sum of the residuals). */\n     private double cost;\n \n@@ -68,23 +61,7 @@\n      * match problem dimension.\n      */\n     protected RealMatrix computeWeightedJacobian(double[] params) {\n-\n-        final double[][] jacobian = computeJacobian(params);\n-\n-        if (weightSquareRoot != null) {\n-            for (int i = 0; i < jacobian.length; ++i) {\n-                final double wi = weightSquareRoot[i];\n-                final double[] row = jacobian[i];\n-                for (int j = 0; j < row.length; ++j) {\n-                    row[j] *= wi;\n-                }\n-            }\n-            return MatrixUtils.createRealMatrix(jacobian);\n-        } else {\n-            // TODO: remove for 4.0, when the {@link Weight} class will be removed\n-            return weightMatrixSqrt.multiply(MatrixUtils.createRealMatrix(jacobian));\n-        }\n-\n+        return weightMatrixSqrt.multiply(MatrixUtils.createRealMatrix(computeJacobian(params)));\n     }\n \n     /**\n@@ -96,13 +73,7 @@\n      */\n     protected double computeCost(double[] residuals) {\n         final ArrayRealVector r = new ArrayRealVector(residuals);\n-        final double[] weight = getNonCorrelatedWeight();\n-        double sum = 0;\n-        for (int i = 0; i < r.getDimension(); ++i) {\n-            final double ri = r.getEntry(i);\n-            sum += ri * weight[i] * ri;\n-        }\n-        return FastMath.sqrt(sum);\n+        return FastMath.sqrt(r.dotProduct(getWeight().operate(r)));\n     }\n \n     /**\n@@ -134,9 +105,7 @@\n      * Gets the square-root of the weight matrix.\n      *\n      * @return the square-root of the weight matrix.\n-     * @deprecated as of 3.1.1, replaced with {@link MultivariateVectorOptimizer#getNonCorrelatedWeight()}\n      */\n-    @Deprecated\n     public RealMatrix getWeightSquareRoot() {\n         return weightMatrixSqrt.copy();\n     }\n@@ -214,7 +183,7 @@\n      *  <li>{@link org.apache.commons.math3.optim.InitialGuess}</li>\n      *  <li>{@link org.apache.commons.math3.optim.SimpleBounds}</li>\n      *  <li>{@link org.apache.commons.math3.optim.nonlinear.vector.Target}</li>\n-     *  <li>{@link org.apache.commons.math3.optim.nonlinear.vector.NonCorrelatedWeight}</li>\n+     *  <li>{@link org.apache.commons.math3.optim.nonlinear.vector.Weight}</li>\n      *  <li>{@link org.apache.commons.math3.optim.nonlinear.vector.ModelFunction}</li>\n      *  <li>{@link org.apache.commons.math3.optim.nonlinear.vector.ModelFunctionJacobian}</li>\n      * </ul>\n@@ -266,7 +235,8 @@\n     /**\n      * Scans the list of (required and optional) optimization data that\n      * characterize the problem.\n-     * If the weight is specified, the {@link #weightSquareRoot} field is recomputed.\n+     * If the weight matrix is specified, the {@link #weightMatrixSqrt}\n+     * field is recomputed.\n      *\n      * @param optData Optimization data. The following data will be looked for:\n      * <ul>\n@@ -278,19 +248,22 @@\n         // not provided in the argument list.\n         for (OptimizationData data : optData) {\n             if (data instanceof Weight) {\n-                // TODO: remove for 4.0, when the {@link Weight} class will be removed\n-                weightSquareRoot = null;\n-                final RealMatrix w = ((Weight) data).getWeight();\n-                final EigenDecomposition dec = new EigenDecomposition(w);\n-                weightMatrixSqrt = dec.getSquareRoot();\n-            } else if (data instanceof NonCorrelatedWeight) {\n-                weightSquareRoot = ((NonCorrelatedWeight) data).getWeight();\n-                for (int i = 0; i < weightSquareRoot.length; ++i) {\n-                    weightSquareRoot[i] = FastMath.sqrt(weightSquareRoot[i]);\n-                }\n-                weightMatrixSqrt = null;\n+                weightMatrixSqrt = squareRoot(((Weight) data).getWeight());\n+                // If more data must be parsed, this statement _must_ be\n+                // changed to \"continue\".\n+                break;\n             }\n         }\n     }\n \n+    /**\n+     * Computes the square-root of the weight matrix.\n+     *\n+     * @param m Symmetric, positive-definite (weight) matrix.\n+     * @return the square-root of the weight matrix.\n+     */\n+    private RealMatrix squareRoot(RealMatrix m) {\n+        final EigenDecomposition dec = new EigenDecomposition(m);\n+        return dec.getSquareRoot();\n+    }\n }\n\n"
    },
    "Math-15": {
        "Buggy Function": "public static double pow(double x, double y) {\n    final double lns[] = new double[2];\n\n    if (y == 0.0) {\n        return 1.0;\n    }\n\n    if (x != x) { // X is NaN\n        return x;\n    }\n\n\n    if (x == 0) {\n        long bits = Double.doubleToLongBits(x);\n        if ((bits & 0x8000000000000000L) != 0) {\n            // -zero\n            long yi = (long) y;\n\n            if (y < 0 && y == yi && (yi & 1) == 1) {\n                return Double.NEGATIVE_INFINITY;\n            }\n\n            if (y > 0 && y == yi && (yi & 1) == 1) {\n                return -0.0;\n            }\n        }\n\n        if (y < 0) {\n            return Double.POSITIVE_INFINITY;\n        }\n        if (y > 0) {\n            return 0.0;\n        }\n\n        return Double.NaN;\n    }\n\n    if (x == Double.POSITIVE_INFINITY) {\n        if (y != y) { // y is NaN\n            return y;\n        }\n        if (y < 0.0) {\n            return 0.0;\n        } else {\n            return Double.POSITIVE_INFINITY;\n        }\n    }\n\n    if (y == Double.POSITIVE_INFINITY) {\n        if (x * x == 1.0) {\n            return Double.NaN;\n        }\n\n        if (x * x > 1.0) {\n            return Double.POSITIVE_INFINITY;\n        } else {\n            return 0.0;\n        }\n    }\n\n    if (x == Double.NEGATIVE_INFINITY) {\n        if (y != y) { // y is NaN\n            return y;\n        }\n\n        if (y < 0) {\n            long yi = (long) y;\n            if (y == yi && (yi & 1) == 1) {\n                return -0.0;\n            }\n\n            return 0.0;\n        }\n\n        if (y > 0)  {\n            long yi = (long) y;\n            if (y == yi && (yi & 1) == 1) {\n                return Double.NEGATIVE_INFINITY;\n            }\n\n            return Double.POSITIVE_INFINITY;\n        }\n    }\n\n    if (y == Double.NEGATIVE_INFINITY) {\n\n        if (x * x == 1.0) {\n            return Double.NaN;\n        }\n\n        if (x * x < 1.0) {\n            return Double.POSITIVE_INFINITY;\n        } else {\n            return 0.0;\n        }\n    }\n\n    /* Handle special case x<0 */\n    if (x < 0) {\n        // y is an even integer in this case\n        if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n            return pow(-x, y);\n        }\n\n        if (y == (long) y) {\n            // If y is an integer\n            return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y);\n        } else {\n            return Double.NaN;\n        }\n    }\n\n    /* Split y into ya and yb such that y = ya+yb */\n    double ya;\n    double yb;\n    if (y < 8e298 && y > -8e298) {\n        double tmp1 = y * HEX_40000000;\n        ya = y + tmp1 - tmp1;\n        yb = y - ya;\n    } else {\n        double tmp1 = y * 9.31322574615478515625E-10;\n        double tmp2 = tmp1 * 9.31322574615478515625E-10;\n        ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;\n        yb = y - ya;\n    }\n\n    /* Compute ln(x) */\n    final double lores = log(x, lns);\n    if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN\n        return lores;\n    }\n\n    double lna = lns[0];\n    double lnb = lns[1];\n\n    /* resplit lns */\n    double tmp1 = lna * HEX_40000000;\n    double tmp2 = lna + tmp1 - tmp1;\n    lnb += lna - tmp2;\n    lna = tmp2;\n\n    // y*ln(x) = (aa+ab)\n    final double aa = lna * ya;\n    final double ab = lna * yb + lnb * ya + lnb * yb;\n\n    lna = aa+ab;\n    lnb = -(lna - aa - ab);\n\n    double z = 1.0 / 120.0;\n    z = z * lnb + (1.0 / 24.0);\n    z = z * lnb + (1.0 / 6.0);\n    z = z * lnb + 0.5;\n    z = z * lnb + 1.0;\n    z = z * lnb;\n\n    final double result = exp(lna, z, null);\n    //result = result + result * z;\n    return result;\n}",
        "Inducing Changes": "diff --git a/src/main/java/org/apache/commons/math/util/FastMath.java b/src/main/java/org/apache/commons/math/util/FastMath.java\nindex 3d963e5..09c7cd0 100644\n--- a/src/main/java/org/apache/commons/math/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math/util/FastMath.java\n@@ -204,22 +204,6 @@\n     private FastMath() {\n     }\n \n-    /** Compute the arc cosine of a number.\n-     * @param a number on which evaluation is done\n-     * @return arc cosine of a\n-     */\n-    public static double acos(final double a) {\n-        return Math.acos(a);\n-    }\n-\n-    /** Compute the arc sine of a number.\n-     * @param a number on which evaluation is done\n-     * @return arc sine of a\n-     */\n-    public static double asin(final double a) {\n-        return Math.asin(a);\n-    }\n-\n     /** Compute the square root of a number.\n      * @param a number on which evaluation is done\n      * @return square root of a\n@@ -441,6 +425,10 @@\n             intVal \u003d (int) -x;\n \n             if (intVal \u003e 746) {\n+                if (hiPrec !\u003d null) {\n+                    hiPrec[0] \u003d 0.0;\n+                    hiPrec[1] \u003d 0.0;\n+                }\n                 return 0.0;\n             }\n \n@@ -474,6 +462,10 @@\n             intVal \u003d (int) x;\n \n             if (intVal \u003e 709) {\n+                if (hiPrec !\u003d null) {\n+                    hiPrec[0] \u003d Double.POSITIVE_INFINITY;\n+                    hiPrec[1] \u003d 0.0;\n+                }\n                 return Double.POSITIVE_INFINITY;\n             }\n \n@@ -1171,6 +1163,14 @@\n         double xpa \u003d 1.0 + x;\n         double xpb \u003d -(xpa - 1.0 - x);\n \n+        if (x \u003d\u003d -1) {\n+            return x/0.0;   // -Infinity\n+        }\n+\n+        if (x \u003e 0 \u0026\u0026 1/x \u003d\u003d 0) { // x \u003d Infinity\n+            return x;\n+        }\n+\n         if (x\u003e1e-6 || x\u003c-1e-6) {\n             double hiPrec[] \u003d new double[2];\n \n@@ -1227,22 +1227,28 @@\n             return 1.0;\n         }\n \n-        /* Handle special case x\u003c0 */\n-        if (x \u003c 0) {\n-            if (y \u003d\u003d (long) y) {\n-                // If y is an integer\n-                return ((long)y \u0026 1) \u003d\u003d 0 ? pow(-x, y) : -pow(-x, y);\n-            } else {\n-                return Double.NaN;\n-            }\n+        if (x !\u003d x) { // X is NaN\n+            return x;\n         }\n \n+\n         if (x \u003d\u003d 0) {\n             long bits \u003d Double.doubleToLongBits(x);\n             if ((bits \u0026 0x8000000000000000L) !\u003d 0) {\n                 // -zero\n-                if (y \u003c 0 \u0026\u0026 y \u003d\u003d (long)y)\n+                long yi \u003d (long) y;\n+\n+                if (y \u003c 0 \u0026\u0026 y \u003d\u003d yi \u0026\u0026 (yi \u0026 1) \u003d\u003d 1) {\n                     return Double.NEGATIVE_INFINITY;\n+                }\n+\n+                if (y \u003c 0 \u0026\u0026 y \u003d\u003d yi \u0026\u0026 (yi \u0026 1) \u003d\u003d 1) {\n+                    return -0.0;\n+                }\n+\n+                if (y \u003e 0 \u0026\u0026 y \u003d\u003d yi \u0026\u0026 (yi \u0026 1) \u003d\u003d 1) {\n+                    return -0.0;\n+                }\n             }\n \n             if (y \u003c 0) {\n@@ -1256,6 +1262,9 @@\n         }\n \n         if (x \u003d\u003d Double.POSITIVE_INFINITY) {\n+            if (y !\u003d y) { // y is NaN\n+                return y;\n+            }\n             if (y \u003c 0.0) {\n                 return 0.0;\n             } else {\n@@ -1264,6 +1273,9 @@\n         }\n \n         if (y \u003d\u003d Double.POSITIVE_INFINITY) {\n+            if (x * x \u003d\u003d 1.0)\n+              return Double.NaN;\n+\n             if (x * x \u003e 1.0) {\n                 return Double.POSITIVE_INFINITY;\n             } else {\n@@ -1271,18 +1283,71 @@\n             }\n         }\n \n+        if (x \u003d\u003d Double.NEGATIVE_INFINITY) {\n+            if (y !\u003d y) { // y is NaN\n+                return y;\n+            }\n+\n+            if (y \u003c 0) {\n+                long yi \u003d (long) y;\n+                if (y \u003d\u003d yi \u0026\u0026 (yi \u0026 1) \u003d\u003d 1) {\n+                    return -0.0;\n+                }\n+\n+                return 0.0;\n+            }\n+\n+            if (y \u003e 0)  {\n+                long yi \u003d (long) y;\n+                if (y \u003d\u003d yi \u0026\u0026 (yi \u0026 1) \u003d\u003d 1) {\n+                    return Double.NEGATIVE_INFINITY;\n+                }\n+\n+                return Double.POSITIVE_INFINITY;\n+            }\n+        }\n+\n         if (y \u003d\u003d Double.NEGATIVE_INFINITY) {\n-            if (x*x \u003c 1.0) {\n-                return Double.NEGATIVE_INFINITY;\n+\n+            if (x * x \u003d\u003d 1.0) {\n+                return Double.NaN;\n+            }\n+\n+            if (x * x \u003c 1.0) {\n+                return Double.POSITIVE_INFINITY;\n             } else {\n                 return 0.0;\n             }\n         }\n \n+        /* Handle special case x\u003c0 */\n+        if (x \u003c 0) {\n+            // y is an even integer in this case\n+            if (y \u003e\u003d 4503599627370496.0 || y \u003c\u003d -4503599627370496.0) {\n+                return pow(-x, y);\n+            }\n+\n+            if (y \u003d\u003d (long) y) {\n+                // If y is an integer\n+                return ((long)y \u0026 1) \u003d\u003d 0 ? pow(-x, y) : -pow(-x, y);\n+            } else {\n+                return Double.NaN;\n+            }\n+        }\n+\n         /* Split y into ya and yb such that y \u003d ya+yb */\n-        double tmp1 \u003d y * 1073741824.0;\n-        final double ya \u003d y + tmp1 - tmp1;\n-        final double yb \u003d y - ya;\n+        double ya;\n+        double yb;\n+        if (y \u003c 8e298 \u0026\u0026 y \u003e -8e298) {\n+            double tmp1 \u003d y * 1073741824.0;\n+            ya \u003d y + tmp1 - tmp1;\n+            yb \u003d y - ya;\n+        } else {\n+            double tmp1 \u003d y * 9.31322574615478515625E-10;\n+            double tmp2 \u003d tmp1 * 9.31322574615478515625E-10;\n+            ya \u003d (tmp1 + tmp2 - tmp1) * 1073741824.0 * 1073741824.0;\n+            yb \u003d y - ya;\n+        }\n \n         /* Compute ln(x) */\n         log(x, lns);\n@@ -1290,8 +1355,8 @@\n         double lnb \u003d lns[1];\n \n         /* resplit lns */\n-        tmp1 \u003d lna * 1073741824.0;\n-        final double tmp2 \u003d lna + tmp1 - tmp1;\n+        double tmp1 \u003d lna * 1073741824.0;\n+        double tmp2 \u003d lna + tmp1 - tmp1;\n         lnb +\u003d lna - tmp2;\n         lna \u003d tmp2;\n \n@@ -2375,8 +2440,8 @@\n             double b \u003d -(a - pi2a + xa);\n             b +\u003d pi2b - xb;\n \n-            xa \u003d a;\n-            xb \u003d b;\n+            xa \u003d a + b;\n+            xb \u003d -(xa - a - b);\n             quadrant ^\u003d 1;\n             negative ^\u003d true;\n         }\n@@ -2412,7 +2477,6 @@\n      */\n     private static double atan(double xa, double xb, boolean leftPlane) {\n         boolean negate \u003d false;\n-        boolean recip \u003d false;\n         int idx;\n \n         if (xa \u003c 0) {\n@@ -2519,41 +2583,24 @@\n \n         double result;\n         double resultb;\n-        if (recip) {\n-            final double pi2a \u003d 1.5707963267948966;\n-            final double pi2b \u003d 6.123233995736766E-17;\n \n-            double za \u003d pi2a - ya;\n-            double zb \u003d -(za - pi2a + ya);\n-            temp \u003d za - EIGHTHES[idx];\n-            zb +\u003d -(temp - za + EIGHTHES[idx]);\n-            za \u003d temp;\n+        //result \u003d yb + eighths[idx] + ya;\n+        double za \u003d EIGHTHES[idx] + ya;\n+        double zb \u003d -(za - EIGHTHES[idx] - ya);\n+        temp \u003d za + yb;\n+        zb +\u003d -(temp - za - yb);\n+        za \u003d temp;\n \n-            zb +\u003d pi2b - yb;\n-            ya \u003d za;\n-            yb \u003d zb;\n-\n-            result \u003d yb + ya;\n-            resultb \u003d -(result - yb - ya);\n-        } else {\n-            //result \u003d yb + eighths[idx] + ya;\n-            double za \u003d EIGHTHES[idx] + ya;\n-            double zb \u003d -(za - EIGHTHES[idx] - ya);\n-            temp \u003d za + yb;\n-            zb +\u003d -(temp - za - yb);\n-            za \u003d temp;\n-\n-            result \u003d za + zb;\n-            resultb \u003d -(result - za - zb);\n-        }\n+        result \u003d za + zb;\n+        resultb \u003d -(result - za - zb);\n \n         if (leftPlane) {\n             // Result is in the left plane\n             final double pia \u003d 1.5707963267948966*2.0;\n             final double pib \u003d 6.123233995736766E-17*2.0;\n \n-            final double za \u003d pia - result;\n-            double zb \u003d -(za - pia + result);\n+            za \u003d pia - result;\n+            zb \u003d -(za - pia + result);\n             zb +\u003d pib - resultb;\n \n             result \u003d za + zb;\n@@ -2585,7 +2632,11 @@\n             double invy \u003d 1.0/y;\n \n             if (invx \u003d\u003d 0.0) { // X is infinite\n-                return 0.0;\n+                if (x \u003e 0) {\n+                    return 0.0;\n+                } else {\n+                    return Math.PI;\n+                }\n             }\n \n             if (result !\u003d result) { // y must be infinite\n@@ -2686,6 +2737,155 @@\n         return result;\n     }\n \n+    /** Compute the arc sine of a number.\n+     * @param x number on which evaluation is done\n+     * @return arc sine of x\n+     */\n+    public static double asin(double x) {\n+      if (x !\u003d x) {\n+          return Double.NaN;\n+      }\n+\n+      if (x \u003e 1.0 || x \u003c -1.0) {\n+          return Double.NaN;\n+      }\n+\n+      if (x \u003d\u003d 1.0) {\n+          return Math.PI/2.0;\n+      }\n+\n+      if (x \u003d\u003d -1.0) {\n+          return -Math.PI/2.0;\n+      }\n+\n+      /* Compute asin(x) \u003d atan(x/sqrt(1-x*x)) */\n+\n+      /* Split x */\n+      double temp \u003d x * 1073741824.0;\n+      final double xa \u003d x + temp - temp;\n+      final double xb \u003d x - xa;\n+\n+      /* Square it */\n+      double ya \u003d xa*xa;\n+      double yb \u003d xa*xb*2.0 + xb*xb;\n+\n+      /* Subtract from 1 */\n+      ya \u003d -ya;\n+      yb \u003d -yb;\n+\n+      double za \u003d 1.0 + ya;\n+      double zb \u003d -(za - 1.0 - ya);\n+\n+      temp \u003d za + yb;\n+      zb +\u003d -(temp - za - yb);\n+      za \u003d temp;\n+\n+      /* Square root */\n+      double y;\n+      y \u003d sqrt(za);\n+      temp \u003d y * 1073741824.0;\n+      ya \u003d y + temp - temp;\n+      yb \u003d y - ya;\n+\n+      /* Extend precision of sqrt */\n+      yb +\u003d (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n+\n+      /* Contribution of zb to sqrt */\n+      double dx \u003d zb / (2.0*y);\n+\n+      // Compute ratio r \u003d x/y\n+      double r \u003d x/y;\n+      temp \u003d r * 1073741824.0;\n+      double ra \u003d r + temp - temp;\n+      double rb \u003d r - ra;\n+\n+      rb +\u003d (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n+      rb +\u003d -x * dx / y / y;  // Add in effect additional bits of sqrt.\n+\n+      temp \u003d ra + rb;\n+      rb \u003d -(temp - ra - rb);\n+      ra \u003d temp;\n+\n+      return atan(ra, rb, false);\n+    }\n+\n+    /** Compute the arc cosine of a number.\n+     * @param x number on which evaluation is done\n+     * @return arc cosine of x\n+     */\n+    public static double acos(double x) {\n+      if (x !\u003d x) {\n+          return Double.NaN;\n+      }\n+\n+      if (x \u003e 1.0 || x \u003c -1.0) {\n+          return Double.NaN;\n+      }\n+\n+      if (x \u003d\u003d -1.0) {\n+          return Math.PI;\n+      }\n+\n+      if (x \u003d\u003d 1.0) {\n+          return 0.0;\n+      }\n+\n+      if (x \u003d\u003d 0) {\n+          return Math.PI/2.0;\n+      }\n+\n+      /* Compute acos(x) \u003d atan(sqrt(1-x*x)/x) */\n+\n+      /* Split x */\n+      double temp \u003d x * 1073741824.0;\n+      final double xa \u003d x + temp - temp;\n+      final double xb \u003d x - xa;\n+\n+      /* Square it */\n+      double ya \u003d xa*xa;\n+      double yb \u003d xa*xb*2.0 + xb*xb;\n+\n+      /* Subtract from 1 */\n+      ya \u003d -ya;\n+      yb \u003d -yb;\n+\n+      double za \u003d 1.0 + ya;\n+      double zb \u003d -(za - 1.0 - ya);\n+\n+      temp \u003d za + yb;\n+      zb +\u003d -(temp - za - yb);\n+      za \u003d temp;\n+\n+      /* Square root */\n+      double y \u003d sqrt(za);\n+      temp \u003d y * 1073741824.0;\n+      ya \u003d y + temp - temp;\n+      yb \u003d y - ya;\n+\n+      /* Extend precision of sqrt */\n+      yb +\u003d (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n+\n+      /* Contribution of zb to sqrt */\n+      yb +\u003d zb / (2.0*y);\n+      y \u003d ya+yb;\n+      yb \u003d -(y - ya - yb);\n+\n+      // Compute ratio r \u003d y/x\n+      double r \u003d y/x;\n+      temp \u003d r * 1073741824.0;\n+      double ra \u003d r + temp - temp;\n+      double rb \u003d r - ra;\n+\n+      rb +\u003d (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n+      rb +\u003d yb / x;  // Add in effect additional bits of sqrt.\n+\n+      temp \u003d ra + rb;\n+      rb \u003d -(temp - ra - rb);\n+      ra \u003d temp;\n+\n+      return atan(ra, rb, x\u003c0);\n+    }\n+\n     /**\n      *  Convert degrees to radians, with error of less than 0.5 ULP\n      *  @param x angle in degrees\n@@ -2829,15 +3029,23 @@\n     public static double floor(double x) {\n         long y;\n \n+        if (x !\u003d x) { // NaN\n+            return x;\n+        }\n+\n         if (x \u003e\u003d 4503599627370496.0 || x \u003c\u003d -4503599627370496.0) {\n             return x;\n         }\n \n         y \u003d (long) x;\n-        if (x \u003c 0) {\n+        if (x \u003c 0 \u0026\u0026 y !\u003d x) {\n             y--;\n         }\n \n+        if (y \u003d\u003d 0) {\n+            return x*y;\n+        }\n+\n         return (double) y;\n     }\n \n@@ -2848,12 +3056,22 @@\n     public static double ceil(double x) {\n         double y;\n \n+        if (x !\u003d x) { // NaN\n+            return x;\n+        }\n+\n         y \u003d floor(x);\n         if (y \u003d\u003d x) {\n             return y;\n         }\n \n-        return y + 1.0;\n+        y +\u003d 1.0;\n+\n+        if (y \u003d\u003d 0) {\n+            return x*y;\n+        }\n+\n+        return y;\n     }\n \n     /** Get the whole number that is the nearest to x, or the even one if x is exactly half way between two integers.\n"
    },
    "Math-23": {
        "Buggy Function": "    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n\n        // Optional additional convergence criteria.\n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(x);\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair current\n            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n        // Best point encountered so far (which is the initial guess).\n\n        int iter = 0;\n        while (true) {\n            final double m = 0.5 * (a + b);\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n\n            // Default stopping criterion.\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n            if (!stop) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n\n                if (FastMath.abs(e) > tol1) { // Fit parabola.\n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -q;\n                    }\n\n                    r = e;\n                    e = d;\n\n                    if (p > q * (a - x) &&\n                        p < q * (b - x) &&\n                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                        // Parabolic interpolation step.\n                        d = p / q;\n                        u = x + d;\n\n                        // f must not be evaluated too close to a or b.\n                        if (u - a < tol2 || b - u < tol2) {\n                            if (x <= m) {\n                                d = tol1;\n                            } else {\n                                d = -tol1;\n                            }\n                        }\n                    } else {\n                        // Golden section step.\n                        if (x < m) {\n                            e = b - x;\n                        } else {\n                            e = a - x;\n                        }\n                        d = GOLDEN_SECTION * e;\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n\n                // Update by at least \"tol1\".\n                if (FastMath.abs(d) < tol1) {\n                    if (d >= 0) {\n                        u = x + tol1;\n                    } else {\n                        u = x - tol1;\n                    }\n                } else {\n                    u = x + d;\n                }\n\n                double fu = computeObjectiveValue(u);\n                if (!isMinim) {\n                    fu = -fu;\n                }\n\n                // User-defined convergence checker.\n                previous = current;\n                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n\n                if (checker != null) {\n                    if (checker.converged(iter, previous, current)) {\n                        return best(current, previous, isMinim);\n                    }\n                }\n\n                // Update a, b, v, w and x.\n                if (fu <= fx) {\n                    if (u < x) {\n                        b = x;\n                    } else {\n                        a = x;\n                    }\n                    v = w;\n                    fv = fw;\n                    w = x;\n                    fw = fx;\n                    x = u;\n                    fx = fu;\n                } else {\n                    if (u < x) {\n                        a = u;\n                    } else {\n                        b = u;\n                    }\n                    if (fu <= fw ||\n                        Precision.equals(w, x)) {\n                        v = w;\n                        fv = fw;\n                        w = u;\n                        fw = fu;\n                    } else if (fu <= fv ||\n                               Precision.equals(v, x) ||\n                               Precision.equals(v, w)) {\n                        v = u;\n                        fv = fu;\n                    }\n                }\n            } else { // Default termination (Brent's criterion).\n                return\n                            best(current,\n                                 previous,\n                            isMinim);\n            }\n            ++iter;\n        }\n    }",
        "Inducing Changes": "diff --git a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\nindex 15a498c..ee2227c 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n@@ -220,6 +220,16 @@\n                     fu = -fu;\n                 }\n \n+                // User-defined convergence checker.\n+                previous = current;\n+                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n+\n+                if (checker != null) {\n+                    if (checker.converged(iter, previous, current)) {\n+                        return current;\n+                    }\n+                }\n+\n                 // Update a, b, v, w and x.\n                 if (fu <= fx) {\n                     if (u < x) {\n@@ -233,16 +243,6 @@\n                     fw = fx;\n                     x = u;\n                     fx = fu;\n-\n-                    // User-defined convergence checker.\n-                    previous = current;\n-                    current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n-\n-                    if (checker != null) {\n-                        if (checker.converged(iter, previous, current)) {\n-                            return current;\n-                        }\n-                    }\n                 } else {\n                     if (u < x) {\n                         a = u;\n\n"
    },
    "Math-24": {
        "Buggy Function": "    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n\n        // Optional additional convergence criteria.\n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(x);\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair current\n            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n\n        int iter = 0;\n        while (true) {\n            final double m = 0.5 * (a + b);\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n\n            // Default stopping criterion.\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n            if (!stop) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n\n                if (FastMath.abs(e) > tol1) { // Fit parabola.\n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -q;\n                    }\n\n                    r = e;\n                    e = d;\n\n                    if (p > q * (a - x) &&\n                        p < q * (b - x) &&\n                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                        // Parabolic interpolation step.\n                        d = p / q;\n                        u = x + d;\n\n                        // f must not be evaluated too close to a or b.\n                        if (u - a < tol2 || b - u < tol2) {\n                            if (x <= m) {\n                                d = tol1;\n                            } else {\n                                d = -tol1;\n                            }\n                        }\n                    } else {\n                        // Golden section step.\n                        if (x < m) {\n                            e = b - x;\n                        } else {\n                            e = a - x;\n                        }\n                        d = GOLDEN_SECTION * e;\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n\n                // Update by at least \"tol1\".\n                if (FastMath.abs(d) < tol1) {\n                    if (d >= 0) {\n                        u = x + tol1;\n                    } else {\n                        u = x - tol1;\n                    }\n                } else {\n                    u = x + d;\n                }\n\n                double fu = computeObjectiveValue(u);\n                if (!isMinim) {\n                    fu = -fu;\n                }\n\n                // User-defined convergence checker.\n                previous = current;\n                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n\n                if (checker != null) {\n                    if (checker.converged(iter, previous, current)) {\n                        return current;\n                    }\n                }\n\n                // Update a, b, v, w and x.\n                if (fu <= fx) {\n                    if (u < x) {\n                        b = x;\n                    } else {\n                        a = x;\n                    }\n                    v = w;\n                    fv = fw;\n                    w = x;\n                    fw = fx;\n                    x = u;\n                    fx = fu;\n                } else {\n                    if (u < x) {\n                        a = u;\n                    } else {\n                        b = u;\n                    }\n                    if (fu <= fw ||\n                        Precision.equals(w, x)) {\n                        v = w;\n                        fv = fw;\n                        w = u;\n                        fw = fu;\n                    } else if (fu <= fv ||\n                               Precision.equals(v, x) ||\n                               Precision.equals(v, w)) {\n                        v = u;\n                        fv = fu;\n                    }\n                }\n            } else { // Default termination (Brent's criterion).\n                return current;\n            }\n            ++iter;\n        }\n    }",
        "Inducing Changes": "diff --git a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\nindex 15a498c..ee2227c 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n@@ -220,6 +220,16 @@\n                     fu = -fu;\n                 }\n \n+                // User-defined convergence checker.\n+                previous = current;\n+                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n+\n+                if (checker != null) {\n+                    if (checker.converged(iter, previous, current)) {\n+                        return current;\n+                    }\n+                }\n+\n                 // Update a, b, v, w and x.\n                 if (fu <= fx) {\n                     if (u < x) {\n@@ -233,16 +243,6 @@\n                     fw = fx;\n                     x = u;\n                     fx = fu;\n-\n-                    // User-defined convergence checker.\n-                    previous = current;\n-                    current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n-\n-                    if (checker != null) {\n-                        if (checker.converged(iter, previous, current)) {\n-                            return current;\n-                        }\n-                    }\n                 } else {\n                     if (u < x) {\n                         a = u;\n\n"
    },
    "Math-26": {
        "Buggy Function": "    private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)\n        throws FractionConversionException\n    {\n        long overflow = Integer.MAX_VALUE;\n        double r0 = value;\n        long a0 = (long)FastMath.floor(r0);\n        if (a0 > overflow) {\n            throw new FractionConversionException(value, a0, 1l);\n        }\n\n        // check for (almost) integer arguments, which should not go\n        // to iterations.\n        if (FastMath.abs(a0 - value) < epsilon) {\n            this.numerator = (int) a0;\n            this.denominator = 1;\n            return;\n        }\n\n        long p0 = 1;\n        long q0 = 0;\n        long p1 = a0;\n        long q1 = 1;\n\n        long p2 = 0;\n        long q2 = 1;\n\n        int n = 0;\n        boolean stop = false;\n        do {\n            ++n;\n            double r1 = 1.0 / (r0 - a0);\n            long a1 = (long)FastMath.floor(r1);\n            p2 = (a1 * p1) + p0;\n            q2 = (a1 * q1) + q0;\n            if ((p2 > overflow) || (q2 > overflow)) {\n                throw new FractionConversionException(value, p2, q2);\n            }\n\n            double convergent = (double)p2 / (double)q2;\n            if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n                p0 = p1;\n                p1 = p2;\n                q0 = q1;\n                q1 = q2;\n                a0 = a1;\n                r0 = r1;\n            } else {\n                stop = true;\n            }\n        } while (!stop);\n\n        if (n >= maxIterations) {\n            throw new FractionConversionException(value, maxIterations);\n        }\n\n        if (q2 < maxDenominator) {\n            this.numerator = (int) p2;\n            this.denominator = (int) q2;\n        } else {\n            this.numerator = (int) p1;\n            this.denominator = (int) q1;\n        }\n\n    }",
        "Inducing Changes": "diff --git a/src/java/org/apache/commons/math/fraction/Fraction.java b/src/java/org/apache/commons/math/fraction/Fraction.java\nindex 302cde6..952b507 100644\n--- a/src/java/org/apache/commons/math/fraction/Fraction.java\n+++ b/src/java/org/apache/commons/math/fraction/Fraction.java\n@@ -32,10 +32,23 @@\n \n     /** A fraction representing \"0 / 1\". */\n     public static final Fraction ZERO \u003d new Fraction(0, 1);\n+\n+    /**\n+     * The maximal number of denominator digits that can be requested for double to fraction\n+     * conversion.\n+     * \u003cp\u003e\n+     * When \u003ccode\u003ed\u003c/code\u003e digits are requested, an integer threshold is\n+     * initialized with the value 10\u003csup\u003ed\u003c/sup\u003e. Therefore, \u003ccode\u003ed\u003c/code\u003e\n+     * cannot be larger than this constant. Since the java language uses 32 bits\n+     * signed integers, the value for this constant is 9.\n+     * \u003c/p\u003e\n+     * \n+     * @see #Fraction(double,int)\n+     */\n+    public static final int MAX_DENOMINATOR_DIGITS \u003d 9;\n     \n     /** Serializable version identifier */\n-    private static final long serialVersionUID \u003d 6222990762865980424L;\n-\n+    private static final long serialVersionUID \u003d 5463066929751300926L;\n     \n     /** The denominator. */\n     private int denominator;\n@@ -54,7 +67,7 @@\n     }\n \n     /**\n-     * Create a fraction given the double value.\n+     * Create a fraction given the double value and maximum error allowed.\n      * \u003cp\u003e\n      * References:\n      * \u003cul\u003e\n@@ -72,6 +85,82 @@\n     public Fraction(double value, double epsilon, int maxIterations)\n         throws FractionConversionException\n     {\n+        this(value, epsilon, Integer.MAX_VALUE, maxIterations);\n+    }\n+\n+    /**\n+     * Convert a number of denominator digits to a denominator max value.\n+     * @param denominatorDigits The maximum number of denominator digits.\n+     * @return the maximal value for denominator\n+     * @throws IllegalArgumentException if more than {@link #MAX_DENOMINATOR_DIGITS}\n+     *         are requested\n+     */\n+    private static int maxDenominator(int denominatorDigits)\n+        throws IllegalArgumentException\n+    {\n+        if (denominatorDigits \u003e MAX_DENOMINATOR_DIGITS) {\n+            throw new IllegalArgumentException(\"too many digits requested\");\n+        }\n+        return (int)Math.pow(10, denominatorDigits);\n+    }\n+\n+    /**\n+     * Create a fraction given the double value and maximum number of\n+     * denominator digits.\n+     * \u003cp\u003e\n+     * References:\n+     * \u003cul\u003e\n+     * \u003cli\u003e\u003ca href\u003d\"http://mathworld.wolfram.com/ContinuedFraction.html\"\u003e\n+     * Continued Fraction\u003c/a\u003e equations (11) and (22)-(26)\u003c/li\u003e\n+     * \u003c/ul\u003e\n+     * \u003c/p\u003e\n+     * @param value the double value to convert to a fraction.\n+     * @param denominatorDigits The maximum number of denominator digits.\n+     * @throws FractionConversionException if the continued fraction failed to\n+     *         converge\n+     * @throws IllegalArgumentException if more than {@link #MAX_DENOMINATOR_DIGITS}\n+     *         are requested\n+     */\n+    public Fraction(double value, int denominatorDigits)\n+        throws FractionConversionException, IllegalArgumentException\n+    {\n+       this(value, 0, maxDenominator(denominatorDigits), 100);\n+    }\n+\n+    /**\n+     * Create a fraction given the double value and either the maximum error\n+     * allowed or the maximum number of denominator digits.\n+     * \u003cp\u003e\n+     *\n+     * NOTE: This constructor is called with EITHER\n+     *   - a valid epsilon value and the maxDenominator set to Integer.MAX_VALUE\n+     *     (that way the maxDenominator has no effect).\n+     * OR\n+     *   - a valid maxDenominator value and the epsilon value set to zero\n+     *     (that way epsilon only has effect if there is an exact match before\n+     *     the maxDenominator value is reached).\n+     * \u003cp\u003e\n+     *\n+     * It has been done this way so that the same code can be (re)used for both\n+     * scenarios. However this could be confusing to users if it were part of\n+     * the public API and this constructor should therefore remain PRIVATE.\n+     * \u003c/p\u003e\n+     *\n+     * See JIRA issue ticket MATH-181 for more details:\n+     *\n+     *     https://issues.apache.org/jira/browse/MATH-181\n+     *\n+     * @param value the double value to convert to a fraction.\n+     * @param epsilon maximum error allowed.  The resulting fraction is within\n+     *        \u003ccode\u003eepsilon\u003c/code\u003e of \u003ccode\u003evalue\u003c/code\u003e, in absolute terms.\n+     * @param maxDenominator maximum denominator value allowed.\n+     * @param maxIterations maximum number of convergents\n+     * @throws FractionConversionException if the continued fraction failed to\n+     *         converge.\n+     */\n+    private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)\n+        throws FractionConversionException\n+    {\n         double r0 \u003d value;\n         int a0 \u003d (int)Math.floor(r0);\n \n@@ -101,7 +190,7 @@\n             q2 \u003d (a1 * q1) + q0;\n             \n             double convergent \u003d (double)p2 / (double)q2;\n-            if (n \u003c maxIterations \u0026\u0026 Math.abs(convergent - value) \u003e epsilon) {\n+            if (n \u003c maxIterations \u0026\u0026 Math.abs(convergent - value) \u003e epsilon \u0026\u0026 q2 \u003c maxDenominator) {\n                 p0 \u003d p1;\n                 p1 \u003d p2;\n                 q0 \u003d q1;\n@@ -117,8 +206,13 @@\n             throw new FractionConversionException(value, maxIterations);\n         }\n         \n-        this.numerator \u003d p2;\n-        this.denominator \u003d q2;\n+        if (q2 \u003c maxDenominator) {\n+            this.numerator \u003d p2;\n+            this.denominator \u003d q2;\n+        } else {\n+            this.numerator \u003d p1;\n+            this.denominator \u003d q1;\n+        }\n         reduce();\n     }\n     \n"
    },
    "Math-28": {
        "Buggy Function": "    private Integer getPivotRow(SimplexTableau tableau, final int col) {\n        // create a list of all the rows that tie for the lowest score in the minimum ratio test\n        List<Integer> minRatioPositions = new ArrayList<Integer>();\n        double minRatio = Double.MAX_VALUE;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                final double ratio = rhs / entry;\n                // check if the entry is strictly equal to the current min ratio\n                // do not use a ulp/epsilon check\n                final int cmp = Double.compare(ratio, minRatio);\n                if (cmp == 0) {\n                    minRatioPositions.add(i);\n                } else if (cmp < 0) {\n                    minRatio = ratio;\n                    minRatioPositions = new ArrayList<Integer>();\n                    minRatioPositions.add(i);\n                }\n            }\n        }\n\n        if (minRatioPositions.size() == 0) {\n            return null;\n        } else if (minRatioPositions.size() > 1) {\n            // there's a degeneracy as indicated by a tie in the minimum ratio test\n\n            // 1. check if there's an artificial variable that can be forced out of the basis\n                for (Integer row : minRatioPositions) {\n                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                        int column = i + tableau.getArtificialVariableOffset();\n                        final double entry = tableau.getEntry(row, column);\n                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                            return row;\n                        }\n                    }\n                }\n\n            // 2. apply Bland's rule to prevent cycling:\n            //    take the row for which the corresponding basic variable has the smallest index\n            //\n            // see http://www.stanford.edu/class/msande310/blandrule.pdf\n            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n            //\n            // Additional heuristic: if we did not get a solution after half of maxIterations\n            //                       revert to the simple case of just returning the top-most row\n            // This heuristic is based on empirical data gathered while investigating MATH-828.\n                Integer minRow = null;\n                int minIndex = tableau.getWidth();\n                for (Integer row : minRatioPositions) {\n                    int i = tableau.getNumObjectiveFunctions();\n                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                        if (row == tableau.getBasicRow(i)) {\n                            if (i < minIndex) {\n                                minIndex = i;\n                                minRow = row;\n                            }\n                        }\n                    }\n                }\n                return minRow;\n        }\n        return minRatioPositions.get(0);\n    }",
        "Inducing Changes": "diff --git a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\nindex c3d9089..c2fa14d 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n@@ -71,7 +71,9 @@\n         Integer minPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, minValue, maxUlps) < 0) {\n+            // check if the entry is strictly smaller than the current minimum\n+            // do not use a ulp/epsilon check\n+            if (entry < minValue) {\n                 minValue = entry;\n                 minPos = i;\n             }\n@@ -95,7 +97,9 @@\n \n             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                 final double ratio = rhs / entry;\n-                final int cmp = Precision.compareTo(ratio, minRatio, maxUlps);\n+                // check if the entry is strictly equal to the current min ratio\n+                // do not use a ulp/epsilon check\n+                final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n                     minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n@@ -107,20 +111,40 @@\n         }\n \n         if (minRatioPositions.size() == 0) {\n-          return null;\n+            return null;\n         } else if (minRatioPositions.size() > 1) {\n-          // there's a degeneracy as indicated by a tie in the minimum ratio test\n-          // check if there's an artificial variable that can be forced out of the basis\n-          for (Integer row : minRatioPositions) {\n-            for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-              int column = i + tableau.getArtificialVariableOffset();\n-              final double entry = tableau.getEntry(row, column);\n-              if (Precision.equals(entry, 1d, maxUlps) &&\n-                  row.equals(tableau.getBasicRow(column))) {\n-                return row;\n-              }\n+            // there's a degeneracy as indicated by a tie in the minimum ratio test\n+\n+            // 1. check if there's an artificial variable that can be forced out of the basis\n+            for (Integer row : minRatioPositions) {\n+                for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n+                    int column = i + tableau.getArtificialVariableOffset();\n+                    final double entry = tableau.getEntry(row, column);\n+                    if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n+                        return row;\n+                    }\n+                }\n             }\n-          }\n+\n+            // 2. apply Bland's rule to prevent cycling:\n+            //    take the row for which the corresponding basic variable has the smallest index\n+            //\n+            // see http://www.stanford.edu/class/msande310/blandrule.pdf\n+            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n+            Integer minRow = null;\n+            int minIndex = tableau.getWidth();\n+            for (Integer row : minRatioPositions) {\n+                for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1 && minRow != row; i++) {\n+                    if (row == tableau.getBasicRow(i)) {\n+                        if (i < minIndex) {\n+                            minIndex = i;\n+                            minRow = row;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            return minRow;\n         }\n         return minRatioPositions.get(0);\n     }\n@@ -149,7 +173,7 @@\n         // set the rest of the pivot column to 0\n         for (int i = 0; i < tableau.getHeight(); i++) {\n             if (i != pivotRow) {\n-                double multiplier = tableau.getEntry(i, pivotCol);\n+                final double multiplier = tableau.getEntry(i, pivotCol);\n                 tableau.subtractRow(i, pivotRow, multiplier);\n             }\n         }\n\n"
    },
    "Math-42": {
        "Buggy Function": "    protected RealPointValuePair getSolution() {\n      int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);\n      Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;\n      double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n\n      Set<Integer> basicRows = new HashSet<Integer>();\n      double[] coefficients = new double[getOriginalNumDecisionVariables()];\n      for (int i = 0; i < coefficients.length; i++) {\n          int colIndex = columnLabels.indexOf(\"x\" + i);\n          if (colIndex < 0) {\n            coefficients[i] = 0;\n            continue;\n          }\n          Integer basicRow = getBasicRow(colIndex);\n              // if the basic row is found to be the objective function row\n              // set the coefficient to 0 -> this case handles unconstrained \n              // variables that are still part of the objective function\n          if (basicRows.contains(basicRow)) {\n              // if multiple variables can take a given value\n              // then we choose the first and set the rest equal to 0\n              coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n          } else {\n              basicRows.add(basicRow);\n              coefficients[i] =\n                  (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                  (restrictToNonNegative ? 0 : mostNegative);\n          }\n      }\n      return new RealPointValuePair(coefficients, f.getValue(coefficients));\n    }",
        "Inducing Changes": "diff --git a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\nindex c228ad6..b387767 100644\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n@@ -270,8 +270,27 @@\n      * @return the row that the variable is basic in.  null if the column is not basic\n      */\n     private Integer getBasicRow(final int col) {\n+        return getBasicRow(col, true);\n+    }\n+\n+    /**\n+     * Checks whether the given column is basic.\n+     * @param col index of the column to check\n+     * @return the row that the variable is basic in.  null if the column is not basic\n+     */\n+    private Integer getBasicRowForSolution(final int col) {\n+        return getBasicRow(col, false);\n+    }\n+    \n+    /**\n+     * Checks whether the given column is basic.\n+     * @param col index of the column to check\n+     * @return the row that the variable is basic in.  null if the column is not basic\n+     */\n+    private Integer getBasicRow(final int col, boolean ignoreObjectiveRows) {\n         Integer row = null;\n-        for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n+        int start = ignoreObjectiveRows ? getNumObjectiveFunctions() : 0;\n+        for (int i = start; i < getHeight(); i++) {\n             if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\n                 row = i;\n             } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n@@ -318,24 +337,23 @@\n      * @return current solution\n      */\n     protected RealPointValuePair getSolution() {\n-        double[] coefficients = new double[getOriginalNumDecisionVariables()];\n-        Integer basicRow =\n-            getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n-        double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n-        Set<Integer> basicRows = new HashSet<Integer>();\n-        for (int i = 0; i < coefficients.length; i++) {\n-            basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n-            if (basicRows.contains(basicRow)) {\n-                // if multiple variables can take a given value \n-                // then we choose the first and set the rest equal to 0\n-                coefficients[i] = 0;\n-            } else {\n-                basicRows.add(basicRow);\n-                coefficients[i] =\n-                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n-                    (restrictToNonNegative ? 0 : mostNegative);\n-            }\n-        }\n+      double[] coefficients = new double[getOriginalNumDecisionVariables()];\n+      Integer negativeVarBasicRow = getBasicRowForSolution(getNegativeDecisionVariableOffset());\n+      double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n+      Set<Integer> basicRows = new HashSet<Integer>();\n+      for (int i = 0; i < coefficients.length; i++) {\n+          Integer basicRow = getBasicRowForSolution(getNumObjectiveFunctions() + i);\n+          if (basicRows.contains(basicRow)) {\n+              // if multiple variables can take a given value \n+              // then we choose the first and set the rest equal to 0\n+              coefficients[i] = 0;\n+          } else {\n+              basicRows.add(basicRow);\n+              coefficients[i] =\n+                  (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n+                  (restrictToNonNegative ? 0 : mostNegative);\n+          }\n+      }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n@@ -430,6 +448,15 @@\n     protected final int getRhsOffset() {\n         return getWidth() - 1;\n     }\n+    \n+    /**\n+     * Returns the offset of the extra decision variable added when there is a\n+     * negative decision variable in the original problem.\n+     * @return the offset of x-\n+     */\n+    protected final int getNegativeDecisionVariableOffset() {\n+      return getNumObjectiveFunctions() + getOriginalNumDecisionVariables();\n+    }\n \n     /**\n      * Get the number of decision variables.\n\n"
    },
    "Math-45": {
        "Buggy Function": "    public OpenMapRealMatrix(int rowDimension, int columnDimension) {\n        super(rowDimension, columnDimension);\n        this.rows = rowDimension;\n        this.columns = columnDimension;\n        this.entries = new OpenIntToDoubleHashMap(0.0);\n    }",
        "Inducing Changes": "diff --git a/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatingFunction.java b/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatingFunction.java\nindex e50ef00..e4cae99 100644\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatingFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatingFunction.java\n@@ -18,7 +18,8 @@\n \n import org.apache.commons.math.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.NoDataException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.DimensionMismatchException;\n import org.apache.commons.math.analysis.BivariateRealFunction;\n@@ -85,8 +86,9 @@\n      * every grid point.\n      * @throws DimensionMismatchException if the various arrays do not contain\n      * the expected number of elements.\n-     * @throws IllegalArgumentException if {@code x} or {@code y} are not strictly\n+     * @throws NonMonotonousSequenceException if {@code x} or {@code y} are not strictly\n      * increasing.\n+     * @throws NoDataException if any of the arrays has zero length.\n      */\n     public BicubicSplineInterpolatingFunction(double[] x,\n                                               double[] y,\n@@ -99,7 +101,7 @@\n         final int yLen \u003d y.length;\n \n         if (xLen \u003d\u003d 0 || yLen \u003d\u003d 0 || f.length \u003d\u003d 0 || f[0].length \u003d\u003d 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NO_DATA);\n+            throw new NoDataException();\n         }\n         if (xLen !\u003d f.length) {\n             throw new DimensionMismatchException(xLen, f.length);\n@@ -158,15 +160,11 @@\n     public double value(double x, double y) {\n         final int i \u003d searchIndex(x, xval);\n         if (i \u003d\u003d -1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n-                  x, xval[0], xval[xval.length - 1]);\n+            throw new OutOfRangeException(x, xval[0], xval[xval.length - 1]);\n         }\n         final int j \u003d searchIndex(y, yval);\n         if (j \u003d\u003d -1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n-                  y, yval[0], yval[yval.length - 1]);\n+            throw new OutOfRangeException(y, yval[0], yval[yval.length - 1]);\n         }\n \n         final double xN \u003d (x - xval[i]) / (xval[i + 1] - xval[i]);\n@@ -233,13 +231,11 @@\n \n         final int i \u003d searchIndex(x, xval);\n         if (i \u003d\u003d -1) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n-                                                                      x, xval[0], xval[xval.length - 1]);\n+            throw new OutOfRangeException(x, xval[0], xval[xval.length - 1]);\n         }\n         final int j \u003d searchIndex(y, yval);\n         if (j \u003d\u003d -1) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n-                                                                      y, yval[0], yval[yval.length - 1]);\n+            throw new OutOfRangeException(y, yval[0], yval[yval.length - 1]);\n         }\n \n         final double xN \u003d (x - xval[i]) / (xval[i + 1] - xval[i]);\n@@ -376,12 +372,10 @@\n      */\n     public double value(double x, double y) {\n         if (x \u003c 0 || x \u003e 1) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n-                                                                      x, 0, 1);\n+            throw new OutOfRangeException(x, 0, 1);\n         }\n         if (y \u003c 0 || y \u003e 1) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n-                                                                      y, 0, 1);\n+            throw new OutOfRangeException(y, 0, 1);\n         }\n \n         final double x2 \u003d x * x;\ndiff --git a/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolator.java b/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolator.java\nindex 5a9dad5..10c85e1 100644\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolator.java\n@@ -17,7 +17,7 @@\n package org.apache.commons.math.analysis.interpolation;\n \n import org.apache.commons.math.DimensionMismatchException;\n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n@@ -40,7 +40,7 @@\n                                                           final double[][] fval)\n         throws MathException, IllegalArgumentException {\n         if (xval.length \u003d\u003d 0 || yval.length \u003d\u003d 0 || fval.length \u003d\u003d 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NO_DATA);\n+            throw new NoDataException();\n         }\n         if (xval.length !\u003d fval.length) {\n             throw new DimensionMismatchException(xval.length, fval.length);\ndiff --git a/src/main/java/org/apache/commons/math/analysis/interpolation/LinearInterpolator.java b/src/main/java/org/apache/commons/math/analysis/interpolation/LinearInterpolator.java\nindex f7b6c21..11e2148 100644\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/LinearInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/LinearInterpolator.java\n@@ -16,10 +16,11 @@\n  */\n package org.apache.commons.math.analysis.interpolation;\n \n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;\n-import org.apache.commons.math.util.LocalizedFormats;\n+import org.apache.commons.math.util.MathUtils;\n \n /**\n  * Implements a linear function for interpolation of real univariate functions.\n@@ -30,28 +31,26 @@\n      * @param x the arguments for the interpolation points\n      * @param y the values for the interpolation points\n      * @return a function which interpolates the data set\n-    */\n+     * @throws DimensionMismatchException if {@code x} and {@code y}\n+     * have different sizes.\n+     * @throws NonMonotonousSequenceException if {@code x} is not sorted in\n+     * strict increasing order.\n+     * @throws NumberIsTooSmallException if the size of {@code x} is smaller\n+     * than 2.\n+     */\n     public PolynomialSplineFunction interpolate(double x[], double y[]) {\n         if (x.length !\u003d y.length) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, x.length, y.length);\n+            throw new DimensionMismatchException(x.length, y.length);\n         }\n \n         if (x.length \u003c 2) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.WRONG_NUMBER_OF_POINTS, 2, x.length);\n+            throw new NumberIsTooSmallException(x.length, 2, true);\n         }\n \n         // Number of intervals.  The number of data points is n + 1.\n         int n \u003d x.length - 1;\n \n-        for (int i \u003d 0; i \u003c n; i++) {\n-            if (x[i] \u003e\u003d x[i + 1]) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                LocalizedFormats.NOT_STRICTLY_INCREASING_NUMBER_OF_POINTS,\n-                i, i+1, x[i], x[i+1]);\n-            }\n-        }\n+        MathUtils.checkOrder(x);\n \n         // Slope of the lines between the datapoints.\n         final double m[] \u003d new double[n];\ndiff --git a/src/main/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolatingFunction.java b/src/main/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolatingFunction.java\nindex bf10172..0e7d824 100644\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolatingFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolatingFunction.java\n@@ -22,7 +22,7 @@\n import java.util.Map;\n \n import org.apache.commons.math.DimensionMismatchException;\n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.linear.ArrayRealVector;\n import org.apache.commons.math.linear.RealVector;\n@@ -142,7 +142,7 @@\n      * {@code xval} (equal to {@code n}, the number of interpolation points)\n      * do not match, or the the arrays {@code xval[0]} ... {@code xval[n]},\n      * have lengths different from {@code dimension}.\n-     * @throws IllegalArgumentException if there are no data (xval null or zero length)\n+     * @throws NoDataException if there are no data (xval null or zero length)\n      */\n     public MicrosphereInterpolatingFunction(double[][] xval,\n                                             double[] yval,\n@@ -151,7 +151,7 @@\n                                             UnitSphereRandomVectorGenerator rand)\n         throws DimensionMismatchException, IllegalArgumentException {\n         if (xval.length \u003d\u003d 0 || xval[0] \u003d\u003d null) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NO_DATA);\n+            throw new NoDataException();\n         }\n \n         if (xval.length !\u003d yval.length) {\ndiff --git a/src/main/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolator.java b/src/main/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolator.java\nindex d909aed..d8872c7 100644\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolator.java\n@@ -17,7 +17,8 @@\n package org.apache.commons.math.analysis.interpolation;\n \n import org.apache.commons.math.MathException;\n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.NotPositiveException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.random.UnitSphereRandomVectorGenerator;\n import org.apache.commons.math.util.LocalizedFormats;\n@@ -25,7 +26,7 @@\n /**\n  * Interpolator that implements the algorithm described in\n  * \u003cem\u003eWilliam Dudziak\u003c/em\u003e\u0027s\n- * \u003ca href\u003d\"http://www.dudziak.com/microsphere.pdf\"\u003eMS thesis\u003c/a\u003e\n+ * \u003ca href\u003d\"http://www.dudziak.com/microsphere.pdf\"\u003eMS thesis\u003c/a\u003e.\n  * @since 2.1\n  *\n  * @version $Revision$ $Date$\n@@ -59,18 +60,17 @@\n      * #MicrosphereInterpolator(int, int)\n      * MicrosphereInterpolator(MicrosphereInterpolator.DEFAULT_MICROSPHERE_ELEMENTS,\n      * MicrosphereInterpolator.DEFAULT_BRIGHTNESS_EXPONENT)}.\u003c/p\u003e\n-     * weights of the sample data\n      */\n     public MicrosphereInterpolator() {\n         this(DEFAULT_MICROSPHERE_ELEMENTS, DEFAULT_BRIGHTNESS_EXPONENT);\n     }\n \n     /** Create a microsphere interpolator.\n-     * @param microsphereElements number of surface elements of the microsphere\n+     * @param microsphereElements number of surface elements of the microsphere.\n      * @param brightnessExponent exponent used in the power law that computes the\n-     * weights of the sample data\n-     * @throws IllegalArgumentException if {@code microsphereElements \u003c\u003d 0}\n-     * or {@code brightnessExponent \u003c 0}\n+     * weights of the sample data.\n+     * @throws NotPositiveException if {@code microsphereElements \u003c\u003d 0}\n+     * or {@code brightnessExponent \u003c 0}.\n      */\n     public MicrosphereInterpolator(final int microsphereElements,\n                                    final int brightnessExponent) {\n@@ -94,31 +94,26 @@\n \n     /**\n      * Set the brightness exponent.\n-     * @param brightnessExponent Exponent for computing the distance dimming\n+     * @param exponent Exponent for computing the distance dimming\n      * factor.\n-     * @throws IllegalArgumentException if {@code brightnessExponent \u003c 0}.\n+     * @throws NotPositiveException if {@code exponent \u003c 0}.\n      */\n-    public void setBrightnessExponent(final int brightnessExponent) {\n-        if (brightnessExponent \u003c 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                LocalizedFormats.NEGATIVE_BRIGHTNESS_EXPONENT,\n-                brightnessExponent);\n+    public void setBrightnessExponent(final int exponent) {\n+        if (exponent \u003c 0) {\n+            throw new NotPositiveException(exponent);\n         }\n-        this.brightnessExponent \u003d brightnessExponent;\n+        brightnessExponent \u003d exponent;\n     }\n \n     /**\n      * Set the number of microsphere elements.\n      * @param elements Number of surface elements of the microsphere.\n-     * @throws IllegalArgumentException if {@code microsphereElements \u003c\u003d 0}.\n+     * @throws NotStrictlyPositiveException if {@code elements \u003c\u003d 0}.\n      */\n     public void setMicropshereElements(final int elements) {\n-        if (microsphereElements \u003c 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                LocalizedFormats.NON_POSITIVE_MICROSPHERE_ELEMENTS,\n-                microsphereElements);\n+        if (elements \u003c\u003d 0) {\n+            throw new NotStrictlyPositiveException(elements);\n         }\n-        this.microsphereElements \u003d elements;\n+        microsphereElements \u003d elements;\n     }\n-\n }\ndiff --git a/src/main/java/org/apache/commons/math/analysis/interpolation/SplineInterpolator.java b/src/main/java/org/apache/commons/math/analysis/interpolation/SplineInterpolator.java\nindex d908228..288c6b9 100644\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/SplineInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/SplineInterpolator.java\n@@ -16,10 +16,11 @@\n  */\n package org.apache.commons.math.analysis.interpolation;\n \n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;\n-import org.apache.commons.math.util.LocalizedFormats;\n+import org.apache.commons.math.util.MathUtils;\n \n /**\n  * Computes a natural (also known as \"free\", \"unclamped\") cubic spline interpolation for the data set.\n@@ -55,28 +56,26 @@\n      * @param x the arguments for the interpolation points\n      * @param y the values for the interpolation points\n      * @return a function which interpolates the data set\n+     * @throws DimensionMismatchException if {@code x} and {@code y}\n+     * have different sizes.\n+     * @throws NonMonotonousSequenceException if {@code x} is not sorted in\n+     * strict increasing order.\n+     * @throws NumberIsTooSmallException if the size of {@code x} is smaller\n+     * than 3.\n      */\n     public PolynomialSplineFunction interpolate(double x[], double y[]) {\n         if (x.length !\u003d y.length) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, x.length, y.length);\n+            throw new DimensionMismatchException(x.length, y.length);\n         }\n \n         if (x.length \u003c 3) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.WRONG_NUMBER_OF_POINTS, 3, x.length);\n+            throw new NumberIsTooSmallException(x.length, 3, true);\n         }\n \n         // Number of intervals.  The number of data points is n + 1.\n         int n \u003d x.length - 1;\n \n-        for (int i \u003d 0; i \u003c n; i++) {\n-            if (x[i] \u003e\u003d x[i + 1]) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                      LocalizedFormats.NOT_STRICTLY_INCREASING_NUMBER_OF_POINTS,\n-                      i, i+1, x[i], x[i+1]);\n-            }\n-        }\n+        MathUtils.checkOrder(x);\n \n         // Differences between knot points\n         double h[] \u003d new double[n];\ndiff --git a/src/main/java/org/apache/commons/math/exception/NotPositiveException.java b/src/main/java/org/apache/commons/math/exception/NotPositiveException.java\nindex 2513814..bf24ebd 100644\n--- a/src/main/java/org/apache/commons/math/exception/NotPositiveException.java\n+++ b/src/main/java/org/apache/commons/math/exception/NotPositiveException.java\n@@ -24,13 +24,13 @@\n  * @since 2.2\n  * @version $Revision$ $Date$\n  */\n-public class NotPositiveException extends MathIllegalNumberException {\n+public class NotPositiveException extends NumberIsTooSmallException {\n     /**\n      * Construct the exception.\n      *\n      * @param value Argument.\n      */\n     public NotPositiveException(Number value) {\n-        super(LocalizedFormats.NOT_POSITIVE, value);\n+        super(value, 0, true);\n     }\n }\ndiff --git a/src/main/java/org/apache/commons/math/exception/NotStrictlyPositiveException.java b/src/main/java/org/apache/commons/math/exception/NotStrictlyPositiveException.java\nindex b2f4229..3b5af31 100644\n--- a/src/main/java/org/apache/commons/math/exception/NotStrictlyPositiveException.java\n+++ b/src/main/java/org/apache/commons/math/exception/NotStrictlyPositiveException.java\n@@ -24,13 +24,13 @@\n  * @since 2.2\n  * @version $Revision$ $Date$\n  */\n-public class NotStrictlyPositiveException extends MathIllegalNumberException {\n+public class NotStrictlyPositiveException extends NumberIsTooSmallException {\n     /**\n      * Construct the exception.\n      *\n      * @param value Argument.\n      */\n     public NotStrictlyPositiveException(Number value) {\n-        super(LocalizedFormats.NOT_STRICTLY_POSITIVE, value);\n+        super(value, 0, false);\n     }\n }\ndiff --git a/src/main/java/org/apache/commons/math/util/LocalizedFormats.java b/src/main/java/org/apache/commons/math/util/LocalizedFormats.java\nindex 2334d40..c3bd9e5 100644\n--- a/src/main/java/org/apache/commons/math/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math/util/LocalizedFormats.java\n@@ -166,8 +166,6 @@\n     NOT_INCREASING_NUMBER_OF_POINTS(\"points {0} and {1} are not increasing ({2} \u003e {3})\"),\n     NOT_INCREASING_SEQUENCE(\"points {3} and {2} are not increasing ({1} \u003e {0})\"), /* keep */\n     NOT_MULTIPLICATION_COMPATIBLE_MATRICES(\"{0}x{1} and {2}x{3} matrices are not multiplication compatible\"),\n-    NOT_STRICTLY_POSITIVE(\"{0} is not strictly positive\"), /* keep */\n-    NOT_POSITIVE(\"{0} is not positive\"), /* keep */\n     NOT_POSITIVE_ALPHA(\"alpha must be positive ({0})\"),\n     NOT_POSITIVE_BETA(\"beta must be positive ({0})\"),\n     NOT_POSITIVE_COLUMNDIMENSION(\"invalid column dimension: {0} (must be positive)\"),\n@@ -219,6 +217,10 @@\n     NULL_OBJECT_TRANSFORMATION(\"Conversion Exception in Transformation, Object is null\"),\n     NULL_REAL_FORMAT(\"null real format\"),\n     NULL_WHOLE_FORMAT(\"whole format can not be null\"),\n+    NUMBER_TOO_LARGE(\"{0} is larger than the maximum ({1})\"), /* keep */\n+    NUMBER_TOO_SMALL(\"{0} is smaller than the minimum ({1})\"), /* keep */\n+    NUMBER_TOO_LARGE_BOUND_EXCLUDED(\"{0} is larger than, or equal to, the maximum ({1})\"), /* keep */\n+    NUMBER_TOO_SMALL_BOUND_EXCLUDED(\"{0} is smaller than, or equal to, the minimum ({1})\"), /* keep */\n     NUMBER_OF_SUCCESS_LARGER_THAN_POPULATION_SIZE(\"number of successes ({0}) must be less than or equal to population size ({1})\"),\n     NUMERATOR_OVERFLOW_AFTER_MULTIPLY(\"overflow, numerator too large after multiply: {0}\"),\n     N_POINTS_GAUSS_LEGENDRE_INTEGRATOR_NOT_SUPPORTED(\"{0} points Legendre-Gauss integrator not supported, number of points must be in the {1}-{2} range\"),\n"
    },
    "Math-46": {
        "Buggy Function": "public Complex divide(Complex divisor)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(divisor);\n    if (isNaN || divisor.isNaN) {\n        return NaN;\n    }\n\n    if (divisor.isZero) {\n        return isZero ? NaN : INF;\n    }\n\n    if (divisor.isInfinite() && !isInfinite()) {\n        return ZERO;\n    }\n\n    final double c = divisor.getReal();\n    final double d = divisor.getImaginary();\n\n    if (FastMath.abs(c) < FastMath.abs(d)) {\n        double q = c / d;\n        double denominator = c * q + d;\n        return createComplex((real * q + imaginary) / denominator,\n            (imaginary * q - real) / denominator);\n    } else {\n        double q = d / c;\n        double denominator = d * q + c;\n        return createComplex((imaginary * q + real) / denominator,\n            (imaginary - real * q) / denominator);\n    }\n}\npublic Complex divide(double divisor) {\n    if (isNaN || Double.isNaN(divisor)) {\n        return NaN;\n    }\n    if (divisor == 0d) {\n        return isZero ? NaN : INF;\n    }\n    if (Double.isInfinite(divisor)) {\n        return !isInfinite() ? ZERO : NaN;\n    }\n    return createComplex(real / divisor,\n                         imaginary  / divisor);\n}",
        "Inducing Changes": "diff --git a/src/main/java/org/apache/commons/math/complex/Complex.java b/src/main/java/org/apache/commons/math/complex/Complex.java\nindex ac31e4b..137765c 100644\n--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n@@ -78,6 +78,8 @@\n     private final transient boolean isNaN;\n     /** Record whether this complex number is infinite. */\n     private final transient boolean isInfinite;\n+    /** Record whether this complex number is zero. */\n+    private final transient boolean isZero;\n \n     /**\n      * Create a complex number given only the real part.\n@@ -101,6 +103,7 @@\n         isNaN = Double.isNaN(real) || Double.isNaN(imaginary);\n         isInfinite = !isNaN &&\n             (Double.isInfinite(real) || Double.isInfinite(imaginary));\n+        isZero = real == 0 && imaginary == 0;\n     }\n \n     /**\n@@ -222,7 +225,10 @@\n      *  <li>If either {@code this} or {@code divisor} has a {@code NaN} value\n      *   in either part, {@link #NaN} is returned.\n      *  </li>\n-     *  <li>If {@code divisor} equals {@link #ZERO}, {@link #NaN} is returned.\n+     *  <li>If {@code this} and {@code divisor} are both {@link #ZERO},\n+     *   {@link #NaN} is returned.\n+     *  </li>\n+     *  <li>If {@code divisor} equals {@link #ZERO}, {@link #INF} is returned.\n      *  </li>\n      *  <li>If {@code this} and {@code divisor} are both infinite,\n      *   {@link #NaN} is returned.\n@@ -249,16 +255,17 @@\n             return NaN;\n         }\n \n-        final double c = divisor.getReal();\n-        final double d = divisor.getImaginary();\n-        if (c == 0.0 && d == 0.0) {\n-            return NaN;\n+        if (divisor.isZero) {\n+            return isZero ? NaN : INF;\n         }\n \n         if (divisor.isInfinite() && !isInfinite()) {\n             return ZERO;\n         }\n \n+        final double c = divisor.getReal();\n+        final double d = divisor.getImaginary();\n+\n         if (FastMath.abs(c) < FastMath.abs(d)) {\n             double q = c / d;\n             double denominator = c * q + d;\n@@ -285,7 +292,7 @@\n             return NaN;\n         }\n         if (divisor == 0d) {\n-            return NaN;\n+            return isZero ? NaN : INF;\n         }\n         if (Double.isInfinite(divisor)) {\n             return !isInfinite() ? ZERO : NaN;\n\n"
    },
    "Math-48": {
        "Buggy Function": "    protected final double doSolve() {\n        // Get initial solution\n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n\n        // If one of the bounds is the exact root, return it. Since these are\n        // not under-approximations or over-approximations, we can return them\n        // regardless of the allowed solutions.\n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n\n        // Verify bracketing of initial solution.\n        verifyBracketing(x0, x1);\n\n        // Get accuracies.\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n\n        // Keep track of inverted intervals, meaning that the left bound is\n        // larger than the right bound.\n        boolean inverted = false;\n\n        // Keep finding better approximations.\n        while (true) {\n            // Calculate the next approximation.\n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n\n            // If the new approximation is the exact root, return it. Since\n            // this is not an under-approximation or an over-approximation,\n            // we can return it regardless of the allowed solutions.\n            if (fx == 0.0) {\n                return x;\n            }\n\n            // Update the bounds with the new approximation.\n            if (f1 * fx < 0) {\n                // The value of x1 has switched to the other bound, thus inverting\n                // the interval.\n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    // Detect early that algorithm is stuck, instead of waiting\n                    // for the maximum number of iterations to be exceeded.\n                    break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n                }\n            }\n            // Update from [x0, x1] to [x0, x].\n            x1 = x;\n            f1 = fx;\n\n            // If the function value of the last approximation is too small,\n            // given the function value accuracy, then we can't get closer to\n            // the root than we already are.\n            if (FastMath.abs(f1) <= ftol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n\n            // If the current interval is within the given accuracies, we\n            // are satisfied with the current approximation.\n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                     atol)) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n        }\n    }",
        "Inducing Changes": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/RegulaFalsiSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/RegulaFalsiSolver.java\nindex 2b310f1..949e3e9 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/RegulaFalsiSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/RegulaFalsiSolver.java\n@@ -35,7 +35,7 @@\n  * @since 3.0\n  * @version $Id$\n  */\n-public class RegulaFalsiSolver extends SecantBase implements BracketedSolution {\n+public class RegulaFalsiSolver extends BaseBracketedSecantSolver {\n     /** Construct a solver with default accuracy (1e-6). */\n     public RegulaFalsiSolver() {\n         super(DEFAULT_ABSOLUTE_ACCURACY, Method.REGULA_FALSI);\n@@ -60,14 +60,4 @@\n                              final double absoluteAccuracy) {\n         super(relativeAccuracy, absoluteAccuracy, Method.REGULA_FALSI);\n     }\n-\n-    /** {@inheritDoc} */\n-    public AllowedSolutions getAllowedSolutions() {\n-        return allowedSolutions;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setAllowedSolutions(final AllowedSolutions allowedSolutions) {\n-        this.allowedSolutions = allowedSolutions;\n-    }\n }\n\n"
    },
    "Math-50": {
        "Buggy Function": "    protected final double doSolve() {\n        // Get initial solution\n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n\n        // If one of the bounds is the exact root, return it. Since these are\n        // not under-approximations or over-approximations, we can return them\n        // regardless of the allowed solutions.\n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n\n        // Verify bracketing of initial solution.\n        verifyBracketing(x0, x1);\n\n        // Get accuracies.\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n\n        // Keep track of inverted intervals, meaning that the left bound is\n        // larger than the right bound.\n        boolean inverted = false;\n\n        // Keep finding better approximations.\n        while (true) {\n            // Calculate the next approximation.\n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n\n            // If the new approximation is the exact root, return it. Since\n            // this is not an under-approximation or an over-approximation,\n            // we can return it regardless of the allowed solutions.\n            if (fx == 0.0) {\n                return x;\n            }\n\n            // Update the bounds with the new approximation.\n            if (f1 * fx < 0) {\n                // The value of x1 has switched to the other bound, thus inverting\n                // the interval.\n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    // Nothing.\n                    if (x == x1) {\n                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                        f0 = computeObjectiveValue(x0);\n                    }\n                    break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n                }\n            }\n            // Update from [x0, x1] to [x0, x].\n            x1 = x;\n            f1 = fx;\n\n            // If the function value of the last approximation is too small,\n            // given the function value accuracy, then we can't get closer to\n            // the root than we already are.\n            if (FastMath.abs(f1) <= ftol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n\n            // If the current interval is within the given accuracies, we\n            // are satisfied with the current approximation.\n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                     atol)) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n        }\n    }",
        "Inducing Changes": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\nindex fde7172..b3a23a1 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n@@ -169,25 +169,37 @@\n \n             // Update the bounds with the new approximation.\n             if (f1 * fx < 0) {\n-                // We had [x0..x1]. We update it to [x1, x]. Note that the\n-                // value of x1 has switched to the other bound, thus inverting\n+                // The value of x1 has switched to the other bound, thus inverting\n                 // the interval.\n                 x0 = x1;\n                 f0 = f1;\n-                x1 = x;\n-                f1 = fx;\n                 inverted = !inverted;\n             } else {\n-                // We had [x0..x1]. We update it to [x0, x].\n-                if (method == Method.ILLINOIS) {\n+                switch (method) {\n+                case ILLINOIS:\n                     f0 *= 0.5;\n-                }\n-                if (method == Method.PEGASUS) {\n+                    break;\n+                case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n+                    break;\n+                case REGULA_FALSI:\n+                    if (x == x1) {\n+                        final double delta = FastMath.max(rtol * FastMath.abs(x1),\n+                                                          atol);\n+                        // Update formula cannot make any progress: Update the\n+                        // search interval.\n+                        x0 = 0.5 * (x0 + x1 - delta);\n+                        f0 = computeObjectiveValue(x0);\n+                    }\n+                    break;\n+                default:\n+                    // Should never happen.\n+                    throw new MathInternalError();\n                 }\n-                x1 = x;\n-                f1 = fx;\n             }\n+            // Update from [x0, x1] to [x0, x].\n+            x1 = x;\n+            f1 = fx;\n \n             // If the function value of the last approximation is too small,\n             // given the function value accuracy, then we can't get closer to\n\n"
    },
    "Math-53": {
        "Buggy Function": "    public Complex add(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        return createComplex(real + rhs.getReal(),\n            imaginary + rhs.getImaginary());\n    }",
        "Inducing Changes": "diff --git a/src/java/org/apache/commons/math/complex/Complex.java b/src/java/org/apache/commons/math/complex/Complex.java\nindex 83eb19d..a3bdb3a 100644\n--- a/src/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/java/org/apache/commons/math/complex/Complex.java\n@@ -29,28 +39,31 @@\n public class Complex implements Serializable  {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -6530173849413811929L;\n+    private static final long serialVersionUID = -6530173849413811929L;\n     \n-    /** The square root of -1. A number representing \"0.0 + 1.0i\".*/    \n+    /** The square root of -1. A number representing \"0.0 + 1.0i\" */    \n     public static final Complex I = new Complex(0.0, 1.0);\n     \n-    /** A complex number analogous to {@link java.lang.Double#NaN} */\n+    /** A complex number representing \"NaN + NaNi\" */\n     public static final Complex NaN = new Complex(Double.NaN, Double.NaN);\n \n     /** A complex number representing \"1.0 + 0.0i\" */    \n     public static final Complex ONE = new Complex(1.0, 0.0);\n     \n-    /** The imaginary part. */\n+    /** A complex number representing \"0.0 + 0.0i\" */    \n+    public static final Complex ZERO = new Complex(0.0, 0.0);\n+    \n+    /** The imaginary part */\n     protected double imaginary;\n     \n-    /** The real part. */\n+    /** The real part */\n     protected double real;\n     \n     /**\n      * Create a complex number given the real and imaginary parts.\n      *\n-     * @param real the real part.\n-     * @param imaginary the imaginary part.\n+     * @param real the real part\n+     * @param imaginary the imaginary part\n      */\n     public Complex(double real, double imaginary) {\n         super();\n@@ -60,13 +73,23 @@\n \n     /**\n      * Return the absolute value of this complex number.\n+     * <p>\n+     * Returns <code>NaN</code> if either real or imaginary part is\n+     * <code>NaN</code> and <code>Double.POSITIVE_INFINITY</code> if\n+     * neither part is <code>NaN</code>, but at least one part takes an infinite\n+     * value.\n      *\n-     * @return the absolute value.\n+     * @return the absolute value\n      */\n     public double abs() {\n         if (isNaN()) {\n             return Double.NaN;\n         }\n+        \n+        if (isInfinite()) {\n+            return Double.POSITIVE_INFINITY;\n+        }\n+        \n         if (Math.abs(real) < Math.abs(imaginary)) {\n             if (imaginary == 0.0) {\n                 return Math.abs(real);\n@@ -84,38 +107,81 @@\n     \n     /**\n      * Return the sum of this complex number and the given complex number.\n+     * <p>\n+     * Uses the definitional formula \n+     * <pre>\n+     * (a + bi) + (c + di) = (a+c) + (b+d)i\n+     * </pre>\n+     * <p>\n+     * If either this or <code>rhs</code> has a NaN value in either part,\n+     * {@link #NaN} is returned; otherwise Inifinite and NaN values are\n+     * returned in the parts of the result according to the rules for\n+     * {@link java.lang.Double} arithmetic. \n      *\n-     * @param rhs the other complex number.\n-     * @return the complex number sum.\n+     * @param rhs the other complex number\n+     * @return the complex number sum\n+     * @throws NullPointerException if <code>rhs</code> is null\n      */\n-    public Complex add(Complex rhs) {\n-        if (isNaN() || rhs.isNaN()) {\n-            return NaN;\n-        }\n-        \n+    public Complex add(Complex rhs) {   \n         return new Complex(real + rhs.getReal(),\n             imaginary + rhs.getImaginary());\n     }\n     \n     /**\n-     * Return the conjugate of this complex number.  The conjugate of\n-     * \"A + Bi\" is \"A - Bi\".  Complex.NaN is returned if either the real or imaginary part of \n-     * this Complex number equals Double.NaN.\n+     * Return the conjugate of this complex number. The conjugate of\n+     * \"A + Bi\" is \"A - Bi\". \n+     * <p>\n+     * {@link #NaN} is returned if either the real or imaginary\n+     * part of this Complex number equals <code>Double.NaN</code>.\n+     * <p>\n+     * If the imaginary part is infinite, and the real part is not NaN, \n+     * the returned value has infinite imaginary part of the opposite\n+     * sign - e.g. the conjugate of <code>1 + POSITIVE_INFINITY i</code>\n+     * is <code>1 - NEGATIVE_INFINITY i</code>\n      *\n      * @return the conjugate of this Complex object\n      */\n     public Complex conjugate() {\n         if (isNaN()) {\n             return NaN;\n-        }\n-        \n+        }   \n         return new Complex(real, -imaginary);\n     }\n     \n     /**\n      * Return the quotient of this complex number and the given complex number.\n-     * @param rhs the other complex number.\n-     * @return the complex number quotient.\n+     * <p>\n+     * Implements the definitional formula\n+     * <pre><code>\n+     *    a + bi          ac + bd + (bc - ad)i\n+     *    ----------- = -------------------------\n+     *    c + di               c<sup>2</sup> + d<sup>2</sup>\n+     * </code></pre>\n+     * but uses \n+     * <a href=\"http://doi.acm.org/10.1145/1039813.1039814\">\n+     * prescaling of operands</a> to limit the effects of overflows and\n+     * underflows in the computation.\n+     * <p>\n+     * Infinite and NaN values are handled / returned according to the\n+     * following rules, applied in the order presented:\n+     * <ul>\n+     * <li>If either this or <code>rhs</code> has a NaN value in either part,\n+     *  {@link #NaN} is returned.</li>\n+     * <li>If <code>rhs</code> equals {@link #ZERO}, {@link #NaN} is returned.\n+     * </li>\n+     * <li>If this and <code>rhs</code> are both infinite,\n+     * {@link #NaN} is returned.</li>\n+     * <li>If this is finite (i.e., has no infinite or NaN parts) and\n+     *  <code>rhs</code> is infinite (one or both parts infinite), \n+     * {@link #ZERO} is returned.</li>\n+     * <li>If this is infinite and <code>rhs</code> is finite, NaN values are\n+     * returned in the parts of the result if the {@link java.lang.Double}\n+     * rules applied to the definitional formula force NaN results.</li>\n+     * </ul>\n+     * \n+     * @param rhs the other complex number\n+     * @return the complex number quotient\n+     * @throws NullPointerException if <code>rhs</code> is null\n      */\n     public Complex divide(Complex rhs) {\n         if (isNaN() || rhs.isNaN()) {\n@@ -125,7 +191,11 @@\n         double c = rhs.getReal();\n         double d = rhs.getImaginary();\n         if (c == 0.0 && d == 0.0) {\n-            throw new ArithmeticException(\"Error: division by zero.\");\n+            return NaN;\n+        }\n+        \n+        if (rhs.isInfinite() && !isInfinite()) {\n+            return ZERO;\n         }\n \n         if (Math.abs(c) < Math.abs(d)) {\n@@ -156,13 +226,13 @@\n      * <p>\n      * All <code>NaN</code> values are considered to be equal - i.e, if either\n      * (or both) real and imaginary parts of the complex number are equal\n-     * to Double.NaN, the complex number is equal to \n+     * to <code>Double.NaN</code>, the complex number is equal to \n      * <code>Complex.NaN</code>.\n      *\n      * @param other Object to test for equality to this\n      * @return true if two Complex objects are equal, false if\n      *         object is null, not an instance of Complex, or\n-     *         not equal to this Complex instance.\n+     *         not equal to this Complex instance\n      * \n      */\n     public boolean equals(Object other) {\n@@ -210,7 +280,7 @@\n     /**\n      * Access the imaginary part.\n      *\n-     * @return the imaginary part.\n+     * @return the imaginary part\n      */\n     public double getImaginary() {\n         return imaginary;\n@@ -219,44 +289,76 @@\n     /**\n      * Access the real part.\n      *\n-     * @return the real part.\n+     * @return the real part\n      */\n     public double getReal() {\n         return real;\n     }\n     \n     /**\n-     * Returns true if this complex number is the special Not-a-Number (NaN)\n-     * value.\n+     * Returns true if either or both parts of this complex number is NaN;\n+     * false otherwise\n      *\n-     * @return true if the value represented by this object is NaN; false\n-     *         otherwise.\n+     * @return  true if either or both parts of this complex number is NaN;\n+     * false otherwise\n      */\n     public boolean isNaN() {\n         return Double.isNaN(real) || Double.isNaN(imaginary);        \n     }\n     \n     /**\n+     * Returns true if either the real or imaginary part of this complex number\n+     * takes an infinite value (either <code>Double.POSITIVE_INFINITY</code> or \n+     * <code>Double.NEGATIVE_INFINITY</code>) and neither part\n+     * is <code>NaN</code>.\n+     * \n+     * @return true if one or both parts of this complex number are infinite\n+     * and neither part is <code>NaN</code>\n+     */\n+    public boolean isInfinite() {\n+        return !isNaN() && \n+        (Double.isInfinite(real) || Double.isInfinite(imaginary));        \n+    }\n+    \n+    /**\n      * Return the product of this complex number and the given complex number.\n-     *\n-     * @param rhs the other complex number.\n-     * @return the complex number product.\n+     * <p>\n+     * Implements the definitional formula:\n+     * <pre><code>\n+     * (a + bi)(c + di) = (ac - bd) + (ad + bc)i\n+     * </code></pre>\n+     * <p>\n+     * Returns {@link #NaN} if either this or <code>rhs</code> has one or more\n+     * NaN parts.\n+     * <p>\n+     * Returns NaN or infinite values in components of the result per the\n+     * definitional formula and and the rules for {@link java.lang.Double}\n+     * arithmetic.  Examples:\n+     * <pre><code>\n+     *  (1 + i) (INF + i)  =  INF + INFi\n+     *  (1 + INFi) (1 - INFi) = INF + NaNi\n+     *  (-INF + -INFi)(1 + NaNi) = NaN + NaNi\n+     *  </code></pre>\n+     * \n+     * @param rhs the other complex number\n+     * @return the complex number product\n+     * @throws NullPointerException if <code>rhs</code> is null\n      */\n     public Complex multiply(Complex rhs) {\n         if (isNaN() || rhs.isNaN()) {\n             return NaN;\n         }\n-        \n-        double p = (real + imaginary) * (rhs.getReal() + rhs.getImaginary());\n-        double ac = real * rhs.getReal();\n-        double bd = imaginary * rhs.getImaginary();\n-        return new Complex(ac - bd, p - ac - bd);\n+        return new Complex(real * rhs.real - imaginary * rhs.imaginary,\n+                real * rhs.imaginary + imaginary * rhs.real);\n     }\n     \n     /**\n      * Return the additive inverse of this complex number.\n+     * <p>\n+     * Returns <code>Complex.NaN</code> if either real or imaginary\n+     * part of this Complex number equals <code>Double.NaN</code>.\n      *\n-     * @return the negation of this complex number.\n+     * @return the negation of this complex number\n      */\n     public Complex negate() {\n         if (isNaN()) {\n@@ -269,9 +371,20 @@\n     /**\n      * Return the difference between this complex number and the given complex\n      * number.\n-     *\n-     * @param rhs the other complex number.\n-     * @return the complex number difference.\n+      * <p>\n+     * Uses the definitional formula \n+     * <pre>\n+     * (a + bi) - (c + di) = (a-c) + (b-d)i\n+     * </pre>\n+     * <p>\n+     * If either this or <code>rhs</code> has a NaN value in either part,\n+     * {@link #NaN} is returned; otherwise inifinite and NaN values are\n+     * returned in the parts of the result according to the rules for\n+     * {@link java.lang.Double} arithmetic. \n+     * \n+     * @param rhs the other complex number\n+     * @return the complex number difference\n+     * @throws NullPointerException if <code>rhs</code> is null\n      */\n     public Complex subtract(Complex rhs) {\n         if (isNaN() || rhs.isNaN()) {"
    },
    "Math-60": {
        "Buggy Function": "    public double cumulativeProbability(double x) throws MathException {\n        final double dev = x - mean;\n        try {\n        return 0.5 * (1.0 + Erf.erf((dev) /\n                    (standardDeviation * FastMath.sqrt(2.0))));\n        } catch (MaxIterationsExceededException ex) {\n            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n                return 0;\n            } else if (x > (mean + 20 * standardDeviation)) {\n                return 1;\n            } else {\n                throw ex;\n            }\n        }\n    }",
        "Inducing Changes": "diff --git a/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java b/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\nindex 010060c..e5bdce7 100644\n--- a/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n@@ -33,6 +33,9 @@\n public class NormalDistributionImpl extends AbstractContinuousDistribution\n         implements NormalDistribution, Serializable {\n \n+    /** Default inverse cumulative probability accuracy */\n+    public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = 8589540077390120676L;\n \n@@ -45,15 +48,31 @@\n     /** The standard deviation of this distribution. */\n     private double standardDeviation = 1;\n \n+    /** Inverse cumulative probability accuracy */\n+    private final double solverAbsoluteAccuracy;\n+\n     /**\n      * Create a normal distribution using the given mean and standard deviation.\n      * @param mean mean for this distribution\n      * @param sd standard deviation for this distribution\n      */\n     public NormalDistributionImpl(double mean, double sd){\n+        this(mean, sd, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n+    }\n+\n+    /**\n+     * Create a normal distribution using the given mean, standard deviation and\n+     * inverse cumulative distribution accuracy.\n+     *\n+     * @param mean mean for this distribution\n+     * @param sd standard deviation for this distribution\n+     * @param inverseCumAccuracy inverse cumulative probability accuracy\n+     */\n+    public NormalDistributionImpl(double mean, double sd, double inverseCumAccuracy) {\n         super();\n-        setMean(mean);\n-        setStandardDeviation(sd);\n+        this.mean = mean;\n+        this.standardDeviation = sd;\n+        solverAbsoluteAccuracy = inverseCumAccuracy;\n     }\n \n     /**\n@@ -137,6 +156,17 @@\n     }\n \n     /**\n+     * Return the absolute accuracy setting of the solver used to estimate\n+     * inverse cumulative probabilities.\n+     *\n+     * @return the solver absolute accuracy\n+     */\n+    @Override\n+    protected double getSolverAbsoluteAccuracy() {\n+        return solverAbsoluteAccuracy;\n+    }\n+\n+    /**\n      * For this distribution, X, this method returns the critical point x, such\n      * that P(X &lt; x) = <code>p</code>.\n      * <p>\n\n"
    },
    "Math-64": {
        "Buggy Function": "    protected VectorialPointValuePair doOptimize()\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        // arrays shared with the other private methods\n        solvedCols  = Math.min(rows, cols);\n        diagR       = new double[cols];\n        jacNorm     = new double[cols];\n        beta        = new double[cols];\n        permutation = new int[cols];\n        lmDir       = new double[cols];\n\n        // local point\n        double   delta   = 0;\n        double   xNorm   = 0;\n        double[] diag    = new double[cols];\n        double[] oldX    = new double[cols];\n        double[] oldRes  = new double[rows];\n        double[] work1   = new double[cols];\n        double[] work2   = new double[cols];\n        double[] work3   = new double[cols];\n\n        // evaluate the function at the starting point and calculate its norm\n        updateResidualsAndCost();\n\n        // outer loop\n        lmPar = 0;\n        boolean firstIteration = true;\n        VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n        while (true) {\n            incrementIterationsCounter();\n\n            // compute the Q.R. decomposition of the jacobian matrix\n            VectorialPointValuePair previous = current;\n            updateJacobian();\n            qrDecomposition();\n\n            // compute Qt.res\n            qTy(residuals);\n            // now we don't need Q anymore,\n            // so let jacobian contain the R matrix with its diagonal elements\n            for (int k = 0; k < solvedCols; ++k) {\n                int pk = permutation[k];\n                jacobian[k][pk] = diagR[pk];\n            }\n\n            if (firstIteration) {\n\n                // scale the point according to the norms of the columns\n                // of the initial jacobian\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double dk = jacNorm[k];\n                    if (dk == 0) {\n                        dk = 1.0;\n                    }\n                    double xk = dk * point[k];\n                    xNorm  += xk * xk;\n                    diag[k] = dk;\n                }\n                xNorm = Math.sqrt(xNorm);\n\n                // initialize the step bound delta\n                delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n\n            }\n\n            // check orthogonality between function vector and jacobian columns\n            double maxCosine = 0;\n            if (cost != 0) {\n                for (int j = 0; j < solvedCols; ++j) {\n                    int    pj = permutation[j];\n                    double s  = jacNorm[pj];\n                    if (s != 0) {\n                        double sum = 0;\n                        for (int i = 0; i <= j; ++i) {\n                            sum += jacobian[i][pj] * residuals[i];\n                        }\n                        maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                    }\n                }\n            }\n            if (maxCosine <= orthoTolerance) {\n                // convergence has been reached\n                return current;\n            }\n\n            // rescale if necessary\n            for (int j = 0; j < cols; ++j) {\n                diag[j] = Math.max(diag[j], jacNorm[j]);\n            }\n\n            // inner loop\n            for (double ratio = 0; ratio < 1.0e-4;) {\n\n                // save the state\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    oldX[pj] = point[pj];\n                }\n                double previousCost = cost;\n                double[] tmpVec = residuals;\n                residuals = oldRes;\n                oldRes    = tmpVec;\n\n                // determine the Levenberg-Marquardt parameter\n                determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n\n                // compute the new point and the norm of the evolution direction\n                double lmNorm = 0;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    lmDir[pj] = -lmDir[pj];\n                    point[pj] = oldX[pj] + lmDir[pj];\n                    double s = diag[pj] * lmDir[pj];\n                    lmNorm  += s * s;\n                }\n                lmNorm = Math.sqrt(lmNorm);\n                // on the first iteration, adjust the initial step bound.\n                if (firstIteration) {\n                    delta = Math.min(delta, lmNorm);\n                }\n\n                // evaluate the function at x + p and calculate its norm\n                updateResidualsAndCost();\n                current = new VectorialPointValuePair(point, objective);\n\n                // compute the scaled actual reduction\n                double actRed = -1.0;\n                if (0.1 * cost < previousCost) {\n                    double r = cost / previousCost;\n                    actRed = 1.0 - r * r;\n                }\n\n                // compute the scaled predicted reduction\n                // and the scaled directional derivative\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    double dirJ = lmDir[pj];\n                    work1[j] = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        work1[i] += jacobian[i][pj] * dirJ;\n                    }\n                }\n                double coeff1 = 0;\n                for (int j = 0; j < solvedCols; ++j) {\n                    coeff1 += work1[j] * work1[j];\n                }\n                double pc2 = previousCost * previousCost;\n                coeff1 = coeff1 / pc2;\n                double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n                double preRed = coeff1 + 2 * coeff2;\n                double dirDer = -(coeff1 + coeff2);\n\n                // ratio of the actual to the predicted reduction\n                ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n                // update the step bound\n                if (ratio <= 0.25) {\n                    double tmp =\n                        (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                        if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                            tmp = 0.1;\n                        }\n                        delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                        lmPar /= tmp;\n                } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                    delta = 2 * lmNorm;\n                    lmPar *= 0.5;\n                }\n\n                // test for successful iteration.\n                if (ratio >= 1.0e-4) {\n                    // successful iteration, update the norm\n                    firstIteration = false;\n                    xNorm = 0;\n                    for (int k = 0; k < cols; ++k) {\n                        double xK = diag[k] * point[k];\n                        xNorm    += xK * xK;\n                    }\n                    xNorm = Math.sqrt(xNorm);\n\n                    // tests for convergence.\n                    // we use the vectorial convergence checker\n                } else {\n                    // failed iteration, reset the previous values\n                    cost = previousCost;\n                    for (int j = 0; j < solvedCols; ++j) {\n                        int pj = permutation[j];\n                        point[pj] = oldX[pj];\n                    }\n                    tmpVec    = residuals;\n                    residuals = oldRes;\n                    oldRes    = tmpVec;\n                }\n                if (checker==null) {\n                \tif (((Math.abs(actRed) <= costRelativeTolerance) &&\n                        (preRed <= costRelativeTolerance) &&\n                        (ratio <= 2.0)) ||\n                       (delta <= parRelativeTolerance * xNorm)) {\n                       return current;\n                   }\n                } else {\n                    if (checker.converged(getIterations(), previous, current)) {\n                        return current;\n                    }\n                }\n                // tests for termination and stringent tolerances\n                // (2.2204e-16 is the machine epsilon for IEEE754)\n                if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                            costRelativeTolerance);\n                } else if (delta <= 2.2204e-16 * xNorm) {\n                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                            parRelativeTolerance);\n                } else if (maxCosine <= 2.2204e-16)  {\n                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                            orthoTolerance);\n                }\n\n            }\n\n        }\n\n    }",
        "Inducing Changes": "diff --git a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\nindex ea0f20d..28aee43 100644\n--- a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n@@ -34,8 +34,9 @@\n  *\n  * <p>The resolution engine is a simple translation of the MINPACK <a\n  * href=\"http://www.netlib.org/minpack/lmder.f\">lmder</a> routine with minor\n- * changes. The changes include the over-determined resolution and the Q.R.\n- * decomposition which has been rewritten following the algorithm described in the\n+ * changes. The changes include the over-determined resolution, the use of\n+ * inherited convergence checker and the Q.R. decomposition which has been\n+ * rewritten following the algorithm described in the\n  * P. Lascaux and R. Theodor book <i>Analyse num&eacute;rique matricielle\n  * appliqu&eacute;e &agrave; l'art de l'ing&eacute;nieur</i>, Masson 1986.</p>\n  * <p>The authors of the original fortran version are:\n@@ -143,6 +144,7 @@\n      * Build an optimizer for least squares problems.\n      * <p>The default values for the algorithm settings are:\n      *   <ul>\n+     *    <li>{@link #setConvergenceChecker vectorial convergence checker}: null</li>\n      *    <li>{@link #setInitialStepBoundFactor initial step bound factor}: 100.0</li>\n      *    <li>{@link #setMaxIterations maximal iterations}: 1000</li>\n      *    <li>{@link #setCostRelativeTolerance cost relative tolerance}: 1.0e-10</li>\n@@ -150,6 +152,10 @@\n      *    <li>{@link #setOrthoTolerance orthogonality tolerance}: 1.0e-10</li>\n      *   </ul>\n      * </p>\n+     * <p>These default values may be overridden after construction. If the {@link\n+     * #setConvergenceChecker vectorial convergence checker} is set to a non-null value, it\n+     * will be used instead of the {@link #setCostRelativeTolerance cost relative tolerance}\n+     * and {@link #setParRelativeTolerance parameters relative tolerance} settings.\n      */\n     public LevenbergMarquardtOptimizer() {\n \n@@ -157,6 +163,7 @@\n         setMaxIterations(1000);\n \n         // default values for the tuning parameters\n+        setConvergenceChecker(null);\n         setInitialStepBoundFactor(100.0);\n         setCostRelativeTolerance(1.0e-10);\n         setParRelativeTolerance(1.0e-10);\n@@ -179,7 +186,8 @@\n \n     /**\n      * Set the desired relative error in the sum of squares.\n-     *\n+     * <p>This setting is used only if the {@link #setConvergenceChecker vectorial\n+     * convergence checker} is set to null.</p>\n      * @param costRelativeTolerance desired relative error in the sum of squares\n      */\n     public void setCostRelativeTolerance(double costRelativeTolerance) {\n@@ -188,7 +196,8 @@\n \n     /**\n      * Set the desired relative error in the approximate solution parameters.\n-     *\n+     * <p>This setting is used only if the {@link #setConvergenceChecker vectorial\n+     * convergence checker} is set to null.</p>\n      * @param parRelativeTolerance desired relative error\n      * in the approximate solution parameters\n      */\n@@ -198,7 +207,8 @@\n \n     /**\n      * Set the desired max cosine on the orthogonality.\n-     *\n+     * <p>This setting is always used, regardless of the {@link #setConvergenceChecker\n+     * vectorial convergence checker} being null or non-null.</p>\n      * @param orthoTolerance desired max cosine on the orthogonality\n      * between the function vector and the columns of the jacobian\n      */\n@@ -235,11 +245,13 @@\n         // outer loop\n         lmPar = 0;\n         boolean firstIteration = true;\n+        VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n         while (true) {\n \n             incrementIterationsCounter();\n \n             // compute the Q.R. decomposition of the jacobian matrix\n+            VectorialPointValuePair previous = current;\n             updateJacobian();\n             qrDecomposition();\n \n@@ -291,7 +303,7 @@\n             }\n             if (maxCosine <= orthoTolerance) {\n                 // convergence has been reached\n-                return new VectorialPointValuePair(point, objective);\n+                return current;\n             }\n \n             // rescale if necessary\n@@ -333,6 +345,7 @@\n \n                 // evaluate the function at x + p and calculate its norm\n                 updateResidualsAndCost();\n+                current = new VectorialPointValuePair(point, objective);\n \n                 // compute the scaled actual reduction\n                 double actRed = -1.0;\n@@ -401,11 +414,19 @@\n                 }\n \n                 // tests for convergence.\n-                if (((Math.abs(actRed) <= costRelativeTolerance) &&\n-                        (preRed <= costRelativeTolerance) &&\n-                        (ratio <= 2.0)) ||\n+                if (checker != null) {\n+                    // we use the vectorial convergence checker\n+                    if (checker.converged(getIterations(), previous, current)) {\n+                        return current;                        \n+                    }\n+                } else {\n+                    // we use the Levenberg-Marquardt specific convergence parameters\n+                    if (((Math.abs(actRed) <= costRelativeTolerance) &&\n+                         (preRed <= costRelativeTolerance) &&\n+                         (ratio <= 2.0)) ||\n                         (delta <= parRelativeTolerance * xNorm)) {\n-                    return new VectorialPointValuePair(point, objective);\n+                        return current;\n+                    }\n                 }\n \n                 // tests for termination and stringent tolerances\n\n"
    },
    "Math-75": {
        "Buggy Function": "    public double getPct(Object v) {\n        return getCumPct((Comparable<?>) v);\n    }",
        "Inducing Changes": "diff --git a/src/java/org/apache/commons/math/stat/Frequency.java b/src/java/org/apache/commons/math/stat/Frequency.java\nindex bc5f826..34790ff 100644\n--- a/src/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/java/org/apache/commons/math/stat/Frequency.java\n@@ -27,7 +27,7 @@\n /** \n  * Maintains a frequency distribution.\n  * \u003cp\u003e\n- * Accepts int, long, char or Object values.  New values added must be \n+ * Accepts int, long, char or Comparable values.  New values added must be \n  * comparable to those that have been added, otherwise the add method will \n  * throw an IllegalArgumentException.\u003c/p\u003e\n  * \u003cp\u003e\n@@ -65,8 +65,9 @@\n      * \n      * @param comparator Comparator used to order values\n      */\n-    public Frequency(Comparator comparator) {\n-        freqTable \u003d new TreeMap\u003cComparable\u003c?\u003e, Long\u003e(comparator);\n+    @SuppressWarnings(\"unchecked\")\n+    public Frequency(Comparator\u003c?\u003e comparator) {\n+        freqTable \u003d new TreeMap\u003cComparable\u003c?\u003e, Long\u003e((Comparator\u003c? super Comparable\u003c?\u003e\u003e) comparator);\n     }\n \n     /**\n@@ -80,9 +81,9 @@\n         NumberFormat nf \u003d NumberFormat.getPercentInstance();\n         StringBuffer outBuffer \u003d new StringBuffer();\n         outBuffer.append(\"Value \\t Freq. \\t Pct. \\t Cum Pct. \\n\");\n-        Iterator\u003c?\u003e iter \u003d freqTable.keySet().iterator();\n+        Iterator\u003cComparable\u003c?\u003e\u003e iter \u003d freqTable.keySet().iterator();\n         while (iter.hasNext()) {\n-            Object value \u003d iter.next();\n+            Comparable\u003c?\u003e value \u003d iter.next();\n             outBuffer.append(value);\n             outBuffer.append(\u0027\\t\u0027);\n             outBuffer.append(getCount(value));\n@@ -211,9 +212,9 @@\n      */\n     public long getSumFreq() {\n         long result \u003d 0;\n-        Iterator\u003c?\u003e iterator \u003d freqTable.values().iterator();\n+        Iterator\u003cLong\u003e iterator \u003d freqTable.values().iterator();\n         while (iterator.hasNext())  {\n-            result +\u003d ((Long) iterator.next()).longValue();\n+            result +\u003d iterator.next().longValue();\n         }\n         return result;\n     }\n@@ -224,8 +225,21 @@\n      * \n      * @param v the value to lookup.\n      * @return the frequency of v.\n+     * @deprecated replaced by {@link #getCount(Comparable)} as of 2.0\n      */\n+    @Deprecated\n     public long getCount(Object v) {\n+        return getCount((Comparable\u003c?\u003e) v);\n+    }\n+\n+    /**\n+     * Returns the number of values \u003d v.\n+     * Returns 0 if the value is not comparable.\n+     * \n+     * @param v the value to lookup.\n+     * @return the frequency of v.\n+     */\n+    public long getCount(Comparable\u003c?\u003e v) {\n         if (v instanceof Integer) {\n             return getCount(((Integer) v).longValue());\n         }\n@@ -281,8 +295,23 @@\n      * \n      * @param v the value to lookup\n      * @return the proportion of values equal to v\n+     * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n      */\n+    @Deprecated\n     public double getPct(Object v) {\n+        return getCumPct((Comparable\u003c?\u003e) v);\n+    }\n+\n+    /**\n+     * Returns the percentage of values that are equal to v\n+     * (as a proportion between 0 and 1).\n+     * \u003cp\u003e\n+     * Returns \u003ccode\u003eDouble.NaN\u003c/code\u003e if no values have been added.\u003c/p\u003e\n+     * \n+     * @param v the value to lookup\n+     * @return the proportion of values equal to v\n+     */\n+    public double getPct(Comparable\u003c?\u003e v) {\n         final long sumFreq \u003d getSumFreq();\n         if (sumFreq \u003d\u003d 0) {\n             return Double.NaN;\n@@ -332,15 +361,30 @@\n      * \n      * @param v the value to lookup.\n      * @return the proportion of values equal to v\n+     * @deprecated replaced by {@link #getCumFreq(Comparable)} as of 2.0\n      */\n+    @Deprecated\n     public long getCumFreq(Object v) {\n+        return getCumFreq((Comparable\u003c?\u003e) v);\n+    }\n+\n+    /**\n+     * Returns the cumulative frequency of values less than or equal to v.\n+     * \u003cp\u003e\n+     * Returns 0 if v is not comparable to the values set.\u003c/p\u003e\n+     * \n+     * @param v the value to lookup.\n+     * @return the proportion of values equal to v\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+        public long getCumFreq(Comparable\u003c?\u003e v) {\n         if (getSumFreq() \u003d\u003d 0) {\n             return 0;\n         }\n         if (v instanceof Integer) {\n             return getCumFreq(((Integer) v).longValue());\n         }\n-        Comparator c \u003d freqTable.comparator();\n+        Comparator\u003cComparable\u003c?\u003e\u003e c \u003d (Comparator\u003cComparable\u003c?\u003e\u003e) freqTable.comparator();\n         if (c \u003d\u003d null) {\n             c \u003d new NaturalComparator();\n         }\n@@ -354,7 +398,7 @@\n         } catch (ClassCastException ex) {\n             return result;   // v is not comparable\n         }\n-        \n+\n         if (c.compare(v, freqTable.firstKey()) \u003c 0) {\n             return 0;  // v is comparable, but less than first value\n         }\n@@ -363,9 +407,9 @@\n             return getSumFreq();    // v is comparable, but greater than the last value\n         }\n         \n-        Iterator\u003c?\u003e values \u003d valuesIterator();\n+        Iterator\u003cComparable\u003c?\u003e\u003e values \u003d valuesIterator();\n         while (values.hasNext()) {\n-            Object nextValue \u003d values.next();\n+            Comparable\u003c?\u003e nextValue \u003d values.next();\n             if (c.compare(v, nextValue) \u003e 0) {\n                 result +\u003d getCount(nextValue);\n             } else {\n@@ -423,8 +467,26 @@\n      * \n      * @param v the value to lookup\n      * @return the proportion of values less than or equal to v\n+     * @deprecated replaced by {@link #getCumPct(Comparable)} as of 2.0\n      */\n+    @Deprecated\n     public double getCumPct(Object v) {\n+        return getCumPct((Comparable\u003c?\u003e) v);\n+        \n+    }\n+\n+    /**\n+     * Returns the cumulative percentage of values less than or equal to v\n+     * (as a proportion between 0 and 1).\n+     * \u003cp\u003e\n+     * Returns \u003ccode\u003eDouble.NaN\u003c/code\u003e if no values have been added.\n+     * Returns 0 if at least one value has been added, but v is not comparable\n+     * to the values set.\u003c/p\u003e\n+     * \n+     * @param v the value to lookup\n+     * @return the proportion of values less than or equal to v\n+     */\n+    public double getCumPct(Comparable\u003c?\u003e v) {\n         final long sumFreq \u003d getSumFreq();\n         if (sumFreq \u003d\u003d 0) {\n             return Double.NaN;\n@@ -475,7 +537,7 @@\n      * A Comparator that compares comparable objects using the\n      * natural order.  Copied from Commons Collections ComparableComparator.\n      */\n-    private static class NaturalComparator implements Comparator, Serializable {\n+    private static class NaturalComparator\u003cT extends Comparable\u003cT\u003e\u003e implements Comparator\u003cComparable\u003cT\u003e\u003e, Serializable {\n \n         /** Serializable version identifier */\n         private static final long serialVersionUID \u003d -3852193713161395148L;\n@@ -493,9 +555,9 @@\n          * @throws ClassCastException when \u003ci\u003eo1\u003c/i\u003e is not a {@link Comparable Comparable}, \n          *         or when \u003ccode\u003e((Comparable)o1).compareTo(o2)\u003c/code\u003e does\n          */\n-        @SuppressWarnings(\"unchecked\") // See Javadoc, ClassCast is expected\n-        public int compare(Object o1, Object o2) {\n-            return ((Comparable\u003cObject\u003e)o1).compareTo(o2);\n+        @SuppressWarnings(\"unchecked\")\n+        public int compare(Comparable\u003cT\u003e o1, Comparable\u003cT\u003e o2) {\n+            return (o1.compareTo((T) o2));\n         }\n     }\n \n@@ -526,4 +588,5 @@\n             return false;\n         return true;\n     }\n+\n }\n"
    },
    "Math-87": {
        "Buggy Function": "    private Integer getBasicRow(final int col) {\n        Integer row = null;\n        for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n                if (row == null) {\n                row = i;\n                } else {\n                return null;\n                }\n            }\n        }\n        return row;\n    }",
        "Inducing Changes": "diff --git a/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java b/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\nindex ba57722..a6d7419 100644\n--- a/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n@@ -23,7 +23,9 @@\n import java.io.Serializable;\n import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.HashSet;\n import java.util.List;\n+import java.util.Set;\n \n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.RealMatrix;\n@@ -321,39 +323,27 @@\n      */\n     protected RealPointValuePair getSolution() {\n         double[] coefficients = new double[getOriginalNumDecisionVariables()];\n-        double mostNegative = getDecisionVariableValue(getOriginalNumDecisionVariables());\n+        Integer basicRow =\n+            getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n+        double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n+        Set<Integer> basicRows = new HashSet<Integer>();\n         for (int i = 0; i < coefficients.length; i++) {\n-            coefficients[i] =\n-                getDecisionVariableValue(i) - (restrictToNonNegative ? 0 : mostNegative); \n+            basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n+            if (basicRows.contains(basicRow)) {\n+                // if multiple variables can take a given value \n+                // then we choose the first and set the rest equal to 0\n+                coefficients[i] = 0;\n+            } else {\n+                basicRows.add(basicRow);\n+                coefficients[i] =\n+                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n+                    (restrictToNonNegative ? 0 : mostNegative);\n+            }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n     /**\n-     * Get the value of the given decision variable.  This is not the actual\n-     * value as it is guaranteed to be >= 0 and thus must be corrected before\n-     * being returned to the user.\n-     * \n-     * @param decisionVariable The index of the decision variable\n-     * @return The value of the given decision variable.\n-     */\n-    protected double getDecisionVariableValue(final int decisionVariable) {\n-      int col = getNumObjectiveFunctions() + decisionVariable;  \n-      Integer basicRow = getBasicRow(col);\n-      if (basicRow == null) {\n-          return 0;\n-      }\n-      // if there are multiple variables that can take the value on the RHS\n-      // then we'll give the first variable that value\n-      for (int i = getNumObjectiveFunctions(); i < col; i++) {\n-          if (tableau.getEntry(basicRow, i) == 1) {\n-              return 0;\n-          }\n-      }\n-      return getEntry(basicRow, getRhsOffset()); \n-  }\n-\n-    /**\n      * Subtracts a multiple of one row from another.\n      * <p>\n      * After application of this operation, the following will hold:\n\n"
    },
    "Math-88": {
        "Buggy Function": "    protected RealPointValuePair getSolution() {\n        double[] coefficients = new double[getOriginalNumDecisionVariables()];\n        Integer basicRow =\n            getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n        double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n        for (int i = 0; i < coefficients.length; i++) {\n            basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n                // if multiple variables can take a given value \n                // then we choose the first and set the rest equal to 0\n                coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);\n            if (basicRow != null) {\n                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }\n            }\n        }\n        return new RealPointValuePair(coefficients, f.getValue(coefficients));\n    }",
        "Inducing Changes": "diff --git a/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java b/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\nindex 5dceaf0..5a9a38d 100644\n--- a/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n@@ -327,9 +327,20 @@\n      * @return The value of the given decision variable.\n      */\n     protected double getDecisionVariableValue(final int decisionVariable) {\n-        Integer basicRow = getBasicRow(getNumObjectiveFunctions() + decisionVariable);\n-        return basicRow == null ? 0 : getEntry(basicRow, getRhsOffset()); \n-    }\n+      int col = getNumObjectiveFunctions() + decisionVariable;  \n+      Integer basicRow = getBasicRow(col);\n+      if (basicRow == null) {\n+          return 0;\n+      }\n+      // if there are multiple variables that can take the value on the RHS\n+      // then we'll give the first variable that value\n+      for (int i = getNumObjectiveFunctions(); i < col; i++) {\n+          if (tableau.getEntry(basicRow, i) == 1) {\n+              return 0;\n+          }\n+      }\n+      return getEntry(basicRow, getRhsOffset()); \n+  }\n \n     /**\n      * Subtracts a multiple of one row from another.\n@@ -392,7 +403,7 @@\n     /** Set an entry of the tableau.\n      * @param row row index\n      * @param column column index\n-     * param value for the entry\n+     * @param value for the entry\n      */\n     protected final void setEntry(final int row, final int column,\n                                   final double value) {\n\n"
    },
    "Math-89": {
        "Buggy Function": "    public void addValue(Object v) {\n            addValue((Comparable<?>) v);            \n    }",
        "Inducing Changes": "diff --git a/src/java/org/apache/commons/math/stat/Frequency.java b/src/java/org/apache/commons/math/stat/Frequency.java\nindex a5b8d7b..237c2f6 100644\n--- a/src/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/java/org/apache/commons/math/stat/Frequency.java\n@@ -101,9 +101,26 @@\n      * </p>\n      * \n      * @param v the value to add.\n-     * @throws IllegalArgumentException if <code>v</code> is not comparable.\n+     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n+     * @throws ClassCastException if <code>v</code> is not Comparable\n+     * @deprecated use {@link #addValue(Comparable)} instead\n      */\n+    @Deprecated\n     public void addValue(Object v) {\n+        addValue((Comparable<?>) v);\n+    }\n+    \n+    /**\n+     * Adds 1 to the frequency count for v.\n+     * <p>\n+     * If other objects have already been added to this Frequency, v must\n+     * be comparable to those that have already been added.\n+     * </p>\n+     * \n+     * @param v the value to add.\n+     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n+     */\n+    public void addValue(Comparable<?>v){\n         Object obj = v;\n         if (v instanceof Integer) {\n            obj = Long.valueOf(((Integer) v).longValue());\n\n"
    },
    "Math-94": {
        "Buggy Function": "    public static int gcd(int u, int v) {\n        if (u * v == 0) {\n            return (Math.abs(u) + Math.abs(v));\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        /* assert u!=0 && v!=0; */\n        if (u > 0) {\n            u = -u;\n        } // make u negative\n        if (v > 0) {\n            v = -v;\n        } // make v negative\n        // B1. [Find power of 2]\n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n                                                            // both even...\n            u /= 2;\n            v /= 2;\n            k++; // cast out twos.\n        }\n        if (k == 31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        // one is odd.\n        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u<0 && v<0; */\n            // B4/B3: cast out twos from t.\n            while ((t & 1) == 0) { // while t is even..\n                t /= 2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t > 0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            t = (v - u) / 2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t != 0);\n        return -u * (1 << k); // gcd is u*2^k\n    }",
        "Inducing Changes": "diff --git a/src/java/org/apache/commons/math/util/MathUtils.java b/src/java/org/apache/commons/math/util/MathUtils.java\nindex e62b7b3..20a9ddc 100644\n--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n@@ -535,31 +535,110 @@\n     }\n \n     /**\n-     * Returns the greatest common divisor between two integer values.\n-     * @param a the first integer value.\n-     * @param b the second integer value.\n-     * @return the greatest common divisor between a and b.\n+     * <p>Gets the greatest common divisor of the absolute value of\n+     * two numbers, using the \"binary gcd\" method which avoids\n+     * division and modulo operations.  See Knuth 4.5.2 algorithm B.\n+     * This algorithm is due to Josef Stein (1961).</p>\n+     *\n+     * @param u  a non-zero number\n+     * @param v  a non-zero number\n+     * @return the greatest common divisor, never zero\n      */\n-    public static int gcd(int a, int b) {\n-        int ret;\n-        \n-        if (a == 0) {\n-            ret = Math.abs(b);\n-        } else if (b == 0) {\n-            ret = Math.abs(a);\n-        } else if (a < 0) {\n-            ret = gcd(-a, b);\n-        } else if (b < 0) {\n-            ret = gcd(a, -b);\n-        } else {\n-            int r = 0;\n-            while(b > 0){\n-                r = a % b;\n-                a = b;\n-                b = r;\n-            }\n-            ret = a;\n+    public static int gcd(int u, int v) {\n+        if (u * v == 0) {\n+            return (Math.abs(u) + Math.abs(v));\n         }\n-        return ret;\n+        // keep u and v negative, as negative integers range down to\n+        // -2^31, while positive numbers can only be as large as 2^31-1\n+        // (i.e. we can't necessarily negate a negative number without\n+        // overflow)\n+        /* assert u!=0 && v!=0; */\n+        if (u>0) { u=-u; } // make u negative\n+        if (v>0) { v=-v; } // make v negative\n+        // B1. [Find power of 2]\n+        int k=0;\n+        while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...\n+            u/=2; v/=2; k++; // cast out twos.\n+        }\n+        if (k==31) {\n+            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n+        }\n+        // B2. Initialize: u and v have been divided by 2^k and at least\n+        //     one is odd.\n+        int t = ((u&1)==1) ? v : -(u/2)/*B3*/;\n+        // t negative: u was odd, v may be even (t replaces v)\n+        // t positive: u was even, v is odd (t replaces u)\n+        do {\n+            /* assert u<0 && v<0; */\n+            // B4/B3: cast out twos from t.\n+            while ((t&1)==0) { // while t is even..\n+                t/=2; // cast out twos\n+            }\n+            // B5 [reset max(u,v)]\n+            if (t>0) {\n+                u = -t;\n+            } else {\n+                v = t;\n+            }\n+            // B6/B3. at this point both u and v should be odd.\n+            t = (v - u)/2;\n+            // |u| larger: t positive (replace u)\n+            // |v| larger: t negative (replace v)\n+        } while (t!=0);\n+        return -u*(1<<k); // gcd is u*2^k\n+    }\n+\n+    /** \n+     * Multiply two integers, checking for overflow.\n+     * \n+     * @param x a factor\n+     * @param y a factor\n+     * @return the product <code>x*y</code>\n+     * @throws ArithmeticException if the result can not be represented as\n+     *                             an int\n+     */\n+    public static int mulAndCheck(int x, int y) {\n+        long m = ((long)x)*((long)y);\n+        if (m < Integer.MIN_VALUE ||\n+                m > Integer.MAX_VALUE) {\n+            throw new ArithmeticException(\"overflow: mul\");\n+        }\n+        return (int)m;\n+    }\n+    \n+    /** \n+     * Add two integers, checking for overflow.\n+     * \n+     * @param x an addend\n+     * @param y an addend\n+     * @return the sum <code>x+y</code>\n+     * @throws ArithmeticException if the result can not be represented as\n+     * an int\n+     */\n+    public static int addAndCheck(int x, int y) {\n+        long s = (long)x+(long)y;\n+        if (s < Integer.MIN_VALUE ||\n+                s > Integer.MAX_VALUE) {\n+            throw new ArithmeticException(\"overflow: add\");\n+        }\n+        return (int)s;\n+    }\n+    \n+    /** \n+     * Subtract two integers, checking for overflow.\n+     * \n+     * @param x the minuend\n+     * @param y the subtrahend\n+     * @return the difference <code>x-y</code>\n+     * @throws ArithmeticException if the result can not be represented as\n+     * an int\n+     */\n+    public static int subAndCheck(int x, int y) {\n+        long s = (long)x-(long)y;\n+        if (s < Integer.MIN_VALUE ||\n+                s > Integer.MAX_VALUE) {\n+            throw new ArithmeticException(\"overflow: add\");\n+        }\n+        return (int)s;\n     }\n }\n\n"
    },
    "Time-1": {
        "Buggy Function": "//buggy function from src/main/java/org/joda/time/Partial.java\npublic Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n    super();\n    chronology = DateTimeUtils.getChronology(chronology).withUTC();\n    iChronology = chronology;\n    if (types == null) {\n        throw new IllegalArgumentException(\"Types array must not be null\");\n    }\n    if (values == null) {\n        throw new IllegalArgumentException(\"Values array must not be null\");\n    }\n    if (values.length != types.length) {\n        throw new IllegalArgumentException(\"Values array must be the same length as the types array\");\n    }\n    if (types.length == 0) {\n        iTypes = types;\n        iValues = values;\n        return;\n    }\n    for (int i = 0; i < types.length; i++) {\n        if (types[i] == null) {\n            throw new IllegalArgumentException(\"Types array must not contain null: index \" + i);\n        }\n    }\n    DurationField lastUnitField = null;\n    for (int i = 0; i < types.length; i++) {\n        DateTimeFieldType loopType = types[i];\n        DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n        if (i > 0) {\n            int compare = lastUnitField.compareTo(loopUnitField);\n            if (compare < 0) {\n                throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                        types[i - 1].getName() + \" < \" + loopType.getName());\n            } else if (compare == 0) {\n                if (types[i - 1].getRangeDurationType() == null) {\n                    if (loopType.getRangeDurationType() == null) {\n                        throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                        types[i - 1].getName() + \" and \" + loopType.getName());\n                    }\n                } else {\n                    if (loopType.getRangeDurationType() == null) {\n                        throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                types[i - 1].getName() + \" < \" + loopType.getName());\n                    }\n                    DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                    DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                    if (lastRangeField.compareTo(loopRangeField) < 0) {\n                        throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                types[i - 1].getName() + \" < \" + loopType.getName());\n                    }\n                    if (lastRangeField.compareTo(loopRangeField) == 0) {\n                        throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                        types[i - 1].getName() + \" and \" + loopType.getName());\n                    }\n                }\n            }\n        }\n        lastUnitField = loopUnitField;\n    }\n\n    iTypes = (DateTimeFieldType[]) types.clone();\n    chronology.validate(this, values);\n    iValues = (int[]) values.clone();\n}\n//buggy function from src/main/java/org/joda/time/field/UnsupportedDurationField.java\npublic int compareTo(DurationField durationField) {\n    if (durationField.isSupported()) {\n        return 1;\n    }\n    return 0;\n}",
        "Inducing Changes": "diff --git a/src/main/java/org/joda/time/field/UnsupportedDurationField.java b/src/main/java/org/joda/time/field/UnsupportedDurationField.java\nindex bf44e01..7e0ce57 100644\n--- a/src/main/java/org/joda/time/field/UnsupportedDurationField.java\n+++ b/src/main/java/org/joda/time/field/UnsupportedDurationField.java\n@@ -224,6 +224,9 @@\n      * @return zero always\n      */\n     public int compareTo(DurationField durationField) {\n+        if (durationField.isSupported()) {\n+            return 1;\n+        }\n         return 0;\n     }\n \n\n"
    },
    "Time-2": {
        "Buggy Function": "//buggy function from src/main/java/org/joda/time/Partial.java\n    public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n    super();\n    chronology = DateTimeUtils.getChronology(chronology).withUTC();\n    iChronology = chronology;\n    if (types == null) {\n        throw new IllegalArgumentException(\"Types array must not be null\");\n    }\n    if (values == null) {\n        throw new IllegalArgumentException(\"Values array must not be null\");\n    }\n    if (values.length != types.length) {\n        throw new IllegalArgumentException(\"Values array must be the same length as the types array\");\n    }\n    if (types.length == 0) {\n        iTypes = types;\n        iValues = values;\n        return;\n    }\n    for (int i = 0; i < types.length; i++) {\n        if (types[i] == null) {\n            throw new IllegalArgumentException(\"Types array must not contain null: index \" + i);\n        }\n    }\n    DurationField lastUnitField = null;\n    for (int i = 0; i < types.length; i++) {\n        DateTimeFieldType loopType = types[i];\n        DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n        if (i > 0) {\n            int compare = lastUnitField.compareTo(loopUnitField);\n            if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                        types[i - 1].getName() + \" < \" + loopType.getName());\n            } else if (compare == 0) {\n                if (types[i - 1].getRangeDurationType() == null) {\n                    if (loopType.getRangeDurationType() == null) {\n                        throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                        types[i - 1].getName() + \" and \" + loopType.getName());\n                    }\n                } else {\n                    if (loopType.getRangeDurationType() == null) {\n                        throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                types[i - 1].getName() + \" < \" + loopType.getName());\n                    }\n                    DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                    DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                    if (lastRangeField.compareTo(loopRangeField) < 0) {\n                        throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                types[i - 1].getName() + \" < \" + loopType.getName());\n                    }\n                    if (lastRangeField.compareTo(loopRangeField) == 0) {\n                        throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                        types[i - 1].getName() + \" and \" + loopType.getName());\n                    }\n                }\n            }\n        }\n        lastUnitField = loopUnitField;\n    }\n    \n    iTypes = (DateTimeFieldType[]) types.clone();\n    chronology.validate(this, values);\n    iValues = (int[]) values.clone();\n}\npublic Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        \n        // find correct insertion point to keep largest-smallest order\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n        // use public constructor to ensure full validation\n        // this isn't overly efficient, but is safe\n        Partial newPartial = new Partial(newTypes, newValues, iChronology);\n        iChronology.validate(newPartial, newValues);\n        return newPartial;\n    }\n    if (value == getValue(index)) {\n        return this;\n    }\n    int[] newValues = getValues();\n    newValues = getField(index).set(this, index, newValues, value);\n    return new Partial(this, newValues);\n}\n//buggy function from src/main/java/org/joda/time/field/UnsupportedDurationField.java\npublic int compareTo(DurationField durationField) {\n    return 0;\n}",
        "Inducing Changes": "diff --git a/src/main/java/org/joda/time/Partial.java b/src/main/java/org/joda/time/Partial.java\nindex aaf0a0f..8e8e603 100644\n--- a/src/main/java/org/joda/time/Partial.java\n+++ b/src/main/java/org/joda/time/Partial.java\n@@ -1,5 +1,5 @@\n /*\n- *  Copyright 2001-2009 Stephen Colebourne\n+ *  Copyright 2001-2013 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n@@ -459,8 +459,9 @@\n             newValues[i] = value;\n             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n-            \n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+            // use public constructor to ensure full validation\n+            // this isn't overly efficient, but is safe\n+            Partial newPartial = new Partial(newTypes, newValues, iChronology);\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }\n\n"
    },
    "Time-7": {
        "Buggy Function": "    public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        \n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n        chrono = selectChronology(chrono);\n        int defaultYear = chrono.year().get(instantLocal);\n        \n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n        int newPos = parser.parseInto(bucket, text, position);\n        instant.setMillis(bucket.computeMillis(false, text));\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            chrono = chrono.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        }\n        instant.setChronology(chrono);\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n        return newPos;\n    }",
        "Inducing Changes": "diff --git a/JodaTime/src/main/java/org/joda/time/format/DateTimeFormatter.java b/JodaTime/src/main/java/org/joda/time/format/DateTimeFormatter.java\nindex bbb1e5c..c1e1d9b 100644\n--- a/JodaTime/src/main/java/org/joda/time/format/DateTimeFormatter.java\n+++ b/JodaTime/src/main/java/org/joda/time/format/DateTimeFormatter.java\n@@ -90,8 +90,10 @@\n     private final Chronology iChrono;\n     /** The zone to use as an override. */\n     private final DateTimeZone iZone;\n-    /* The pivot year to use for two-digit year parsing. */\n+    /** The pivot year to use for two-digit year parsing. */\n     private final Integer iPivotYear;\n+    /** The default year for parsing month/day without year. */\n+    private final int iDefaultYear;\n \n     /**\n      * Creates a new formatter, however you will normally use the factory\n@@ -110,6 +112,7 @@\n         iChrono = null;\n         iZone = null;\n         iPivotYear = null;\n+        iDefaultYear = 2000;\n     }\n \n     /**\n@@ -119,7 +122,7 @@\n             DateTimePrinter printer, DateTimeParser parser,\n             Locale locale, boolean offsetParsed,\n             Chronology chrono, DateTimeZone zone,\n-            Integer pivotYear) {\n+            Integer pivotYear, int defaultYear) {\n         super();\n         iPrinter = printer;\n         iParser = parser;\n@@ -128,6 +131,7 @@\n         iChrono = chrono;\n         iZone = zone;\n         iPivotYear = pivotYear;\n+        iDefaultYear = defaultYear;\n     }\n \n     //-----------------------------------------------------------------------\n@@ -184,7 +188,7 @@\n             return this;\n         }\n         return new DateTimeFormatter(iPrinter, iParser, locale,\n-                iOffsetParsed, iChrono, iZone, iPivotYear);\n+                iOffsetParsed, iChrono, iZone, iPivotYear, iDefaultYear);\n     }\n \n     /**\n@@ -217,7 +221,7 @@\n             return this;\n         }\n         return new DateTimeFormatter(iPrinter, iParser, iLocale,\n-                true, iChrono, null, iPivotYear);\n+                true, iChrono, null, iPivotYear, iDefaultYear);\n     }\n \n     /**\n@@ -252,7 +256,7 @@\n             return this;\n         }\n         return new DateTimeFormatter(iPrinter, iParser, iLocale,\n-                iOffsetParsed, chrono, iZone, iPivotYear);\n+                iOffsetParsed, chrono, iZone, iPivotYear, iDefaultYear);\n     }\n \n     /**\n@@ -315,7 +319,7 @@\n             return this;\n         }\n         return new DateTimeFormatter(iPrinter, iParser, iLocale,\n-                false, iChrono, zone, iPivotYear);\n+                false, iChrono, zone, iPivotYear, iDefaultYear);\n     }\n \n     /**\n@@ -362,7 +366,7 @@\n             return this;\n         }\n         return new DateTimeFormatter(iPrinter, iParser, iLocale,\n-                iOffsetParsed, iChrono, iZone, pivotYear);\n+                iOffsetParsed, iChrono, iZone, pivotYear, iDefaultYear);\n     }\n \n     /**\n@@ -410,6 +414,40 @@\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Returns a new formatter that will use the specified default year.\n+     * <p>\n+     * The default year is used when parsing in the case where there is a\n+     * month or a day but not a year. Specifically, it is used if there is\n+     * a field parsed with a duration between the length of a month and the\n+     * length of a day inclusive.\n+     * <p>\n+     * This value is typically used to move the year from 1970 to a leap year\n+     * to enable February 29th to be parsed.\n+     * Unless customised, the year 2000 is used.\n+     * <p>\n+     * This setting has no effect when printing.\n+     *\n+     * @param defaultYear  the default year to use\n+     * @return the new formatter, not null\n+     * @since 2.0\n+     */\n+    public DateTimeFormatter withDefaultYear(int defaultYear) {\n+        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n+                iOffsetParsed, iChrono, iZone, iPivotYear, defaultYear);\n+    }\n+\n+    /**\n+     * Gets the default year for parsing months and days.\n+     *\n+     * @return the default year for parsing months and days\n+     * @since 2.0\n+     */\n+    public int getDefaultYear() {\n+      return iDefaultYear;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Prints a ReadableInstant, using the chronology supplied by the instant.\n      *\n      * @param buf  the destination to format to, not null\n@@ -662,8 +700,8 @@\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n         \n-        DateTimeParserBucket bucket = new DateTimeParserBucket\n-            (instantLocal, chrono, iLocale, iPivotYear);\n+        DateTimeParserBucket bucket = new DateTimeParserBucket(\n+            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getZone() == null) {\n@@ -691,7 +729,7 @@\n         DateTimeParser parser = requireParser();\n         \n         Chronology chrono = selectChronology(iChrono);\n-        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear);\n+        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n         int newPos = parser.parseInto(bucket, text, 0);\n         if (newPos >= 0) {\n             if (newPos >= text.length()) {\n@@ -757,7 +795,7 @@\n         DateTimeParser parser = requireParser();\n         \n         Chronology chrono = selectChronology(null).withUTC();  // always use UTC, avoiding DST gaps\n-        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear);\n+        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n         int newPos = parser.parseInto(bucket, text, 0);\n         if (newPos >= 0) {\n             if (newPos >= text.length()) {\n@@ -796,7 +834,7 @@\n         DateTimeParser parser = requireParser();\n         \n         Chronology chrono = selectChronology(null);\n-        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear);\n+        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n         int newPos = parser.parseInto(bucket, text, 0);\n         if (newPos >= 0) {\n             if (newPos >= text.length()) {\n@@ -835,7 +873,7 @@\n         DateTimeParser parser = requireParser();\n         \n         Chronology chrono = selectChronology(null);\n-        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear);\n+        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n         int newPos = parser.parseInto(bucket, text, 0);\n         if (newPos >= 0) {\n             if (newPos >= text.length()) {"
    },
    "Time-11": {
        "Buggy Function": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\nstatic {\n    cVerbose.set(Boolean.FALSE);\n}\n\n/**\n * Gets a flag indicating that verbose logging is required.\n * @return true to log verbosely\n */\npublic static boolean verbose() {\n    return cVerbose.get();\n}",
        "Inducing Changes": "diff --git a/JodaTime/src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java b/JodaTime/src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java\nindex a42772e..ead4b2b 100644\n--- a/JodaTime/src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java\n+++ b/JodaTime/src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java\n@@ -1,5 +1,5 @@\n /*\n- *  Copyright 2001-2009 Stephen Colebourne\n+ *  Copyright 2001-2010 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n@@ -1440,9 +1440,11 @@\n                         curNameKey.equals(zoneNameData[2]) \u0026\u0026\n                         curNameKey.equals(zoneNameData[4])) {\n                     \n-                    System.out.println(\"Fixing duplicate name key - \" + nextNameKey);\n-                    System.out.println(\"     - \" + new DateTime(trans[i], chrono) +\n-                                       \" - \" + new DateTime(trans[i + 1], chrono));\n+                    if (ZoneInfoCompiler.verbose()) {\n+                        System.out.println(\"Fixing duplicate name key - \" + nextNameKey);\n+                        System.out.println(\"     - \" + new DateTime(trans[i], chrono) +\n+                                           \" - \" + new DateTime(trans[i + 1], chrono));\n+                    }\n                     if (curOffset \u003e nextOffset) {\n                         nameKeys[i] \u003d (curNameKey + \"-Summer\").intern();\n                     } else if (curOffset \u003c nextOffset) {\n@@ -1455,8 +1457,10 @@\n             if (tailZone !\u003d null) {\n                 if (tailZone.iStartRecurrence.getNameKey()\n                     .equals(tailZone.iEndRecurrence.getNameKey())) {\n-                    System.out.println(\"Fixing duplicate recurrent name key - \" +\n-                                       tailZone.iStartRecurrence.getNameKey());\n+                    if (ZoneInfoCompiler.verbose()) {\n+                        System.out.println(\"Fixing duplicate recurrent name key - \" +\n+                                           tailZone.iStartRecurrence.getNameKey());\n+                    }\n                     if (tailZone.iStartRecurrence.getSaveMillis() \u003e 0) {\n                         tailZone \u003d new DSTZone(\n                             tailZone.getID(),\ndiff --git a/JodaTime/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java b/JodaTime/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\nindex a7b5418..a057c30 100644\n--- a/JodaTime/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\n+++ b/JodaTime/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\n@@ -1,5 +1,5 @@\n /*\n- *  Copyright 2001-2009 Stephen Colebourne\n+ *  Copyright 2001-2010 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n@@ -65,6 +65,20 @@\n \n     static Chronology cLenientISO;\n \n+    static ThreadLocal\u003cBoolean\u003e cVerbose \u003d new ThreadLocal\u003cBoolean\u003e();\n+    static {\n+        cVerbose.set(Boolean.FALSE);\n+    }\n+\n+    /**\n+     * Gets a flag indicating that verbose logging is required.\n+     * @return true to log verbosely\n+     */\n+    public static boolean verbose() {\n+        return cVerbose.get();\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Launches the ZoneInfoCompiler tool.\n      *\n@@ -73,6 +87,7 @@\n      * where possible options include:\n      *   -src \u0026lt;directory\u0026gt;    Specify where to read source files\n      *   -dst \u0026lt;directory\u0026gt;    Specify where to write generated files\n+     *   -verbose            Output verbosely (default false)\n      * \u003c/pre\u003e\n      */\n     public static void main(String[] args) throws Exception {\n@@ -83,6 +98,7 @@\n \n         File inputDir \u003d null;\n         File outputDir \u003d null;\n+        boolean verbose \u003d false;\n \n         int i;\n         for (i\u003d0; i\u003cargs.length; i++) {\n@@ -91,6 +107,8 @@\n                     inputDir \u003d new File(args[++i]);\n                 } else if (\"-dst\".equals(args[i])) {\n                     outputDir \u003d new File(args[++i]);\n+                } else if (\"-verbose\".equals(args[i])) {\n+                    verbose \u003d true;\n                 } else if (\"-?\".equals(args[i])) {\n                     printUsage();\n                     return;\n@@ -113,6 +131,7 @@\n             sources[j] \u003d inputDir \u003d\u003d null ? new File(args[i]) : new File(inputDir, args[i]);\n         }\n \n+        cVerbose.set(verbose);\n         ZoneInfoCompiler zic \u003d new ZoneInfoCompiler();\n         zic.compile(outputDir, sources);\n     }\n@@ -122,6 +141,7 @@\n         System.out.println(\"where possible options include:\");\n         System.out.println(\"  -src \u003cdirectory\u003e    Specify where to read source files\");\n         System.out.println(\"  -dst \u003cdirectory\u003e    Specify where to write generated files\");\n+        System.out.println(\"  -verbose            Output verbosely (default false)\");\n     }\n \n     static DateTimeOfYear getStartOfYear() {\n@@ -363,6 +383,7 @@\n \n         Map\u003cString, DateTimeZone\u003e map \u003d new TreeMap\u003cString, DateTimeZone\u003e();\n \n+        System.out.println(\"Writing zoneinfo files\");\n         for (int i\u003d0; i\u003ciZones.size(); i++) {\n             Zone zone \u003d iZones.get(i);\n             DateTimeZoneBuilder builder \u003d new DateTimeZoneBuilder();\n@@ -372,7 +393,9 @@\n             if (test(tz.getID(), tz)) {\n                 map.put(tz.getID(), tz);\n                 if (outputDir !\u003d null) {\n-                    System.out.println(\"Writing \" + tz.getID());\n+                    if (ZoneInfoCompiler.verbose()) {\n+                        System.out.println(\"Writing \" + tz.getID());\n+                    }\n                     File file \u003d new File(outputDir, tz.getID());\n                     if (!file.getParentFile().exists()) {\n                         file.getParentFile().mkdirs();\n"
    },
    "Time-16": {
        "Buggy Function": "    public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        \n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n        chrono = selectChronology(chrono);\n        \n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, position);\n        instant.setMillis(bucket.computeMillis(false, text));\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            chrono = chrono.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        }\n        instant.setChronology(chrono);\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n        return newPos;\n    }",
        "Inducing Changes": "diff --git a/JodaTime/src/main/java/org/joda/time/format/DateTimeFormatter.java b/JodaTime/src/main/java/org/joda/time/format/DateTimeFormatter.java\nindex bbb1e5c..c1e1d9b 100644\n--- a/JodaTime/src/main/java/org/joda/time/format/DateTimeFormatter.java\n+++ b/JodaTime/src/main/java/org/joda/time/format/DateTimeFormatter.java\n@@ -90,8 +90,10 @@\n     private final Chronology iChrono;\n     /** The zone to use as an override. */\n     private final DateTimeZone iZone;\n-    /* The pivot year to use for two-digit year parsing. */\n+    /** The pivot year to use for two-digit year parsing. */\n     private final Integer iPivotYear;\n+    /** The default year for parsing month/day without year. */\n+    private final int iDefaultYear;\n \n     /**\n      * Creates a new formatter, however you will normally use the factory\n@@ -110,6 +112,7 @@\n         iChrono \u003d null;\n         iZone \u003d null;\n         iPivotYear \u003d null;\n+        iDefaultYear \u003d 2000;\n     }\n \n     /**\n@@ -119,7 +122,7 @@\n             DateTimePrinter printer, DateTimeParser parser,\n             Locale locale, boolean offsetParsed,\n             Chronology chrono, DateTimeZone zone,\n-            Integer pivotYear) {\n+            Integer pivotYear, int defaultYear) {\n         super();\n         iPrinter \u003d printer;\n         iParser \u003d parser;\n@@ -128,6 +131,7 @@\n         iChrono \u003d chrono;\n         iZone \u003d zone;\n         iPivotYear \u003d pivotYear;\n+        iDefaultYear \u003d defaultYear;\n     }\n \n     //-----------------------------------------------------------------------\n@@ -184,7 +188,7 @@\n             return this;\n         }\n         return new DateTimeFormatter(iPrinter, iParser, locale,\n-                iOffsetParsed, iChrono, iZone, iPivotYear);\n+                iOffsetParsed, iChrono, iZone, iPivotYear, iDefaultYear);\n     }\n \n     /**\n@@ -217,7 +221,7 @@\n             return this;\n         }\n         return new DateTimeFormatter(iPrinter, iParser, iLocale,\n-                true, iChrono, null, iPivotYear);\n+                true, iChrono, null, iPivotYear, iDefaultYear);\n     }\n \n     /**\n@@ -252,7 +256,7 @@\n             return this;\n         }\n         return new DateTimeFormatter(iPrinter, iParser, iLocale,\n-                iOffsetParsed, chrono, iZone, iPivotYear);\n+                iOffsetParsed, chrono, iZone, iPivotYear, iDefaultYear);\n     }\n \n     /**\n@@ -315,7 +319,7 @@\n             return this;\n         }\n         return new DateTimeFormatter(iPrinter, iParser, iLocale,\n-                false, iChrono, zone, iPivotYear);\n+                false, iChrono, zone, iPivotYear, iDefaultYear);\n     }\n \n     /**\n@@ -362,7 +366,7 @@\n             return this;\n         }\n         return new DateTimeFormatter(iPrinter, iParser, iLocale,\n-                iOffsetParsed, iChrono, iZone, pivotYear);\n+                iOffsetParsed, iChrono, iZone, pivotYear, iDefaultYear);\n     }\n \n     /**\n@@ -410,6 +414,40 @@\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Returns a new formatter that will use the specified default year.\n+     * \u003cp\u003e\n+     * The default year is used when parsing in the case where there is a\n+     * month or a day but not a year. Specifically, it is used if there is\n+     * a field parsed with a duration between the length of a month and the\n+     * length of a day inclusive.\n+     * \u003cp\u003e\n+     * This value is typically used to move the year from 1970 to a leap year\n+     * to enable February 29th to be parsed.\n+     * Unless customised, the year 2000 is used.\n+     * \u003cp\u003e\n+     * This setting has no effect when printing.\n+     *\n+     * @param defaultYear  the default year to use\n+     * @return the new formatter, not null\n+     * @since 2.0\n+     */\n+    public DateTimeFormatter withDefaultYear(int defaultYear) {\n+        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n+                iOffsetParsed, iChrono, iZone, iPivotYear, defaultYear);\n+    }\n+\n+    /**\n+     * Gets the default year for parsing months and days.\n+     *\n+     * @return the default year for parsing months and days\n+     * @since 2.0\n+     */\n+    public int getDefaultYear() {\n+      return iDefaultYear;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Prints a ReadableInstant, using the chronology supplied by the instant.\n      *\n      * @param buf  the destination to format to, not null\n@@ -662,8 +700,8 @@\n         long instantLocal \u003d instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono \u003d selectChronology(chrono);\n         \n-        DateTimeParserBucket bucket \u003d new DateTimeParserBucket\n-            (instantLocal, chrono, iLocale, iPivotYear);\n+        DateTimeParserBucket bucket \u003d new DateTimeParserBucket(\n+            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n         int newPos \u003d parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed \u0026\u0026 bucket.getZone() \u003d\u003d null) {\n@@ -691,7 +729,7 @@\n         DateTimeParser parser \u003d requireParser();\n         \n         Chronology chrono \u003d selectChronology(iChrono);\n-        DateTimeParserBucket bucket \u003d new DateTimeParserBucket(0, chrono, iLocale, iPivotYear);\n+        DateTimeParserBucket bucket \u003d new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n         int newPos \u003d parser.parseInto(bucket, text, 0);\n         if (newPos \u003e\u003d 0) {\n             if (newPos \u003e\u003d text.length()) {\n@@ -757,7 +795,7 @@\n         DateTimeParser parser \u003d requireParser();\n         \n         Chronology chrono \u003d selectChronology(null).withUTC();  // always use UTC, avoiding DST gaps\n-        DateTimeParserBucket bucket \u003d new DateTimeParserBucket(0, chrono, iLocale, iPivotYear);\n+        DateTimeParserBucket bucket \u003d new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n         int newPos \u003d parser.parseInto(bucket, text, 0);\n         if (newPos \u003e\u003d 0) {\n             if (newPos \u003e\u003d text.length()) {\n@@ -796,7 +834,7 @@\n         DateTimeParser parser \u003d requireParser();\n         \n         Chronology chrono \u003d selectChronology(null);\n-        DateTimeParserBucket bucket \u003d new DateTimeParserBucket(0, chrono, iLocale, iPivotYear);\n+        DateTimeParserBucket bucket \u003d new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n         int newPos \u003d parser.parseInto(bucket, text, 0);\n         if (newPos \u003e\u003d 0) {\n             if (newPos \u003e\u003d text.length()) {\n@@ -835,7 +873,7 @@\n         DateTimeParser parser \u003d requireParser();\n         \n         Chronology chrono \u003d selectChronology(null);\n-        DateTimeParserBucket bucket \u003d new DateTimeParserBucket(0, chrono, iLocale, iPivotYear);\n+        DateTimeParserBucket bucket \u003d new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n         int newPos \u003d parser.parseInto(bucket, text, 0);\n         if (newPos \u003e\u003d 0) {\n             if (newPos \u003e\u003d text.length()) {\ndiff --git a/JodaTime/src/main/java/org/joda/time/format/DateTimeParserBucket.java b/JodaTime/src/main/java/org/joda/time/format/DateTimeParserBucket.java\nindex 2b109f1..44255a6 100644\n--- a/JodaTime/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n+++ b/JodaTime/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n@@ -24,6 +24,7 @@\n import org.joda.time.DateTimeUtils;\n import org.joda.time.DateTimeZone;\n import org.joda.time.DurationField;\n+import org.joda.time.DurationFieldType;\n import org.joda.time.IllegalFieldValueException;\n \n /**\n@@ -64,6 +65,8 @@\n     private Locale iLocale;\n     /** Used for parsing two-digit years. */\n     private Integer iPivotYear;\n+    /** Used for parsing month/day without year. */\n+    private int iDefaultYear;\n \n     private SavedField[] iSavedFields \u003d new SavedField[8];\n     private int iSavedFieldsCount;\n@@ -72,18 +75,20 @@\n     private Object iSavedState;\n \n     /**\n-     * Constucts a bucket.\n+     * Constructs a bucket.\n      * \n      * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time\n      * @param chrono  the chronology to use\n      * @param locale  the locale to use\n+     * @deprecated Use longer constructor\n      */\n+    @Deprecated\n     public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale) {\n-        this(instantLocal, chrono, locale, null);\n+        this(instantLocal, chrono, locale, null, 2000);\n     }\n \n     /**\n-     * Constucts a bucket, with the option of specifying the pivot year for\n+     * Constructs a bucket, with the option of specifying the pivot year for\n      * two-digit year parsing.\n      *\n      * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time\n@@ -91,8 +96,25 @@\n      * @param locale  the locale to use\n      * @param pivotYear  the pivot year to use when parsing two-digit years\n      * @since 1.1\n+     * @deprecated Use longer constructor\n      */\n+    @Deprecated\n     public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear) {\n+        this(instantLocal, chrono, locale, pivotYear, 2000);\n+    }\n+\n+    /**\n+     * Constructs a bucket, with the option of specifying the pivot year for\n+     * two-digit year parsing.\n+     *\n+     * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time\n+     * @param chrono  the chronology to use\n+     * @param locale  the locale to use\n+     * @param pivotYear  the pivot year to use when parsing two-digit years\n+     * @since 2.0\n+     */\n+    public DateTimeParserBucket(long instantLocal, Chronology chrono,\n+            Locale locale, Integer pivotYear, int defaultYear) {\n         super();\n         chrono \u003d DateTimeUtils.getChronology(chrono);\n         iMillis \u003d instantLocal;\n@@ -100,6 +122,7 @@\n         iLocale \u003d (locale \u003d\u003d null ? Locale.getDefault() : locale);\n         setZone(chrono.getZone());\n         iPivotYear \u003d pivotYear;\n+        iDefaultYear \u003d defaultYear;\n     }\n \n     //-----------------------------------------------------------------------\n@@ -162,9 +185,13 @@\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Returns the pivot year used for parsing two-digit years.\n+     * Returns the default year used when information is incomplete.\n      * \u003cp\u003e\n-     * If null is returned, this indicates default behaviour\n+     * This is used for two-digit years and when the largest parsed field is\n+     * months or days.\n+     * \u003cp\u003e\n+     * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.\n+     * A null value for month/day only parsing will cause the default of 2000 to be used.\n      *\n      * @return Integer value of the pivot year, null if not set\n      * @since 1.1\n@@ -309,6 +336,16 @@\n             iSavedFieldsShared \u003d false;\n         }\n         sort(savedFields, count);\n+        if (count \u003e 0) {\n+            // alter base year for parsing if first field is month or day\n+            DurationField months \u003d DurationFieldType.months().getField(iChrono);\n+            DurationField days \u003d DurationFieldType.days().getField(iChrono);\n+            DurationField first \u003d savedFields[0].iField.getDurationField();\n+            if (compareReverse(first, months) \u003e\u003d 0 \u0026\u0026 compareReverse(first, days) \u003c\u003d 0) {\n+                saveField(DateTimeFieldType.year(), iDefaultYear);\n+                return computeMillis(resetFields, text);\n+            }\n+        }\n \n         long millis \u003d iMillis;\n         try {\n@@ -451,18 +488,18 @@\n             return compareReverse\n                 (iField.getDurationField(), other.getDurationField());\n         }\n-        \n-        private int compareReverse(DurationField a, DurationField b) {\n-            if (a \u003d\u003d null || !a.isSupported()) {\n-                if (b \u003d\u003d null || !b.isSupported()) {\n-                    return 0;\n-                }\n-                return -1;\n-            }\n+    }\n+\n+    static int compareReverse(DurationField a, DurationField b) {\n+        if (a \u003d\u003d null || !a.isSupported()) {\n             if (b \u003d\u003d null || !b.isSupported()) {\n-                return 1;\n+                return 0;\n             }\n-            return -a.compareTo(b);\n+            return -1;\n         }\n+        if (b \u003d\u003d null || !b.isSupported()) {\n+            return 1;\n+        }\n+        return -a.compareTo(b);\n     }\n }\n"
    },
    "Mockito-8": {
        "Buggy Function": "    protected void registerTypeVariablesOn(Type classType) {\n        if (!(classType instanceof ParameterizedType)) {\n            return;\n        }\n        ParameterizedType parameterizedType = (ParameterizedType) classType;\n        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n        for (int i = 0; i < actualTypeArguments.length; i++) {\n            TypeVariable typeParameter = typeParameters[i];\n            Type actualTypeArgument = actualTypeArguments[i];\n\n            if (actualTypeArgument instanceof WildcardType) {\n                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n            } else {\n                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n            }\n            // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n        }\n    }",
        "Inducing Changes": "diff --git a/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java b/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\nnew file mode 100644\nindex 0000000..26493ea\n--- /dev/null\n+++ b/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n@@ -0,0 +1,637 @@\n+/*\r\n+ * Copyright (c) 2007 Mockito contributors\r\n+ * This program is made available under the terms of the MIT License.\r\n+ */\r\n+package org.mockito.internal.util.reflection;\r\n+\r\n+\r\n+import java.lang.reflect.Method;\r\n+import java.lang.reflect.ParameterizedType;\r\n+import java.lang.reflect.Type;\r\n+import java.lang.reflect.TypeVariable;\r\n+import java.lang.reflect.WildcardType;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.Collections;\r\n+import java.util.HashMap;\r\n+import java.util.LinkedHashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import org.mockito.Incubating;\r\n+import org.mockito.exceptions.base.MockitoException;\r\n+import org.mockito.internal.util.Checks;\r\n+\r\n+\r\n+/**\r\n+ * This class can retrieve generic meta-data that the compiler stores on classes\r\n+ * and accessible members.\r\n+ *\r\n+ * <p>\r\n+ *     The main idea of this code is to create a Map that will help to resolve return types.\r\n+ *     In order to actually work with nested generics, this map will have to be passed along new instances\r\n+ *     as a type context.\r\n+ * </p>\r\n+ *\r\n+ * <p>\r\n+ *     Hence :\r\n+ *     <ul>\r\n+ *         <li>A new instance representing the metadata is created using the {@link #inferFrom(Type)} method from a real\r\n+ *         <code>Class</code> or from a <code>ParameterizedType</code>, other types are not yet supported.</li>\r\n+ *\r\n+ *         <li>Then from this metadata, we can extract meta-data for a generic return type of a method, using\r\n+ *         {@link #resolveGenericReturnType(Method)}.</li>\r\n+ *     </ul>\r\n+ * </p>\r\n+ *\r\n+ * <p>\r\n+ * For now this code support the following kind of generic declarations :\r\n+ * <pre class=\"code\"><code class=\"java\">\r\n+ * interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; {\r\n+ *     Set&lt;Number&gt; remove(Object key); // override with fixed ParameterizedType\r\n+ *     List&lt;? super Integer&gt; returning_wildcard_with_class_lower_bound();\r\n+ *     List&lt;? super K&gt; returning_wildcard_with_typeVar_lower_bound();\r\n+ *     List&lt;? extends K&gt; returning_wildcard_with_typeVar_upper_bound();\r\n+ *     K returningK();\r\n+ *     &lt;O extends K&gt; List&lt;O&gt; paramType_with_type_params();\r\n+ *     &lt;S, T extends S&gt; T two_type_params();\r\n+ *     &lt;O extends K&gt; O typeVar_with_type_params();\r\n+ *     Number returningNonGeneric();\r\n+ * }\r\n+ * </code></pre>\r\n+ *\r\n+ * @see #inferFrom(Type)\r\n+ * @see #resolveGenericReturnType(Method)\r\n+ * @see org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs\r\n+ */\r\n+@Incubating\r\n+public abstract class GenericMetadataSupport {\r\n+\r\n+    // public static MockitoLogger logger = new ConsoleMockitoLogger();\r\n+\r\n+    /**\r\n+     * Represents actual type variables resolved for current class.\r\n+     */\r\n+    protected Map<TypeVariable, Type> contextualActualTypeParameters = new HashMap<TypeVariable, Type>();\r\n+\r\n+\r\n+    protected void registerTypeVariablesOn(Type classType) {\r\n+        if (!(classType instanceof ParameterizedType)) {\r\n+            return;\r\n+        }\r\n+        ParameterizedType parameterizedType = (ParameterizedType) classType;\r\n+        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\r\n+        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\r\n+        for (int i = 0; i < actualTypeArguments.length; i++) {\r\n+            TypeVariable typeParameter = typeParameters[i];\r\n+            Type actualTypeArgument = actualTypeArguments[i];\r\n+\r\n+            if (actualTypeArgument instanceof WildcardType) {\r\n+                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\r\n+            } else {\r\n+                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\r\n+            }\r\n+            // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\r\n+        }\r\n+    }\r\n+\r\n+    protected void registerTypeParametersOn(TypeVariable[] typeParameters) {\r\n+        for (TypeVariable typeVariable : typeParameters) {\r\n+            registerTypeVariableIfNotPresent(typeVariable);\r\n+        }\r\n+    }\r\n+\r\n+    private void registerTypeVariableIfNotPresent(TypeVariable typeVariable) {\r\n+        if (!contextualActualTypeParameters.containsKey(typeVariable)) {\r\n+            contextualActualTypeParameters.put(typeVariable, boundsOf(typeVariable));\r\n+            // logger.log(\"For '\" + typeVariable.getGenericDeclaration() + \"' found type variable : { '\" + typeVariable + \"(\" + System.identityHashCode(typeVariable) + \")\" + \"' : '\" + boundsOf(typeVariable) + \"' }\");\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * @param typeParameter The TypeVariable parameter\r\n+     * @return A {@link BoundedType} for easy bound information, if first bound is a TypeVariable\r\n+     *         then retrieve BoundedType of this TypeVariable\r\n+     */\r\n+    private BoundedType boundsOf(TypeVariable typeParameter) {\r\n+        if (typeParameter.getBounds()[0] instanceof TypeVariable) {\r\n+            return boundsOf((TypeVariable) typeParameter.getBounds()[0]);\r\n+        }\r\n+        return new TypeVarBoundedType(typeParameter);\r\n+    }\r\n+\r\n+    /**\r\n+     * @param wildCard The WildCard type\r\n+     * @return A {@link BoundedType} for easy bound information, if first bound is a TypeVariable\r\n+     *         then retrieve BoundedType of this TypeVariable\r\n+     */\r\n+    private BoundedType boundsOf(WildcardType wildCard) {\r\n+        /*\r\n+         *  According to JLS(http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1):\r\n+         *  - Lower and upper can't coexist: (for instance, this is not allowed: <? extends List<String> & super MyInterface>)\r\n+         *  - Multiple bounds are not supported (for instance, this is not allowed: <? extends List<String> & MyInterface>)\r\n+         */\r\n+\r\n+        WildCardBoundedType wildCardBoundedType = new WildCardBoundedType(wildCard);\r\n+        if (wildCardBoundedType.firstBound() instanceof TypeVariable) {\r\n+            return boundsOf((TypeVariable) wildCardBoundedType.firstBound());\r\n+        }\r\n+\r\n+        return wildCardBoundedType;\r\n+    }\r\n+\r\n+\r\n+\r\n+    /**\r\n+     * @return Raw type of the current instance.\r\n+     */\r\n+    public abstract Class<?> rawType();\r\n+\r\n+\r\n+\r\n+    /**\r\n+     * @return Returns extra interfaces <strong>if relevant</strong>, otherwise empty List.\r\n+     */\r\n+    public List<Type> extraInterfaces() {\r\n+        return Collections.emptyList();\r\n+    }\r\n+\r\n+    /**\r\n+     * @return Returns an array with the raw types of {@link #extraInterfaces()} <strong>if relevant</strong>.\r\n+     */\r\n+    public Class<?>[] rawExtraInterfaces() {\r\n+        return new Class[0];\r\n+    }\r\n+\r\n+    /**\r\n+     * @return Returns true if metadata knows about extra-interfaces {@link #extraInterfaces()} <strong>if relevant</strong>.\r\n+     */\r\n+    public boolean hasRawExtraInterfaces() {\r\n+        return rawExtraInterfaces().length > 0;\r\n+    }\r\n+\r\n+\r\n+\r\n+    /**\r\n+     * @return Actual type arguments matching the type variables of the raw type represented by this {@link GenericMetadataSupport} instance.\r\n+     */\r\n+    public Map<TypeVariable, Type> actualTypeArguments() {\r\n+        TypeVariable[] typeParameters = rawType().getTypeParameters();\r\n+        LinkedHashMap<TypeVariable, Type> actualTypeArguments = new LinkedHashMap<TypeVariable, Type>();\r\n+\r\n+        for (TypeVariable typeParameter : typeParameters) {\r\n+\r\n+            Type actualType = getActualTypeArgumentFor(typeParameter);\r\n+\r\n+            actualTypeArguments.put(typeParameter, actualType);\r\n+            // logger.log(\"For '\" + rawType().getCanonicalName() + \"' returning explicit TypeVariable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualType +\"' }\");\r\n+        }\r\n+\r\n+        return actualTypeArguments;\r\n+    }\r\n+\r\n+    protected Type getActualTypeArgumentFor(TypeVariable typeParameter) {\r\n+        Type type = this.contextualActualTypeParameters.get(typeParameter);\r\n+        if (type instanceof TypeVariable) {\r\n+            TypeVariable typeVariable = (TypeVariable) type;\r\n+            return getActualTypeArgumentFor(typeVariable);\r\n+        }\r\n+\r\n+        return type;\r\n+    }\r\n+\r\n+\r\n+\r\n+    /**\r\n+     * Resolve current method generic return type to a {@link GenericMetadataSupport}.\r\n+     *\r\n+     * @param method Method to resolve the return type.\r\n+     * @return {@link GenericMetadataSupport} representing this generic return type.\r\n+     */\r\n+    public GenericMetadataSupport resolveGenericReturnType(Method method) {\r\n+        Type genericReturnType = method.getGenericReturnType();\r\n+        // logger.log(\"Method '\" + method.toGenericString() + \"' has return type : \" + genericReturnType.getClass().getInterfaces()[0].getSimpleName() + \" : \" + genericReturnType);\r\n+\r\n+        if (genericReturnType instanceof Class) {\r\n+            return new NotGenericReturnTypeSupport(genericReturnType);\r\n+        }\r\n+        if (genericReturnType instanceof ParameterizedType) {\r\n+            return new ParameterizedReturnType(this, method.getTypeParameters(), (ParameterizedType) method.getGenericReturnType());\r\n+        }\r\n+        if (genericReturnType instanceof TypeVariable) {\r\n+            return new TypeVariableReturnType(this, method.getTypeParameters(), (TypeVariable) genericReturnType);\r\n+        }\r\n+\r\n+        throw new MockitoException(\"Ouch, it shouldn't happen, type '\" + genericReturnType.getClass().getCanonicalName() + \"' on method : '\" + method.toGenericString() + \"' is not supported : \" + genericReturnType);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an new instance of {@link GenericMetadataSupport} inferred from a {@link Type}.\r\n+     *\r\n+     * <p>\r\n+     *     At the moment <code>type</code> can only be a {@link Class} or a {@link ParameterizedType}, otherwise\r\n+     *     it'll throw a {@link MockitoException}.\r\n+     * </p>\r\n+     *\r\n+     * @param type The class from which the {@link GenericMetadataSupport} should be built.\r\n+     * @return The new {@link GenericMetadataSupport}.\r\n+     * @throws MockitoException Raised if type is not a {@link Class} or a {@link ParameterizedType}.\r\n+     */\r\n+    public static GenericMetadataSupport inferFrom(Type type) {\r\n+        Checks.checkNotNull(type, \"type\");\r\n+        if (type instanceof Class) {\r\n+            return new FromClassGenericMetadataSupport((Class<?>) type);\r\n+        }\r\n+        if (type instanceof ParameterizedType) {\r\n+            return new FromParameterizedTypeGenericMetadataSupport((ParameterizedType) type);\r\n+        }\r\n+\r\n+        throw new MockitoException(\"Type meta-data for this Type (\" + type.getClass().getCanonicalName() + \") is not supported : \" + type);\r\n+    }\r\n+\r\n+\r\n+    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n+    //// Below are specializations of GenericMetadataSupport that could handle retrieval of possible Types\r\n+    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n+\r\n+    /**\r\n+     * Generic metadata implementation for {@link Class}.\r\n+     *\r\n+     * Offer support to retrieve generic metadata on a {@link Class} by reading type parameters and type variables on\r\n+     * the class and its ancestors and interfaces.\r\n+     */\r\n+    private static class FromClassGenericMetadataSupport extends GenericMetadataSupport {\r\n+        private final Class<?> clazz;\r\n+\r\n+        public FromClassGenericMetadataSupport(Class<?> clazz) {\r\n+            this.clazz = clazz;\r\n+\r\n+            for (Class currentExploredClass = clazz;\r\n+                 currentExploredClass != null && currentExploredClass != Object.class;\r\n+                 currentExploredClass = superClassOf(currentExploredClass)\r\n+                ) {\r\n+                readActualTypeParametersOnDeclaringClass(currentExploredClass);\r\n+            }\r\n+        }\r\n+\r\n+        private Class superClassOf(Class currentExploredClass) {\r\n+            Type genericSuperclass = currentExploredClass.getGenericSuperclass();\r\n+            if (genericSuperclass instanceof ParameterizedType) {\r\n+                Type rawType = ((ParameterizedType) genericSuperclass).getRawType();\r\n+                return (Class) rawType;\r\n+            }\r\n+            return (Class) genericSuperclass;\r\n+        }\r\n+\r\n+        private void readActualTypeParametersOnDeclaringClass(Class<?> clazz) {\r\n+            registerTypeParametersOn(clazz.getTypeParameters());\r\n+            registerTypeVariablesOn(clazz.getGenericSuperclass());\r\n+            for (Type genericInterface : clazz.getGenericInterfaces()) {\r\n+                registerTypeVariablesOn(genericInterface);\r\n+            }\r\n+        }\r\n+\r\n+        @Override\r\n+        public Class<?> rawType() {\r\n+            return clazz;\r\n+        }\r\n+    }\r\n+\r\n+\r\n+    /**\r\n+     * Generic metadata implementation for \"standalone\" {@link ParameterizedType}.\r\n+     *\r\n+     * Offer support to retrieve generic metadata on a {@link ParameterizedType} by reading type variables of\r\n+     * the related raw type and declared type variable of this parameterized type.\r\n+     *\r\n+     * This class is not designed to work on ParameterizedType returned by {@link Method#getGenericReturnType()}, as\r\n+     * the ParameterizedType instance return in these cases could have Type Variables that refer to type declaration(s).\r\n+     * That's what meant the \"standalone\" word at the beginning of the Javadoc.\r\n+     * Instead use {@link ParameterizedReturnType}.\r\n+     */\r\n+    private static class FromParameterizedTypeGenericMetadataSupport extends GenericMetadataSupport {\r\n+        private final ParameterizedType parameterizedType;\r\n+\r\n+        public FromParameterizedTypeGenericMetadataSupport(ParameterizedType parameterizedType) {\r\n+            this.parameterizedType = parameterizedType;\r\n+            readActualTypeParameters();\r\n+        }\r\n+\r\n+        private void readActualTypeParameters() {\r\n+            registerTypeVariablesOn(parameterizedType.getRawType());\r\n+            registerTypeVariablesOn(parameterizedType);\r\n+        }\r\n+\r\n+        @Override\r\n+        public Class<?> rawType() {\r\n+            return (Class<?>) parameterizedType.getRawType();\r\n+        }\r\n+    }\r\n+\r\n+\r\n+    /**\r\n+     * Generic metadata specific to {@link ParameterizedType} returned via {@link Method#getGenericReturnType()}.\r\n+     */\r\n+    private static class ParameterizedReturnType extends GenericMetadataSupport {\r\n+        private final ParameterizedType parameterizedType;\r\n+        private final TypeVariable[] typeParameters;\r\n+\r\n+        public ParameterizedReturnType(GenericMetadataSupport source, TypeVariable[] typeParameters, ParameterizedType parameterizedType) {\r\n+            this.parameterizedType = parameterizedType;\r\n+            this.typeParameters = typeParameters;\r\n+            this.contextualActualTypeParameters = source.contextualActualTypeParameters;\r\n+\r\n+            readTypeParameters();\r\n+            readTypeVariables();\r\n+        }\r\n+\r\n+        private void readTypeParameters() {\r\n+            registerTypeParametersOn(typeParameters);\r\n+        }\r\n+\r\n+        private void readTypeVariables() {\r\n+            registerTypeVariablesOn(parameterizedType);\r\n+        }\r\n+\r\n+        @Override\r\n+        public Class<?> rawType() {\r\n+            return (Class<?>) parameterizedType.getRawType();\r\n+        }\r\n+\r\n+    }\r\n+\r\n+\r\n+    /**\r\n+     * Generic metadata for {@link TypeVariable} returned via {@link Method#getGenericReturnType()}.\r\n+     */\r\n+    private static class TypeVariableReturnType extends GenericMetadataSupport {\r\n+        private final TypeVariable typeVariable;\r\n+        private final TypeVariable[] typeParameters;\r\n+        private Class<?> rawType;\r\n+\r\n+\r\n+\r\n+        public TypeVariableReturnType(GenericMetadataSupport source, TypeVariable[] typeParameters, TypeVariable typeVariable) {\r\n+            this.typeParameters = typeParameters;\r\n+            this.typeVariable = typeVariable;\r\n+            this.contextualActualTypeParameters = source.contextualActualTypeParameters;\r\n+\r\n+            readTypeParameters();\r\n+            readTypeVariables();\r\n+        }\r\n+\r\n+        private void readTypeParameters() {\r\n+            registerTypeParametersOn(typeParameters);\r\n+        }\r\n+\r\n+        private void readTypeVariables() {\r\n+            for (Type type : typeVariable.getBounds()) {\r\n+                registerTypeVariablesOn(type);\r\n+            }\r\n+            registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\r\n+        }\r\n+\r\n+        @Override\r\n+        public Class<?> rawType() {\r\n+            if (rawType == null) {\r\n+                rawType = extractRawTypeOf(typeVariable);\r\n+            }\r\n+            return rawType;\r\n+        }\r\n+\r\n+        private Class<?> extractRawTypeOf(Type type) {\r\n+            if (type instanceof Class) {\r\n+                return (Class<?>) type;\r\n+            }\r\n+            if (type instanceof ParameterizedType) {\r\n+                return (Class<?>) ((ParameterizedType) type).getRawType();\r\n+            }\r\n+            if (type instanceof BoundedType) {\r\n+                return extractRawTypeOf(((BoundedType) type).firstBound());\r\n+            }\r\n+            if (type instanceof TypeVariable) {\r\n+                /*\r\n+                 * If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared\r\n+                 * on the class definition, such as such as List<E>.\r\n+                 */\r\n+                return extractRawTypeOf(contextualActualTypeParameters.get(type));\r\n+            }\r\n+            throw new MockitoException(\"Raw extraction not supported for : '\" + type + \"'\");\r\n+        }\r\n+\r\n+        @Override\r\n+        public List<Type> extraInterfaces() {\r\n+            Type type = extractActualBoundedTypeOf(typeVariable);\r\n+            if (type instanceof BoundedType) {\r\n+                return Arrays.asList(((BoundedType) type).interfaceBounds());\r\n+            }\r\n+            if (type instanceof ParameterizedType) {\r\n+                return Collections.singletonList(type);\r\n+            }\r\n+            if (type instanceof Class) {\r\n+                return Collections.emptyList();\r\n+            }\r\n+            throw new MockitoException(\"Cannot extract extra-interfaces from '\" + typeVariable + \"' : '\" + type + \"'\");\r\n+        }\r\n+\r\n+        /**\r\n+         * @return Returns an array with the extracted raw types of {@link #extraInterfaces()}.\r\n+         * @see #extractRawTypeOf(java.lang.reflect.Type)\r\n+         */\r\n+        public Class<?>[] rawExtraInterfaces() {\r\n+            List<Type> extraInterfaces = extraInterfaces();\r\n+            List<Class<?>> rawExtraInterfaces = new ArrayList<Class<?>>();\r\n+            for (Type extraInterface : extraInterfaces) {\r\n+                Class<?> rawInterface = extractRawTypeOf(extraInterface);\r\n+                // avoid interface collision with actual raw type (with typevariables, resolution ca be quite aggressive)\r\n+                if(!rawType().equals(rawInterface)) {\r\n+                    rawExtraInterfaces.add(rawInterface);\r\n+                }\r\n+            }\r\n+            return rawExtraInterfaces.toArray(new Class[rawExtraInterfaces.size()]);\r\n+        }\r\n+\r\n+        private Type extractActualBoundedTypeOf(Type type) {\r\n+            if (type instanceof TypeVariable) {\r\n+                /*\r\n+                If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared\r\n+                on the class definition, such as such as List<E>.\r\n+                */\r\n+                return extractActualBoundedTypeOf(contextualActualTypeParameters.get(type));\r\n+            }\r\n+            if (type instanceof BoundedType) {\r\n+                Type actualFirstBound = extractActualBoundedTypeOf(((BoundedType) type).firstBound());\r\n+                if (!(actualFirstBound instanceof BoundedType)) {\r\n+                    return type; // avoid going one step further, ie avoid : O(TypeVar) -> K(TypeVar) -> Some ParamType\r\n+                }\r\n+                return actualFirstBound;\r\n+            }\r\n+            return type; // irrelevant, we don't manage other types as they are not bounded.\r\n+        }\r\n+    }\r\n+\r\n+\r\n+\r\n+    /**\r\n+     * Non-Generic metadata for {@link Class} returned via {@link Method#getGenericReturnType()}.\r\n+     */\r\n+    private static class NotGenericReturnTypeSupport extends GenericMetadataSupport {\r\n+        private final Class<?> returnType;\r\n+\r\n+        public NotGenericReturnTypeSupport(Type genericReturnType) {\r\n+            returnType = (Class<?>) genericReturnType;\r\n+        }\r\n+\r\n+        @Override\r\n+        public Class<?> rawType() {\r\n+            return returnType;\r\n+        }\r\n+    }\r\n+\r\n+\r\n+\r\n+    /**\r\n+     * Type representing bounds of a type\r\n+     *\r\n+     * @see TypeVarBoundedType\r\n+     * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>\r\n+     * @see WildCardBoundedType\r\n+     * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1</a>\r\n+     */\r\n+    public static interface BoundedType extends Type {\r\n+        Type firstBound();\r\n+\r\n+        Type[] interfaceBounds();\r\n+    }\r\n+\r\n+    /**\r\n+     * Type representing bounds of a type variable, allows to keep all bounds information.\r\n+     *\r\n+     * <p>It uses the first bound in the array, as this array is never null and always contains at least\r\n+     * one element (Object is always here if no bounds are declared).</p>\r\n+     *\r\n+     * <p>If upper bounds are declared with SomeClass and additional interfaces, then firstBound will be SomeClass and\r\n+     * interfacesBound will be an array of the additional interfaces.\r\n+     *\r\n+     * i.e. <code>SomeClass</code>.\r\n+     * <pre class=\"code\"><code class=\"java\">\r\n+     *     interface UpperBoundedTypeWithClass<E extends Comparable<E> & Cloneable> {\r\n+     *         E get();\r\n+     *     }\r\n+     *     // will return Comparable type\r\n+     * </code></pre>\r\n+     * </p>\r\n+     *\r\n+     * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>\r\n+     */\r\n+    public static class TypeVarBoundedType implements BoundedType {\r\n+        private final TypeVariable typeVariable;\r\n+\r\n+\r\n+        public TypeVarBoundedType(TypeVariable typeVariable) {\r\n+            this.typeVariable = typeVariable;\r\n+        }\r\n+\r\n+        /**\r\n+         * @return either a class or an interface (parameterized or not), if no bounds declared Object is returned.\r\n+         */\r\n+        public Type firstBound() {\r\n+            return typeVariable.getBounds()[0]; //\r\n+        }\r\n+\r\n+        /**\r\n+         * On a Type Variable (typeVar extends C_0 & I_1 & I_2 & etc), will return an array\r\n+         * containing I_1 and I_2.\r\n+         *\r\n+         * @return other bounds for this type, these bounds can only be only interfaces as the JLS says,\r\n+         * empty array if no other bound declared.\r\n+         */\r\n+        public Type[] interfaceBounds() {\r\n+            Type[] interfaceBounds = new Type[typeVariable.getBounds().length - 1];\r\n+            System.arraycopy(typeVariable.getBounds(), 1, interfaceBounds, 0, typeVariable.getBounds().length - 1);\r\n+            return interfaceBounds;\r\n+        }\r\n+\r\n+        @Override\r\n+        public boolean equals(Object o) {\r\n+            if (this == o) return true;\r\n+            if (o == null || getClass() != o.getClass()) return false;\r\n+\r\n+            return typeVariable.equals(((TypeVarBoundedType) o).typeVariable);\r\n+\r\n+        }\r\n+\r\n+        @Override\r\n+        public int hashCode() {\r\n+            return typeVariable.hashCode();\r\n+        }\r\n+\r\n+        @Override\r\n+        public String toString() {\r\n+            return \"{firstBound=\" + firstBound() + \", interfaceBounds=\" + Arrays.deepToString(interfaceBounds()) + '}';\r\n+        }\r\n+\r\n+        public TypeVariable typeVariable() {\r\n+            return typeVariable;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Type representing bounds of a wildcard, allows to keep all bounds information.\r\n+     *\r\n+     * <p>The JLS says that lower bound and upper bound are mutually exclusive, and that multiple bounds\r\n+     * are not allowed.\r\n+     *\r\n+     * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>\r\n+     */\r\n+    public static class WildCardBoundedType implements BoundedType {\r\n+        private final WildcardType wildcard;\r\n+\r\n+\r\n+        public WildCardBoundedType(WildcardType wildcard) {\r\n+            this.wildcard = wildcard;\r\n+        }\r\n+\r\n+        /**\r\n+         * @return The first bound, either a type or a reference to a TypeVariable\r\n+         */\r\n+        public Type firstBound() {\r\n+            Type[] lowerBounds = wildcard.getLowerBounds();\r\n+            Type[] upperBounds = wildcard.getUpperBounds();\r\n+\r\n+            return lowerBounds.length != 0 ? lowerBounds[0] : upperBounds[0];\r\n+        }\r\n+\r\n+        /**\r\n+         * @return An empty array as, wildcard don't support multiple bounds.\r\n+         */\r\n+        public Type[] interfaceBounds() {\r\n+            return new Type[0];\r\n+        }\r\n+\r\n+        @Override\r\n+        public boolean equals(Object o) {\r\n+            if (this == o) return true;\r\n+            if (o == null || getClass() != o.getClass()) return false;\r\n+\r\n+            return wildcard.equals(((TypeVarBoundedType) o).typeVariable);\r\n+\r\n+        }\r\n+\r\n+        @Override\r\n+        public int hashCode() {\r\n+            return wildcard.hashCode();\r\n+        }\r\n+\r\n+        @Override\r\n+        public String toString() {\r\n+            return \"{firstBound=\" + firstBound() + \", interfaceBounds=[]}\";\r\n+        }\r\n+\r\n+        public WildcardType wildCard() {\r\n+            return wildcard;\r\n+        }\r\n+    }\r\n+\r\n+}\r\n+\r\n+\r\n\n"
    },
    "Mockito-11": {
        "Buggy Function": "@Override\npublic boolean equals(Object o) {\n        return method.equals(o);\n}\n\n@Override\npublic int hashCode() {\n    return 1;\n}",
        "Inducing Changes": "diff --git a/src/org/mockito/internal/creation/DelegatingMethod.java b/src/org/mockito/internal/creation/DelegatingMethod.java\nnew file mode 100644\nindex 0000000..1f4239a\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/DelegatingMethod.java\n@@ -0,0 +1,49 @@\n+package org.mockito.internal.creation;\n+\n+import java.lang.reflect.Method;\n+\n+import org.mockito.internal.invocation.MockitoMethod;\n+\n+public class DelegatingMethod implements MockitoMethod {\n+\n+    private final Method method;\n+\n+    public DelegatingMethod(Method method) {\n+        assert method != null : \"Method cannot be null\";\n+        this.method = method;\n+    }\n+\n+    public Class<?>[] getExceptionTypes() {\n+        return method.getExceptionTypes();\n+    }\n+\n+    public Method getJavaMethod() {\n+        return method;\n+    }\n+\n+    public String getName() {\n+        return method.getName();\n+    }\n+\n+    public Class<?>[] getParameterTypes() {\n+        return method.getParameterTypes();\n+    }\n+\n+    public Class<?> getReturnType() {\n+        return method.getReturnType();\n+    }\n+\n+    public boolean isVarArgs() {\n+        return method.isVarArgs();\n+    }\n+    \n+    @Override\n+    public int hashCode() {\n+        throw new RuntimeException(\"hashCode() not implemented\");\n+    }\n+    \n+    @Override\n+    public boolean equals(Object obj) {\n+        return method.equals(obj);\n+    }\n+}\ndiff --git a/src/org/mockito/internal/creation/MethodInterceptorFilter.java b/src/org/mockito/internal/creation/MethodInterceptorFilter.java\nindex d89eb3c..8115507 100644\n--- a/src/org/mockito/internal/creation/MethodInterceptorFilter.java\n+++ b/src/org/mockito/internal/creation/MethodInterceptorFilter.java\n@@ -38,15 +38,15 @@\n         }\n         \n         MockitoMethodProxy mockitoMethodProxy = createMockitoMethodProxy(methodProxy);\n-        \n         cglibHacker.setMockitoNamingPolicy(mockitoMethodProxy);\n         \n+        MockitoMethod mockitoMethod = createMockitoMethod(method);\n+        \n         FilteredCGLIBProxyRealMethod realMethod = new FilteredCGLIBProxyRealMethod(mockitoMethodProxy);\n-        SerializableMethod serializableMethod = new SerializableMethod(method);\n-        Invocation invocation = new Invocation(proxy, serializableMethod, args, SequenceNumber.next(), realMethod);\n+        Invocation invocation = new Invocation(proxy, mockitoMethod, args, SequenceNumber.next(), realMethod);\n         return mockHandler.handle(invocation);\n     }\n-    \n+   \n     public IMockHandler getMockHandler() {\n         return mockHandler;\n     }\n@@ -60,4 +60,12 @@\n             return new SerializableMockitoMethodProxy(methodProxy);\n         return new DelegatingMockitoMethodProxy(methodProxy);\n     }\n+    \n+    public MockitoMethod createMockitoMethod(Method method) {\n+        if (mockSettings.isSerializable()) {\n+            return new SerializableMethod(method);\n+        } else {\n+            return new DelegatingMethod(method); \n+        }\n+    }\n }"
    },
    "Mockito-12": {
        "Buggy Function": "    public Class getGenericType(Field field) {        \n        Type generic = field.getGenericType();\n        if (generic != null && generic instanceof ParameterizedType) {\n            Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\n                return (Class) actual;\n                //in case of nested generics we don't go deep\n        }\n        \n        return Object.class;\n    }",
        "Inducing Changes": "diff --git a/src/org/mockito/internal/configuration/DefaultAnnotationEngine.java b/src/org/mockito/internal/configuration/DefaultAnnotationEngine.java\nindex a0492c6..d6849ec 100644\n--- a/src/org/mockito/internal/configuration/DefaultAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/DefaultAnnotationEngine.java\n@@ -6,8 +6,6 @@\n \n import java.lang.annotation.Annotation;\n import java.lang.reflect.Field;\n-import java.lang.reflect.ParameterizedType;\n-import java.lang.reflect.Type;\n \n import org.mockito.ArgumentCaptor;\n import org.mockito.Captor;\n@@ -19,12 +17,14 @@\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.util.reflection.FieldSetter;\n+import org.mockito.internal.util.reflection.GenericMaster;\n \n /**\n  * Initializes fields annotated with &#64;{@link org.mockito.Mock} or &#64;{@link org.mockito.Captor}.\n  * <p/>\n  * See {@link MockitoAnnotations}\n  */\n+@SuppressWarnings(\"unchecked\")\n public class DefaultAnnotationEngine implements AnnotationEngine {\n \n     /* (non-Javadoc)\n@@ -65,7 +65,7 @@\n     private Object processAnnotationOn(org.mockito.MockitoAnnotations.Mock annotation, Field field) {\n         return Mockito.mock(field.getType(), field.getName());\n     }\n-\n+    \n     private Object processAnnotationOn(Captor annotation, Field field) {\n         Class<?> type = field.getType();\n         if (!ArgumentCaptor.class.isAssignableFrom(type)) {\n@@ -73,20 +73,9 @@\n                     + field.getName() + \"' has wrong type\\n\"\n                     + \"For info how to use @Captor annotations see examples in javadoc for MockitoAnnotations class.\");\n         }\n-        Type generic = field.getGenericType();\n-        if (generic != null && generic instanceof ParameterizedType) {\n-            Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\n-            return ArgumentCaptor.forClass(typeToClass(actual));\n-        }\n-        return ArgumentCaptor.forClass(Object.class);    \n-    }       \n-\n-    private Class typeToClass(Type actual) {\n-        if (actual.equals(Double.class)) {\n-            return Double.class;\n-        }\n-        return Object.class;\n-    }\n+        Class cls = new GenericMaster().getGenericType(field);        \n+        return ArgumentCaptor.forClass(cls);    \n+    }           \n \n     @Override\n     public void process(Class<?> clazz, Object testClass) {\ndiff --git a/src/org/mockito/internal/util/reflection/GenericMaster.java b/src/org/mockito/internal/util/reflection/GenericMaster.java\nnew file mode 100644\nindex 0000000..1e63db6\n--- /dev/null\n+++ b/src/org/mockito/internal/util/reflection/GenericMaster.java\n@@ -0,0 +1,25 @@\n+package org.mockito.internal.util.reflection;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class GenericMaster {\n+\n+    /**\n+     * Finds the generic type (parametrized type) of the field. If the field is not generic it returns Object.class. \n+     * \n+     * @param field\n+     * @return\n+     */\n+    public Class getGenericType(Field field) {        \n+        Type generic = field.getGenericType();\n+        if (generic != null && generic instanceof ParameterizedType) {\n+            Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\n+            return (Class) actual;\n+        }\n+        \n+        return Object.class;\n+    }\n+}"
    },
    "Mockito-22": {
        "Buggy Function": "    public static boolean areEqual(Object o1, Object o2) {\n        if (o1 == null || o2 == null) {\n            return o1 == null && o2 == null;\n        } else if (isArray(o1)) {\n            return isArray(o2) && areArraysEqual(o1, o2);\n        } else {\n            return o1.equals(o2);\n        }\n    }",
        "Inducing Changes": "diff --git a/src/org/mockito/internal/matchers/Equality.java b/src/org/mockito/internal/matchers/Equality.java\nnew file mode 100644\nindex 0000000..3d905f1\n--- /dev/null\n+++ b/src/org/mockito/internal/matchers/Equality.java\n@@ -0,0 +1,37 @@\n+package org.mockito.internal.matchers;\n+\n+import java.lang.reflect.Array;\n+\n+//stolen from hamcrest because I didn't want to have more dependency than Matcher class \n+public class Equality {\n+\n+    public static boolean areEqual(Object o1, Object o2) {\n+        if (o1 == null || o2 == null) {\n+            return o1 == null && o2 == null;\n+        } else if (isArray(o1)) {\n+            return isArray(o2) && areArraysEqual(o1, o2);\n+        } else {\n+            return o1.equals(o2);\n+        }\n+    }\n+\n+    static boolean areArraysEqual(Object o1, Object o2) {\n+        return areArrayLengthsEqual(o1, o2)\n+                && areArrayElementsEqual(o1, o2);\n+    }\n+\n+    static boolean areArrayLengthsEqual(Object o1, Object o2) {\n+        return Array.getLength(o1) == Array.getLength(o2);\n+    }\n+\n+    static boolean areArrayElementsEqual(Object o1, Object o2) {\n+        for (int i = 0; i < Array.getLength(o1); i++) {\n+            if (!areEqual(Array.get(o1, i), Array.get(o2, i))) return false;\n+        }\n+        return true;\n+    }\n+\n+    static boolean isArray(Object o) {\n+        return o.getClass().isArray();\n+    }\n+}\ndiff --git a/src/org/mockito/internal/matchers/Equals.java b/src/org/mockito/internal/matchers/Equals.java\nindex b889f57..bd8b436 100644\n--- a/src/org/mockito/internal/matchers/Equals.java\n+++ b/src/org/mockito/internal/matchers/Equals.java\n@@ -18,10 +18,7 @@\n     }\n \n     public boolean matches(Object actual) {\n-        if (this.wanted == null) {\n-            return actual == null;\n-        }\n-        return wanted.equals(actual);\n+        return Equality.areEqual(this.wanted, actual);\n     }\n \n     public void describeTo(Description description) {"
    },
    "Mockito-38": {
        "Buggy Function": "    private boolean toStringEquals(Matcher m, Object arg) {\n        return StringDescription.toString(m).equals(arg.toString());\n    }",
        "Inducing Changes": "diff --git a/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java b/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\nindex 3e4bf91..f2161b4 100644\n--- a/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\n+++ b/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\n@@ -16,20 +16,20 @@\n      * @param arguments\r\n      * @return\r\n      */\r\n-    public Matcher[] getSuspiciouslyNotMatchingArgs(List<Matcher> matchers, Object[] arguments) {\r\n+    public Integer[] getSuspiciouslyNotMatchingArgsIndexes(List<Matcher> matchers, Object[] arguments) {\r\n         if (matchers.size() != arguments.length) {\r\n-            return new Matcher[0];\r\n+            return new Integer[0];\r\n         }\r\n         \r\n-        List<Matcher> suspicious = new LinkedList<Matcher>();\r\n+        List<Integer> suspicious = new LinkedList<Integer>();\r\n         int i = 0;\r\n         for (Matcher m : matchers) {\r\n             if (!safelyMatches(m, arguments[i]) && toStringEquals(m, arguments[i])) {\r\n-                suspicious.add(m);\r\n+                suspicious.add(i);\r\n             }\r\n             i++;\r\n         }\r\n-        return suspicious.toArray(new Matcher[0]);\r\n+        return suspicious.toArray(new Integer[0]);\r\n     }\r\n \r\n     private boolean safelyMatches(Matcher m, Object arg) {\r\n\n"
    },
    "Codec-3": {
        "Buggy Function": "    private int handleG(String value, \n                        DoubleMetaphoneResult result, \n                        int index, \n                        boolean slavoGermanic) {\n        if (charAt(value, index + 1) == 'H') {\n            index = handleGH(value, result, index);\n        } else if (charAt(value, index + 1) == 'N') {\n            if (index == 1 && isVowel(charAt(value, 0)) && !slavoGermanic) {\n                result.append(\"KN\", \"N\");\n            } else if (!contains(value, index + 2, 2, \"EY\") && \n                       charAt(value, index + 1) != 'Y' && !slavoGermanic) {\n                result.append(\"N\", \"KN\");\n            } else {\n                result.append(\"KN\");\n            }\n            index = index + 2;\n        } else if (contains(value, index + 1, 2, \"LI\") && !slavoGermanic) {\n            result.append(\"KL\", \"L\");\n            index += 2;\n        } else if (index == 0 && (charAt(value, index + 1) == 'Y' || contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {\n            //-- -ges-, -gep-, -gel-, -gie- at beginning --//\n            result.append('K', 'J');\n            index += 2;\n        } else if ((contains(value, index + 1, 2, \"ER\") || \n                    charAt(value, index + 1) == 'Y') &&\n                   !contains(value, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\") &&\n                   !contains(value, index - 1, 1, \"E\", \"I\") && \n                   !contains(value, index - 1, 3, \"RGY\", \"OGY\")) {\n            //-- -ger-, -gy- --//\n            result.append('K', 'J');\n            index += 2;\n        } else if (contains(value, index + 1, 1, \"E\", \"I\", \"Y\") || \n                   contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n            //-- Italian \"biaggi\" --//\n            if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                //-- obvious germanic --//\n                result.append('K');\n            } else if (contains(value, index + 1, 4, \"IER\")) {\n                result.append('J');\n            } else {\n                result.append('J', 'K');\n            }\n            index += 2;\n        } else if (charAt(value, index + 1) == 'G') {\n            index += 2;\n            result.append('K');\n        } else {\n            index++;\n            result.append('K');\n        }\n        return index;\n    }",
        "Inducing Changes": "Add Whole Class File of buggy method"
    },
    "Codec-4": {
        "Buggy Function": "    public Base64() {\n        this(false);\n    }",
        "Inducing Changes": "diff --git a/src/java/org/apache/commons/codec/binary/Base64.java b/src/java/org/apache/commons/codec/binary/Base64.java\nindex b85f9f4..eb09b5c 100644\n--- a/src/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64.java\n@@ -254,7 +254,7 @@\n      * \u003c/p\u003e\n      * \n      * @param lineLength\n-     *            Each line of encoded data will be at most of the given length (rounded up to nearest multiple of 4).\n+     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n      *            If lineLength \u003c\u003d 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n      * @since 1.4\n      */\n@@ -276,7 +276,7 @@\n      * \u003c/p\u003e\n      * \n      * @param lineLength\n-     *            Each line of encoded data will be at most of the given length (rounded up to nearest multiple of 4).\n+     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n      *            If lineLength \u003c\u003d 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n      * @param lineSeparator\n      *            Each line of encoded data will end with this sequence of bytes.\n@@ -302,7 +302,7 @@\n      * \u003c/p\u003e\n      * \n      * @param lineLength\n-     *            Each line of encoded data will be at most of the given length (rounded up to nearest multiple of 4).\n+     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n      *            If lineLength \u003c\u003d 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n      * @param lineSeparator\n      *            Each line of encoded data will end with this sequence of bytes.\n@@ -314,7 +314,7 @@\n      * @since 1.4\n      */\n     public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n-        this.lineLength \u003d lineLength;\n+        this.lineLength \u003d lineLength \u003e 0 ? (lineLength / 4) * 4 : 0;\n         this.lineSeparator \u003d new byte[lineSeparator.length];\n         System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n         if (lineLength \u003e 0) {\n@@ -324,7 +324,7 @@\n         }\n         this.decodeSize \u003d this.encodeSize - 1;\n         if (containsBase64Byte(lineSeparator)) {\n-            String sep \u003d StringBytesUtils.newStringUtf8(lineSeparator);\n+            String sep \u003d StringUtils.newStringUtf8(lineSeparator);\n             throw new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n         }\n         this.encodeTable \u003d urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n@@ -669,10 +669,11 @@\n      *             if the parameter supplied is not of type byte[]\n      */\n     public Object decode(Object pObject) throws DecoderException {\n-        if (!(pObject instanceof byte[])) {\n+        if (pObject instanceof byte[]) {\n+            return decode((byte[]) pObject);\n+        } else {\n             throw new DecoderException(\"Parameter supplied to Base64 decode is not a byte[]\");\n         }\n-        return decode((byte[]) pObject);\n     }\n \n     /**\n@@ -683,7 +684,24 @@\n      * @return a byte array containing binary data\n      */\n     public byte[] decode(byte[] pArray) {\n-        return decodeBase64(pArray);\n+        if (pArray \u003d\u003d null || pArray.length \u003d\u003d 0) {\n+            return pArray;\n+        }\n+        long len \u003d (pArray.length * 3) / 4;\n+        byte[] buf \u003d new byte[(int) len];\n+        setInitialBuffer(buf, 0, buf.length);\n+        decode(pArray, 0, pArray.length);\n+        decode(pArray, 0, -1); // Notify decoder of EOF.\n+\n+        // Would be nice to just return buf (like we sometimes do in the encode\n+        // logic), but we have no idea what the line-length was (could even be\n+        // variable).  So we cannot determine ahead of time exactly how big an\n+        // array is necessary.  Hence the need to construct a 2nd byte array to\n+        // hold the final result:\n+\n+        byte[] result \u003d new byte[pos];\n+        readResults(result, 0, result.length);\n+        return result;\n     }\n \n     /**\n@@ -739,41 +757,17 @@\n         if (binaryData \u003d\u003d null || binaryData.length \u003d\u003d 0) {\n             return binaryData;\n         }\n-        Base64 b64 \u003d isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n-        long len \u003d (binaryData.length * 4) / 3;\n-        long mod \u003d len % 4;\n-        if (mod !\u003d 0) {\n-            len +\u003d 4 - mod;\n-        }\n-        if (isChunked) {\n-            boolean lenChunksPerfectly \u003d len % CHUNK_SIZE \u003d\u003d 0;\n-            len +\u003d (len / CHUNK_SIZE) * CHUNK_SEPARATOR.length;\n-            if (!lenChunksPerfectly) {\n-                len +\u003d CHUNK_SEPARATOR.length;\n-            }\n-        }\n+\n+        long len \u003d getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);\n         if (len \u003e maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n                 \") than the specified maxium size of \" +\n                 maxResultSize);\n         }\n-        byte[] buf \u003d new byte[(int) len];\n-        b64.setInitialBuffer(buf, 0, buf.length);\n-        b64.encode(binaryData, 0, binaryData.length);\n-        b64.encode(binaryData, 0, -1); // Notify encoder of EOF.\n-        // Encoder might have resized, even though it was unnecessary.\n-        if (b64.buffer !\u003d buf) {\n-            b64.readResults(buf, 0, buf.length);\n-        }\n-        // In URL-SAFE mode we skip the padding characters, so sometimes our\n-        // final length is a bit smaller.\n-        if (urlSafe \u0026\u0026 b64.pos \u003c buf.length) {\n-            byte[] smallerBuf \u003d new byte[b64.pos];\n-            System.arraycopy(buf, 0, smallerBuf, 0, b64.pos);\n-            buf \u003d smallerBuf;\n-        }\n-        return buf;\n+                \n+        Base64 b64 \u003d isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n+        return b64.encode(binaryData);\n     }\n \n     /**\n@@ -784,20 +778,8 @@\n      * @return Array containing decoded data.\n      */\n     public static byte[] decodeBase64(byte[] base64Data) {\n-        if (base64Data \u003d\u003d null || base64Data.length \u003d\u003d 0) {\n-            return base64Data;\n-        }\n         Base64 b64 \u003d new Base64();\n-        long len \u003d (base64Data.length * 3) / 4;\n-        byte[] buf \u003d new byte[(int) len];\n-        b64.setInitialBuffer(buf, 0, buf.length);\n-        b64.decode(base64Data, 0, base64Data.length);\n-        b64.decode(base64Data, 0, -1); // Notify decoder of EOF.\n-        // We have no idea what the line-length was, so we\n-        // cannot know how much of our array wasn\u0027t used.\n-        byte[] result \u003d new byte[b64.pos];\n-        b64.readResults(result, 0, result.length);\n-        return result;\n+        return b64.decode(base64Data);\n     }\n \n     /**\n@@ -873,7 +855,53 @@\n      * @return A byte array containing only Base64 character data\n      */\n     public byte[] encode(byte[] pArray) {\n-        return encodeBase64(pArray, false, isUrlSafe());\n+        long len \u003d getEncodeLength(pArray, lineLength, lineSeparator);\n+        byte[] buf \u003d new byte[(int) len];\n+        setInitialBuffer(buf, 0, buf.length);\n+        encode(pArray, 0, pArray.length);\n+        encode(pArray, 0, -1); // Notify encoder of EOF.\n+        // Encoder might have resized, even though it was unnecessary.\n+        if (buffer !\u003d buf) {\n+            readResults(buf, 0, buf.length);\n+        }\n+        // In URL-SAFE mode we skip the padding characters, so sometimes our\n+        // final length is a bit smaller.\n+        if (isUrlSafe() \u0026\u0026 pos \u003c buf.length) {\n+            byte[] smallerBuf \u003d new byte[pos];\n+            System.arraycopy(buf, 0, smallerBuf, 0, pos);\n+            buf \u003d smallerBuf;\n+        }\n+        return buf;        \n+    }\n+\n+    /**\n+     * Pre-calculates the amount of space needed to base64-encode the supplied array.\n+     *\n+     * @param pArray byte[] array which will later be encoded\n+     * @param chunkSize line-length of the output (\u003c\u003d 0 means no chunking) between each\n+     *        chunkSeparator (e.g. CRLF).\n+     * @param chunkSeparator the sequence of bytes used to separate chunks of output (e.g. CRLF).\n+     *\n+     * @return amount of space needed to encoded the supplied array.  Returns\n+     *         a long since a max-len array will require Integer.MAX_VALUE + 33%.\n+     */\n+    private static long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {\n+        // base64 always encodes to multiples of 4.\n+        chunkSize \u003d (chunkSize / 4) * 4;\n+\n+        long len \u003d (pArray.length * 4) / 3;\n+        long mod \u003d len % 4;\n+        if (mod !\u003d 0) {\n+            len +\u003d 4 - mod;\n+        }\n+        if (chunkSize \u003e 0 \u0026\u0026 chunkSeparator !\u003d null) {\n+            boolean lenChunksPerfectly \u003d len % chunkSize \u003d\u003d 0;\n+            len +\u003d (len / chunkSize) * chunkSeparator.length;\n+            if (!lenChunksPerfectly) {\n+                len +\u003d chunkSeparator.length;\n+            }\n+        }\n+        return len;\n     }\n \n     // Implementation of integer encoding used for crypto\n"
    },
    "Codec-6": {
        "Buggy Function": "    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            /*\n             Rationale for while-loop on (readLen == 0):\n             -----\n             Base64.readResults() usually returns > 0 or EOF (-1).  In the\n             rare case where it returns 0, we just keep trying.\n\n             This is essentially an undocumented contract for InputStream\n             implementors that want their code to work properly with\n             java.io.InputStreamReader, since the latter hates it when\n             InputStream.read(byte[]) returns a zero.  Unfortunately our\n             readResults() call must return 0 if a large amount of the data\n             being decoded was non-base64, so this while-loop enables proper\n             interop with InputStreamReader for that scenario.\n             -----\n             This is a fix for CODEC-101\n            */\n                if (!base64.hasData()) {\n                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n                    int c = in.read(buf);\n                    // A little optimization to avoid System.arraycopy()\n                    // when possible.\n                    if (c > 0 && b.length == len) {\n                        base64.setInitialBuffer(b, offset, len);\n                    }\n                    if (doEncode) {\n                        base64.encode(buf, 0, c);\n                    } else {\n                        base64.decode(buf, 0, c);\n                    }\n                }\n            return base64.readResults(b, offset, len);\n        }\n    }",
        "Inducing Changes": "Add Whole Class File of buggy method"
    },
    "Codec-8": {
        "Buggy Function": "//buggy function from src/java/org/apache/commons/codec/binary/Base64.java\nvoid setInitialBuffer(byte[] out, int outPos, int outAvail) {\n    // We can re-use consumer's original output array under\n    // special circumstances, saving on some System.arraycopy().\n    if (out != null && out.length == outAvail) {\n        buffer = out;\n        pos = outPos;\n        readPos = outPos;\n    }\n}\n//buggy function from src/java/org/apache/commons/codec/binary/Base64InputStream.java\npublic int read(byte b[], int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0) {\n        throw new IndexOutOfBoundsException();\n    } else if (offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n        /*\n         Rationale for while-loop on (readLen == 0):\n         -----\n         Base64.readResults() usually returns > 0 or EOF (-1).  In the\n         rare case where it returns 0, we just keep trying.\n\n         This is essentially an undocumented contract for InputStream\n         implementors that want their code to work properly with\n         java.io.InputStreamReader, since the latter hates it when\n         InputStream.read(byte[]) returns a zero.  Unfortunately our\n         readResults() call must return 0 if a large amount of the data\n         being decoded was non-base64, so this while-loop enables proper\n         interop with InputStreamReader for that scenario.\n         -----\n         This is a fix for CODEC-101\n        */\n        while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}",
        "Inducing Changes": "diff --git a/src/java/org/apache/commons/codec/binary/Base64.java b/src/java/org/apache/commons/codec/binary/Base64.java\nindex 6aa9f4c..9437653 100644\n--- a/src/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64.java\n@@ -22,6 +22,7 @@\n import org.apache.commons.codec.DecoderException;\n import org.apache.commons.codec.EncoderException;\n \n+import java.io.UnsupportedEncodingException;\n import java.math.BigInteger;\n \n /**\n@@ -38,7 +39,6 @@\n  * @version $Id$\n  */\n public class Base64 implements BinaryEncoder, BinaryDecoder {\n-\n     /**\n      * Chunk size per RFC 2045 section 6.8.\n      * \n@@ -59,104 +59,392 @@\n     static final byte[] CHUNK_SEPARATOR = \"\\r\\n\".getBytes();\n \n     /**\n-     * The base length.\n-     */\n-    private static final int BASELENGTH = 255;\n-\n-    /**\n-     * Lookup length.\n-     */\n-    private static final int LOOKUPLENGTH = 64;\n-\n-    /**\n-     * Used to calculate the number of bits in a byte.\n-     */\n-    private static final int EIGHTBIT = 8;\n-\n-    /**\n-     * Used when encoding something which has fewer than 24 bits.\n-     */\n-    private static final int SIXTEENBIT = 16;\n-\n-    /**\n-     * Used to determine how many bits data contains.\n-     */\n-    private static final int TWENTYFOURBITGROUP = 24;\n-\n-    /**\n-     * Used to get the number of Quadruples.\n-     */\n-    private static final int FOURBYTE = 4;\n-\n-    /**\n-     * Used to test the sign of a byte.\n-     */\n-    private static final int SIGN = -128;\n-\n-    /**\n      * Byte used to pad output.\n      */\n     private static final byte PAD = (byte) '=';\n \n+\n+    // The static final fields above are used for the original static byte[] methods on Base64.\n+    // The private member fields below are used with the new streaming approach, which requires\n+    // some state be preserved between calls of encode() and decode().\n+\n+\n     /**\n-     * Contains the Base64 values <code>0</code> through <code>63</code> accessed by using character encodings as\n-     * indices.\n-     * <p>\n-     * For example, <code>base64Alphabet['+']</code> returns <code>62</code>.\n-     * </p>\n-     * <p>\n-     * The value of undefined encodings is <code>-1</code>.\n-     * </p>\n+     * Line length for encoding.  Not used when decoding.  Any value of zero or less implies\n+     * so chunking of the base64 encoded data.\n      */\n-    private static final byte[] base64Alphabet = new byte[BASELENGTH];\n+    private final int lineLength;\n+\n+    /**\n+     * Line separator for encoding.  Not used when decoding.  Only used if lineLength >= 1.\n+     */\n+    private final byte[] lineSeparator;\n+\n+    /**\n+     * Convenience variable to help us determine when our buffer is going to run out of\n+     * room and needs resizing.  <code>decodeSize = 3 + lineSeparator.length;</code>\n+     */\n+    private final int decodeSize;\n+\n+    /**\n+     * Convenience variable to help us determine when our buffer is going to run out of\n+     * room and needs resizing.  <code>encodeSize = 4 + lineSeparator.length;</code>\n+     */\n+    private final int encodeSize;\n+\n+    /**\n+     * Buffer for streaming. \n+     */\n+    private byte[] buf;\n+\n+    /**\n+     * Position where next character should be written in the buffer.\n+     */\n+    private int pos;\n+\n+    /**\n+     * Position where next character should be read from the buffer.\n+     */\n+    private int readPos;\n+\n+    /**\n+     * Variable tracks how many characters have been written to the current line.\n+     * Only used when encoding.  We use it to make sure each encoded line never\n+     * goes beyond lineLength (if lineLength >= 0).\n+     */\n+    private int currentLinePos;\n+\n+    /**\n+     * Writes to the buffer only occur after every 3 reads when encoding, an\n+     * every 4 reads when decoding.  This variable helps track that.\n+     */\n+    private int modulus;\n+\n+    /**\n+     * Boolean flag to indicate the EOF has been reached.  Once EOF has been\n+     * reached, this Base64 object becomes useless, and must be thrown away.\n+     */\n+    private boolean eof;\n+\n+    /**\n+     * Place holder for the 3 bytes we're dealing with for our base64 logic.\n+     * Bitwise operations store and extract the base64 encoding or decoding from\n+     * this variable.\n+     */\n+    private int x;\n+\n+    /**\n+     * Default constructor:  lineLength is 76, and the lineSeparator is CRLF\n+     * when encoding, and all forms can be decoded.\n+     */\n+    Base64() {\n+        this(CHUNK_SIZE, CHUNK_SEPARATOR);\n+    }\n \n     /**\n      * <p>\n-     * Contains the Base64 encodings <code>A</code> through <code>Z</code>, followed by <code>a</code> through\n-     * <code>z</code>, followed by <code>0</code> through <code>9</code>, followed by <code>+</code>, and\n-     * <code>/</code>.\n+     * Consumer can use this constructor to choose a different lineLength\n+     * when encoding (lineSeparator is still CRLF).  All forms of data can\n+     * be decoded.\n+     * </p><p>\n+     * Note:  lineLengths that aren't multiples of 4 will still essentially\n+     * end up being multiples of 4 in the encoded data.\n      * </p>\n-     * <p>\n-     * This array is accessed by using character values as indices.\n-     * </p>\n-     * <p>\n-     * For example, <code>lookUpBase64Alphabet[62] </code> returns <code>'+'</code>.\n-     * </p>\n+     *\n+     * @param lineLength each line of encoded data will be at most this long\n+     * (rounded up to nearest multiple of 4).  Ignored when decoding.\n      */\n-    private static final byte[] lookUpBase64Alphabet = new byte[LOOKUPLENGTH];\n+    Base64(int lineLength) {\n+        this(lineLength, CHUNK_SEPARATOR);\n+    }\n \n-    // Populating the lookup and character arrays\n-    static {\n-        for (int i = 0; i < BASELENGTH; i++) {\n-            base64Alphabet[i] = (byte) -1;\n+    /**\n+     * <p>\n+     * Consumer can use this constructor to choose a different lineLength\n+     * and lineSeparator when encoding.  All forms of data can\n+     * be decoded.\n+     * </p><p>\n+     * Note:  lineLengths that aren't multiples of 4 will still essentially\n+     * end up being multiples of 4 in the encoded data.\n+     * </p>\n+     * @param lineLength    Each line of encoded data will be at most this long\n+     *                      (rounded up to nearest multiple of 4).  Ignored when decoding.\n+     * @param lineSeparator Each line of encoded data will end with this\n+     *                      sequence of bytes.\n+     * @throws IllegalArgumentException The provided lineSeparator included\n+     *                                  some base64 characters.  That's not going to work!\n+     */\n+    Base64(int lineLength, byte[] lineSeparator) {\n+        this.lineLength = lineLength;\n+        this.lineSeparator = lineSeparator;\n+        if (lineLength > 0) {\n+            this.encodeSize = (byte) (4 + lineSeparator.length);\n+        } else {\n+            this.encodeSize = 4;\n         }\n-        for (int i = 'Z'; i >= 'A'; i--) {\n-            base64Alphabet[i] = (byte) (i - 'A');\n+        this.decodeSize = encodeSize - 1;\n+        byte[] separator = discardWhitespace(lineSeparator);\n+        if (separator.length > 0 && isArrayByteBase64(separator)) {\n+            String sep;\n+            try {\n+                sep = new String(lineSeparator, \"UTF-8\");\n+            } catch (UnsupportedEncodingException uee) {\n+                sep = new String(lineSeparator);\n+            }\n+            throw new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n         }\n-        for (int i = 'z'; i >= 'a'; i--) {\n-            base64Alphabet[i] = (byte) (i - 'a' + 26);\n+    }\n+\n+    /**\n+     * This array is a lookup table that translates 6-bit positive integer\n+     * index values into their \"Base64 Alphabet\" equivalents as specified\n+     * in Table 1 of RFC 2045.\n+     *\n+     * Thanks to \"commons\" project in ws.apache.org for this code. \n+     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n+     */\n+    private static final byte[] intToBase64 = {\n+            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n+            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n+            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n+            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n+            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'\n+    };\n+\n+    /**\n+     * This array is a lookup table that translates unicode characters\n+     * drawn from the \"Base64 Alphabet\" (as specified in Table 1 of RFC 2045)\n+     * into their 6-bit positive integer equivalents.  Characters that\n+     * are not in the Base64 alphabet but fall within the bounds of the\n+     * array are translated to -1.\n+     *\n+     * Thanks to \"commons\" project in ws.apache.org for this code.\n+     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/ \n+     */\n+    private static final byte[] base64ToInt = {\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54,\n+            55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4,\n+            5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n+            24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34,\n+            35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\n+    };\n+\n+    /**\n+     * Returns true if this Base64 object has buffered data for reading.\n+     *\n+     * @return true if there is Base64 object still available for reading.\n+     */\n+    boolean hasData() { return buf != null; }\n+\n+    /**\n+     * Returns the amount of buffered data available for reading.\n+     *\n+     * @return The amount of buffered data available for reading.\n+     */\n+    int avail() { return buf != null ? pos - readPos : 0; }\n+\n+    /** Doubles our buffer. */\n+    private void resizeBuf() {\n+        if (buf == null) {\n+            buf = new byte[8192];\n+            pos = 0;\n+            readPos = 0;\n+        } else {\n+            byte[] b = new byte[buf.length * 2];\n+            System.arraycopy(buf, 0, b, 0, buf.length);\n+            buf = b;\n         }\n-        for (int i = '9'; i >= '0'; i--) {\n-            base64Alphabet[i] = (byte) (i - '0' + 52);\n+    }\n+\n+    /**\n+     * Extracts buffered data into the provided byte[] array, starting\n+     * at position bPos, up to a maximum of bAvail bytes.  Returns how\n+     * many bytes were actually extracted.\n+     *\n+     * @param b      byte[] array to extract the buffered data into.\n+     * @param bPos   position in byte[] array to start extraction at.\n+     * @param bAvail amount of bytes we're allowed to extract.  We may extract\n+     *               fewer (if fewer are available).\n+     * @return The number of bytes successfully extracted into the provided\n+     *         byte[] array.\n+     */\n+    int readResults(byte[] b, int bPos, int bAvail) {\n+        if (buf != null) {\n+            int len = Math.min(avail(), bAvail);\n+            if (buf != b) {\n+                System.arraycopy(buf, readPos, b, bPos, len);\n+                readPos += len;\n+                if (readPos >= pos) {\n+                    buf = null;\n+                }\n+            } else {\n+                // Re-using the original consumer's output array is only\n+                // allowed for one round.\n+                buf = null;\n+            }\n+            return len;\n+        } else {\n+            return eof ? -1 : 0;\n+        }\n+    }\n+\n+    /**\n+     * Small optimization where we try to buffer directly to the consumer's\n+     * output array for one round (if consumer calls this method first!) instead\n+     * of starting our own buffer.\n+     *\n+     * @param out byte[] array to buffer directly to.\n+     * @param outPos Position to start buffering into.\n+     * @param outAvail Amount of bytes available for direct buffering.\n+     */\n+    void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n+        // We can re-use consumer's original output array under\n+        // special circumstances, saving on some System.arraycopy().\n+        if (out != null && out.length == outAvail) {\n+            buf = out;\n+            pos = outPos;\n+            readPos = outPos;\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Encodes all of the provided data, starting at inPos, for inAvail bytes.\n+     * Must be called at least twice:  once with the data to encode, and once\n+     * with inAvail set to \"-1\" to alert encoder that EOF has been reached,\n+     * so flush last remaining bytes (if not multiple of 3).\n+     * </p><p>\n+     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations,\n+     * and general approach.\n+     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n+     * </p>\n+     *\n+     * @param in byte[] array of binary data to base64 encode.\n+     * @param inPos Position to start reading data from.\n+     * @param inAvail Amount of bytes available from input for encoding.\n+     */\n+    void encode(byte[] in, int inPos, int inAvail) {\n+        if (eof) {\n+            return;\n         }\n \n-        base64Alphabet['+'] = 62;\n-        base64Alphabet['/'] = 63;\n+        // inAvail < 0 is how we're informed of EOF in the underlying data we're\n+        // encoding.\n+        if (inAvail < 0) {\n+            eof = true;\n+            if (buf == null || buf.length - pos < encodeSize) {\n+                resizeBuf();\n+            }\n+            switch (modulus) {\n+                case 1:\n+                    buf[pos++] = intToBase64[(x >> 2) & 0x3f];\n+                    buf[pos++] = intToBase64[(x << 4) & 0x3f];\n+                    buf[pos++] = PAD;\n+                    buf[pos++] = PAD;\n+                    break;\n \n-        for (int i = 0; i <= 25; i++) {\n-            lookUpBase64Alphabet[i] = (byte) ('A' + i);\n+                case 2:\n+                    buf[pos++] = intToBase64[(x >> 10) & 0x3f];\n+                    buf[pos++] = intToBase64[(x >> 4) & 0x3f];\n+                    buf[pos++] = intToBase64[(x << 2) & 0x3f];\n+                    buf[pos++] = PAD;\n+                    break;\n+            }\n+            if (lineLength > 0) {\n+                System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n+                pos += lineSeparator.length;\n+            }\n+        } else {\n+            for (int i = 0; i < inAvail; i++) {\n+                if (buf == null || buf.length - pos < encodeSize) {\n+                    resizeBuf();\n+                }\n+                modulus = (++modulus) % 3;\n+                int b = in[inPos++];\n+                if (b < 0) { b += 256; }\n+                x = (x << 8) + b;\n+                if (0 == modulus) {\n+                    buf[pos++] = intToBase64[(x >> 18) & 0x3f];\n+                    buf[pos++] = intToBase64[(x >> 12) & 0x3f];\n+                    buf[pos++] = intToBase64[(x >> 6) & 0x3f];\n+                    buf[pos++] = intToBase64[x & 0x3f];\n+                    currentLinePos += 4;\n+                    if (lineLength > 0 && lineLength <= currentLinePos) {\n+                        System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n+                        pos += lineSeparator.length;\n+                        currentLinePos = 0;\n+                    }\n+                }\n+            }\n         }\n+    }\n \n-        for (int i = 26, j = 0; i <= 51; i++, j++) {\n-            lookUpBase64Alphabet[i] = (byte) ('a' + j);\n+    /**\n+     * <p>\n+     * Decodes all of the provided data, starting at inPos, for inAvail bytes.\n+     * Should be called at least twice:  once with the data to decode, and once\n+     * with inAvail set to \"-1\" to alert decoder that EOF has been reached.\n+     * The \"-1\" call is not necessary when decoding, but it doesn't hurt, either.\n+     * </p><p>\n+     * Ignores all non-base64 characters.  This is how chunked (e.g. 76 character)\n+     * data is handled, since CR and LF are silently ignored, but has implications\n+     * for other bytes, too.  This method subscribes to the garbage-in, garbage-out\n+     * philosophy:  it will not check the provided data for validity.\n+     * </p><p>\n+     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations,\n+     * and general approach.\n+     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n+     * </p>\n+\n+     * @param in byte[] array of ascii data to base64 decode.\n+     * @param inPos Position to start reading data from.\n+     * @param inAvail Amount of bytes available from input for encoding.\n+     */    \n+    void decode(byte[] in, int inPos, int inAvail) {\n+        if (eof) {\n+            return;\n         }\n-\n-        for (int i = 52, j = 0; i <= 61; i++, j++) {\n-            lookUpBase64Alphabet[i] = (byte) ('0' + j);\n+        if (inAvail < 0) {\n+            eof = true;\n         }\n-\n-        lookUpBase64Alphabet[62] = (byte) '+';\n-        lookUpBase64Alphabet[63] = (byte) '/';\n+        for (int i = 0; i < inAvail; i++) {\n+            if (buf == null || buf.length - pos < decodeSize) {\n+                resizeBuf();\n+            }\n+            byte b = in[inPos++];\n+            if (b == PAD) {\n+                modulus = (++modulus) % 4;\n+                x = x << 6;\n+                switch (modulus) {\n+                    case 3:\n+                        x = x << 6;\n+                    case 0:\n+                        buf[pos++] = (byte) ((x >> 16) & 0xff);\n+                        if (modulus == 0) {\n+                            buf[pos++] = (byte) ((x >> 8) & 0xff);\n+                        }\n+                    default:\n+                        // WE'RE DONE!!!!\n+                        eof = true;\n+                        return;\n+                }\n+            } else {\n+                if (b >= 0 && b < base64ToInt.length) {\n+                    int result = base64ToInt[b];\n+                    if (result >= 0) {\n+                        modulus = (byte) ((++modulus) % 4);\n+                        x = (x << 6) + result;\n+                        if (modulus == 0) {\n+                            buf[pos++] = (byte) ((x >> 16) & 0xff);\n+                            buf[pos++] = (byte) ((x >> 8) & 0xff);\n+                            buf[pos++] = (byte) (x & 0xff);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n     }\n \n     /**\n@@ -167,13 +455,7 @@\n      * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.\n      */\n     private static boolean isBase64(byte octect) {\n-        if (octect == PAD) {\n-            return true;\n-        } else if (octect < 0 || base64Alphabet[octect] == -1) {\n-            return false;\n-        } else {\n-            return true;\n-        }\n+        return octect == PAD || (octect >= 0 && octect < base64ToInt.length && base64ToInt[octect] != -1);\n     }\n \n     /**\n@@ -264,189 +546,59 @@\n      *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n      */\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n-        long binaryDataLength = binaryData.length;\n-        long lengthDataBits = binaryDataLength * EIGHTBIT;\n-        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n-        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n-        long encodedDataLengthLong = 0;\n-        int chunckCount = 0;\n-\n-        if (fewerThan24bits != 0) {\n-            // data not divisible by 24 bit\n-            encodedDataLengthLong = (tripletCount + 1) * 4;\n-        } else {\n-            // 16 or 8 bit\n-            encodedDataLengthLong = tripletCount * 4;\n+        if (binaryData == null || binaryData.length == 0) {\n+            return binaryData;\n         }\n+        Base64 b64 = isChunked ? new Base64() : new Base64(0);\n \n-        // If the output is to be \"chunked\" into 76 character sections,\n-        // for compliance with RFC 2045 MIME, then it is important to\n-        // allow for extra length to account for the separator(s)\n+        long len = (binaryData.length * 4) / 3;\n+        long mod = len % 4;\n+        if (mod != 0) {\n+            len += 4 - mod;\n+        }\n         if (isChunked) {\n-\n-            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n-                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n-            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n+            len += (1 + (len / CHUNK_SIZE)) * CHUNK_SEPARATOR.length;\n         }\n \n-        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n+        if (len > Integer.MAX_VALUE) {\n             throw new IllegalArgumentException(\n                     \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n         }\n-        int encodedDataLength = (int) encodedDataLengthLong;\n-        byte encodedData[] = new byte[encodedDataLength];\n+        byte[] buf = new byte[(int) len];\n+        b64.setInitialBuffer(buf, 0, buf.length);\n+        b64.encode(binaryData, 0, binaryData.length);\n+        b64.encode(binaryData, 0, -1); // Notify encoder of EOF.\n \n-        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n-\n-        int encodedIndex = 0;\n-        int dataIndex = 0;\n-        int i = 0;\n-        int nextSeparatorIndex = CHUNK_SIZE;\n-        int chunksSoFar = 0;\n-\n-        // log.debug(\"number of triplets = \" + numberTriplets);\n-        for (i = 0; i < tripletCount; i++) {\n-            dataIndex = i * 3;\n-            b1 = binaryData[dataIndex];\n-            b2 = binaryData[dataIndex + 1];\n-            b3 = binaryData[dataIndex + 2];\n-\n-            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n-\n-            l = (byte) (b2 & 0x0f);\n-            k = (byte) (b1 & 0x03);\n-\n-            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n-            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n-            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n-\n-            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n-            // log.debug( \"val2 = \" + val2 );\n-            // log.debug( \"k4 = \" + (k<<4) );\n-            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n-            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n-            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n-            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n-\n-            encodedIndex += 4;\n-\n-            // If we are chunking, let's put a chunk separator down.\n-            if (isChunked) {\n-                // this assumes that CHUNK_SIZE % 4 == 0\n-                if (encodedIndex == nextSeparatorIndex) {\n-                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n-                    chunksSoFar++;\n-                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n-                    encodedIndex += CHUNK_SEPARATOR.length;\n-                }\n-            }\n+        // Encoder might have resized, even though it was unnecessary.\n+        if (b64.buf != buf) {\n+            b64.readResults(buf, 0, buf.length);\n         }\n-\n-        // form integral number of 6-bit groups\n-        dataIndex = i * 3;\n-\n-        if (fewerThan24bits == EIGHTBIT) {\n-            b1 = binaryData[dataIndex];\n-            k = (byte) (b1 & 0x03);\n-            // log.debug(\"b1=\" + b1);\n-            // log.debug(\"b1<<2 = \" + (b1>>2) );\n-            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n-            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n-            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n-            encodedData[encodedIndex + 2] = PAD;\n-            encodedData[encodedIndex + 3] = PAD;\n-        } else if (fewerThan24bits == SIXTEENBIT) {\n-\n-            b1 = binaryData[dataIndex];\n-            b2 = binaryData[dataIndex + 1];\n-            l = (byte) (b2 & 0x0f);\n-            k = (byte) (b1 & 0x03);\n-\n-            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n-            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n-\n-            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n-            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n-            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n-            encodedData[encodedIndex + 3] = PAD;\n-        }\n-\n-        if (isChunked) {\n-            // we also add a separator to the end of the final chunk.\n-            if (chunksSoFar < chunckCount) {\n-                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n-                        CHUNK_SEPARATOR.length);\n-            }\n-        }\n-\n-        return encodedData;\n+        return buf;\n     }\n \n     /**\n      * Decodes Base64 data into octects\n-     * \n-     * @param base64Data\n-     *            Byte array containing Base64 data\n+     *\n+     * @param base64Data Byte array containing Base64 data\n      * @return Array containing decoded data.\n      */\n     public static byte[] decodeBase64(byte[] base64Data) {\n-        // RFC 2045 requires that we discard ALL non-Base64 characters\n-        base64Data = discardNonBase64(base64Data);\n-\n-        // handle the edge case, so we don't have to worry about it later\n-        if (base64Data.length == 0) {\n-            return new byte[0];\n+        if (base64Data == null || base64Data.length == 0) {\n+            return base64Data;\n         }\n+        Base64 b64 = new Base64();\n \n-        int numberQuadruple = base64Data.length / FOURBYTE;\n-        byte decodedData[] = null;\n-        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n+        long len = (base64Data.length * 3) / 4;\n+        byte[] buf = new byte[(int) len];\n+        b64.setInitialBuffer(buf, 0, buf.length);\n+        b64.decode(base64Data, 0, base64Data.length);\n+        b64.decode(base64Data, 0, -1); // Notify decoder of EOF.\n \n-        // Throw away anything not in base64Data\n-\n-        int encodedIndex = 0;\n-        int dataIndex = 0;\n-        {\n-            // this sizes the output array properly - rlw\n-            int lastData = base64Data.length;\n-            // ignore the '=' padding\n-            while (base64Data[lastData - 1] == PAD) {\n-                if (--lastData == 0) {\n-                    return new byte[0];\n-                }\n-            }\n-            decodedData = new byte[lastData - numberQuadruple];\n-        }\n-\n-        for (int i = 0; i < numberQuadruple; i++) {\n-            dataIndex = i * 4;\n-            marker0 = base64Data[dataIndex + 2];\n-            marker1 = base64Data[dataIndex + 3];\n-\n-            b1 = base64Alphabet[base64Data[dataIndex]];\n-            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n-\n-            if (marker0 != PAD && marker1 != PAD) {\n-                // No PAD e.g 3cQl\n-                b3 = base64Alphabet[marker0];\n-                b4 = base64Alphabet[marker1];\n-\n-                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n-                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n-                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n-            } else if (marker0 == PAD) {\n-                // Two PAD e.g. 3c[Pad][Pad]\n-                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n-            } else if (marker1 == PAD) {\n-                // One PAD e.g. 3cQ[Pad]\n-                b3 = base64Alphabet[marker0];\n-\n-                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n-                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n-            }\n-            encodedIndex += 3;\n-        }\n-        return decodedData;\n+        // We have no idea what the line-length was, so we\n+        // cannot know how much of our array wasn't used.\n+        byte[] result = new byte[b64.pos];\n+        b64.readResults(result, 0, result.length);\n+        return result;\n     }\n \n     /**\n\n"
    },
    "Codec-14": {
        "Buggy Function": "",
        "Inducing Changes": ""
    },
    "Compress-6": {
        "Buggy Function": "public ZipArchiveEntry(String name) {\n    super(name);\n}\npublic boolean equals(Object obj) {\n    if (this == obj) {\n        return true;\n    }\n    if (obj == null || getClass() != obj.getClass()) {\n        return false;\n    }\n    ZipArchiveEntry other = (ZipArchiveEntry) obj;\n    if (name == null) {\n        if (other.name != null) {\n            return false;\n        }\n    } else if (!name.equals(other.name)) {\n        return false;\n    }\n    return true;\n}",
        "Inducing Changes": "diff --git a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\nindex 419b59c..772b19f 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n@@ -390,4 +390,25 @@\n             setExtra();\n         }\n     }\n+\n+    /* (non-Javadoc)\n+     * @see java.lang.Object#equals(java.lang.Object)\n+     */\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null || getClass() != obj.getClass()) {\n+            return false;\n+        }\n+        ZipArchiveEntry other = (ZipArchiveEntry) obj;\n+        if (name == null) {\n+            if (other.name != null) {\n+                return false;\n+            }\n+        } else if (!name.equals(other.name)) {\n+            return false;\n+        }\n+        return true;\n+    }\n }\n\n"
    },
    "Jsoup-26": {
        "Buggy Function": "    public Document clean(Document dirtyDocument) {\n        Validate.notNull(dirtyDocument);\n\n        Document clean = Document.createShell(dirtyDocument.baseUri());\n            copySafeNodes(dirtyDocument.body(), clean.body());\n\n        return clean;\n    }",
        "Inducing Changes": "diff --git a/src/main/java/org/jsoup/parser/Parser.java b/src/main/java/org/jsoup/parser/Parser.java\nindex f9bc06c..8adc13d 100644\n--- a/src/main/java/org/jsoup/parser/Parser.java\n+++ b/src/main/java/org/jsoup/parser/Parser.java\n@@ -1,318 +1,71 @@\n package org.jsoup.parser;\n \n+import org.jsoup.nodes.Document;\n+import org.jsoup.nodes.Element;\n+import org.jsoup.nodes.Node;\n \n-import org.jsoup.helper.Validate;\n-import org.jsoup.nodes.*;\n-\n-import java.util.LinkedList;\n+import java.util.List;\n \n /**\n- Parses HTML into a {@link Document}. Generally best to use one of the  more convenient parse methods in {@link org.jsoup.Jsoup}.\n-\n- @author Jonathan Hedley, jonathan@hedley.net */\n+ * Parses HTML into a {@link org.jsoup.nodes.Document}. Generally best to use one of the  more convenient parse methods\n+ * in {@link org.jsoup.Jsoup}.\n+ */\n public class Parser {\n-    private static final String SQ = \"'\";\n-    private static final String DQ = \"\\\"\";\n-\n-    private static final Tag htmlTag = Tag.valueOf(\"html\");\n-    private static final Tag headTag = Tag.valueOf(\"head\");\n-    private static final Tag bodyTag = Tag.valueOf(\"body\");\n-    private static final Tag titleTag = Tag.valueOf(\"title\");\n-    private static final Tag textareaTag = Tag.valueOf(\"textarea\");\n-\n-    private final LinkedList<Element> stack;\n-    private final TokenQueue tq;\n-    private final Document doc;\n-    private String baseUri;\n-    private boolean relaxed = false;\n-\n-    private Parser(String html, String baseUri, boolean isBodyFragment) {\n-        Validate.notNull(html);\n-        Validate.notNull(baseUri);\n-\n-        stack = new LinkedList<Element>();\n-        tq = new TokenQueue(html);\n-        this.baseUri = baseUri;\n-\n-        if (isBodyFragment) {\n-            doc = Document.createShell(baseUri);\n-            stack.add(doc.body());\n-        } else {\n-            doc = new Document(baseUri);\n-            stack.add(doc);\n-        }\n-    }\n-\n     /**\n-     Parse HTML into a Document.\n-     @param html HTML to parse\n-     @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n-     @return parsed Document\n+     * Parse HTML into a Document.\n+     *\n+     * @param html HTML to parse\n+     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n+     *\n+     * @return parsed Document\n      */\n     public static Document parse(String html, String baseUri) {\n-        Parser parser = new Parser(html, baseUri, false);\n-        return parser.parse();\n+        TreeBuilder treeBuilder = new TreeBuilder();\n+        return treeBuilder.parse(html, baseUri);\n     }\n \n     /**\n-     Parse a fragment of HTML into the {@code body} of a Document.\n-     @param bodyHtml fragment of HTML\n-     @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n-     @return Document, with empty head, and HTML parsed into body\n+     * Parse a fragment of HTML into a list of nodes. The context element, if supplied, supplies parsing context.\n+     *\n+     * @param fragmentHtml the fragment of HTML to parse\n+     * @param context (optional) the element that this HTML fragment is being parsed for (i.e. for inner HTML). This\n+     * provides stack context (for implicit element creation).\n+     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n+     *\n+     * @return list of nodes parsed from the input HTML. Note that the context element, if supplied, is not modifed.\n+     */\n+    public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri) {\n+        TreeBuilder treeBuilder = new TreeBuilder();\n+        return treeBuilder.parseFragment(fragmentHtml, context, baseUri);\n+    }\n+\n+    /**\n+     * Parse a fragment of HTML into the {@code body} of a Document.\n+     *\n+     * @param bodyHtml fragment of HTML\n+     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n+     *\n+     * @return Document, with empty head, and HTML parsed into body\n      */\n     public static Document parseBodyFragment(String bodyHtml, String baseUri) {\n-        Parser parser = new Parser(bodyHtml, baseUri, true);\n-        return parser.parse();\n+        Document doc = Document.createShell(baseUri);\n+        Element body = doc.body();\n+        List<Node> nodeList = parseFragment(bodyHtml, body, baseUri);\n+        Node[] nodes = nodeList.toArray(new Node[nodeList.size()]); // the node list gets modified when re-parented\n+        for (Node node : nodes) {\n+            body.appendChild(node);\n+        }\n+        return doc;\n     }\n \n     /**\n-     Parse a fragment of HTML into the {@code body} of a Document, with relaxed parsing enabled. Relaxed, in this\n-     context, means that implicit tags are not automatically created when missing.\n-     @param bodyHtml fragment of HTML\n-     @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n-     @return Document, with empty head, and HTML parsed into body\n+     * @param bodyHtml HTML to parse\n+     * @param baseUri baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n+     *\n+     * @return parsed Document\n+     * @deprecated Use {@link #parseBodyFragment} or {@link #parseFragment} instead.\n      */\n     public static Document parseBodyFragmentRelaxed(String bodyHtml, String baseUri) {\n-        Parser parser = new Parser(bodyHtml, baseUri, true);\n-        parser.relaxed = true;\n-        return parser.parse();\n-    }\n-\n-    private Document parse() {\n-        while (!tq.isEmpty()) {\n-            if (tq.matchesStartTag()) {\n-                parseStartTag();\n-            } else if (tq.matchesCS(\"</\")) {\n-                parseEndTag();\n-            } else if (tq.matchesCS(\"<!--\")) {\n-                parseComment();\n-            } else if (tq.matches(\"<![CDATA[\")) {\n-                parseCdata();\n-            } else if (tq.matchesCS(\"<?\") || tq.matchesCS(\"<!\")) {\n-                parseXmlDecl();\n-            } else {\n-                parseTextNode();\n-            }\n-        }\n-        return doc.normalise();\n-    }\n-\n-    private void parseComment() {\n-        tq.consume(\"<!--\");\n-        String data = tq.chompTo(\"->\");\n-\n-        if (data.endsWith(\"-\")) // i.e. was -->\n-            data = data.substring(0, data.length()-1);\n-        Comment comment = new Comment(data, baseUri);\n-        last().appendChild(comment);\n-    }\n-\n-    private void parseXmlDecl() {\n-        tq.consume(\"<\");\n-        Character firstChar = tq.consume(); // <? or <!, from initial match.\n-        boolean procInstr = firstChar.toString().equals(\"!\");\n-        String data = tq.chompTo(\">\");\n-\n-        XmlDeclaration decl = new XmlDeclaration(data, baseUri, procInstr);\n-        last().appendChild(decl);\n-    }\n-\n-    private void parseEndTag() {\n-        tq.consume(\"</\");\n-        String tagName = tq.consumeTagName();\n-        tq.chompTo(\">\");\n-\n-        if (tagName.length() != 0) {\n-            Tag tag = Tag.valueOf(tagName);\n-            if (!last().tag().isIgnorableEndTag(tag)) // skips </tr> if in <table>\n-                popStackToClose(tag);\n-        }\n-    }\n-\n-    private void parseStartTag() {\n-        tq.consume(\"<\");\n-        String tagName = tq.consumeTagName();\n-        Validate.notEmpty(tagName, \"Unexpectedly empty tagname. (This should not occur, please report!)\");\n-        \n-        tq.consumeWhitespace();\n-        Attributes attributes = new Attributes();\n-        while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.isEmpty()) {\n-            Attribute attribute = parseAttribute();\n-            if (attribute != null)\n-                attributes.put(attribute);\n-        }\n-\n-        Tag tag = Tag.valueOf(tagName);\n-        Element child = new Element(tag, baseUri, attributes);\n-\n-        boolean isEmptyElement = tag.isEmpty(); // empty element if empty tag (e.g. img) or self-closed el (<div/>\n-        if (tq.matchChomp(\"/>\")) { // close empty element or tag\n-            isEmptyElement = true;\n-            if (!tag.isKnownTag()) // if unknown and a self closed, allow it to be self closed on output. this doesn't force all instances to be empty\n-                tag.setSelfClosing();\n-        } else {\n-            tq.matchChomp(\">\");\n-        }\n-        addChildToParent(child, isEmptyElement);\n-\n-        // pc data only tags (textarea, script): chomp to end tag, add content as text node\n-        if (tag.isData()) {\n-            String data = tq.chompToIgnoreCase(\"</\" + tagName);\n-            tq.chompTo(\">\");\n-            popStackToClose(tag);\n-            \n-            Node dataNode;\n-            if (tag.equals(titleTag) || tag.equals(textareaTag)) // want to show as text, but not contain inside tags (so not a data tag?)\n-                dataNode = TextNode.createFromEncoded(data, baseUri);\n-            else\n-                dataNode = new DataNode(data, baseUri); // data not encoded but raw (for \" in script)\n-            child.appendChild(dataNode);   \n-        }\n-\n-        // <base href>: update the base uri\n-        if (child.tagName().equals(\"base\")) {\n-            String href = child.absUrl(\"href\");\n-            if (href.length() != 0) { // ignore <base target> etc\n-                baseUri = href;\n-                doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base\n-            }\n-        }\n-    }\n-\n-    private Attribute parseAttribute() {\n-        tq.consumeWhitespace();\n-        String key = tq.consumeAttributeKey();\n-        String value = \"\";\n-        tq.consumeWhitespace();\n-        if (tq.matchChomp(\"=\")) {\n-            tq.consumeWhitespace();\n-\n-            if (tq.matchChomp(SQ)) {\n-                value = tq.chompTo(SQ);\n-            } else if (tq.matchChomp(DQ)) {\n-                value = tq.chompTo(DQ);\n-            } else {\n-                StringBuilder valueAccum = new StringBuilder();\n-                // no ' or \" to look for, so scan to end tag or space (or end of stream)\n-                while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.matchesWhitespace() && !tq.isEmpty()) {\n-                    valueAccum.append(tq.consume());\n-                }\n-                value = valueAccum.toString();\n-            }\n-            tq.consumeWhitespace();\n-        }\n-        if (key.length() != 0)\n-            return Attribute.createFromEncoded(key, value);\n-        else {\n-            if (value.length() == 0) // no key, no val; unknown char, keep popping so not get stuck\n-                tq.advance();\n-                \n-            return null;\n-        }\n-    }\n-\n-    private void parseTextNode() {\n-        TextNode textNode;\n-        // special case: handle string like \"hello < there\". first char will be \"<\", because of matchStartTag\n-        if (tq.peek() == '<') {\n-            tq.advance();\n-            textNode = new TextNode(\"<\", baseUri);\n-        } else {\n-            String text = tq.consumeTo(\"<\");\n-            textNode = TextNode.createFromEncoded(text, baseUri);\n-        }\n-        last().appendChild(textNode);\n-    }\n-\n-    private void parseCdata() {\n-        tq.consume(\"<![CDATA[\");\n-        String rawText = tq.chompTo(\"]]>\");\n-        TextNode textNode = new TextNode(rawText, baseUri); // constructor does not escape\n-        last().appendChild(textNode);\n-    }\n-\n-    private Element addChildToParent(Element child, boolean isEmptyElement) {\n-        Element parent = popStackToSuitableContainer(child.tag());\n-        Tag childTag = child.tag();\n-        boolean validAncestor = stackHasValidParent(childTag);\n-\n-        if (!validAncestor && !relaxed) {\n-            // create implicit parent around this child\n-            Tag parentTag = childTag.getImplicitParent();\n-            Element implicit = new Element(parentTag, baseUri);\n-            // special case: make sure there's a head before putting in body\n-            if (child.tag().equals(bodyTag)) {\n-                Element head = new Element(headTag, baseUri);\n-                implicit.appendChild(head);\n-            }\n-            implicit.appendChild(child);\n-\n-            // recurse to ensure somewhere to put parent\n-            Element root = addChildToParent(implicit, false);\n-            if (!isEmptyElement)\n-                stack.addLast(child);\n-            return root;\n-        }\n-\n-        parent.appendChild(child);\n-\n-        if (!isEmptyElement)\n-            stack.addLast(child);\n-        return parent;\n-    }\n-\n-    private boolean stackHasValidParent(Tag childTag) {\n-        if (stack.size() == 1 && childTag.equals(htmlTag))\n-            return true; // root is valid for html node\n-\n-        if (childTag.requiresSpecificParent())\n-            return stack.getLast().tag().isValidParent(childTag);\n-\n-        // otherwise, look up the stack for valid ancestors\n-        for (int i = stack.size() -1; i >= 0; i--) {\n-            Element el = stack.get(i);\n-            Tag parent2 = el.tag();\n-            if (parent2.isValidAncestor(childTag)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    private Element popStackToSuitableContainer(Tag tag) {\n-        while (!stack.isEmpty()) {\n-            if (last().tag().canContain(tag))\n-                return last();\n-            else\n-                stack.removeLast();\n-        }\n-        return null;\n-    }\n-\n-    private Element popStackToClose(Tag tag) {\n-        // first check to see if stack contains this tag; if so pop to there, otherwise ignore\n-        int counter = 0;\n-        Element elToClose = null;\n-        for (int i = stack.size() -1; i > 0; i--) {\n-            counter++;\n-            Element el = stack.get(i);\n-            Tag elTag = el.tag();\n-            if (elTag.equals(bodyTag) || elTag.equals(htmlTag)) { // once in body, don't close past body\n-                break;\n-            } else if (elTag.equals(tag)) {\n-                elToClose = el;\n-                break;\n-            }\n-        }\n-        if (elToClose != null) {\n-            for (int i = 0; i < counter; i++) {\n-                stack.removeLast();\n-            }\n-        }\n-        return elToClose;\n-    }\n-\n-    private Element last() {\n-        return stack.getLast();\n+        return parse(bodyHtml, baseUri);\n     }\n }"
    },
    "Jsoup-43": {
        "Buggy Function": "    private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n        Validate.notNull(search);\n        Validate.notNull(elements);\n\n        for (int i = 0; i < elements.size(); i++) {\n            E element = elements.get(i);\n            if (element.equals(search))\n                return i;\n        }\n        return null;\n    }",
        "Inducing Changes": "diff --git a/src/main/java/org/jsoup/nodes/Element.java b/src/main/java/org/jsoup/nodes/Element.java\nindex 3dfc0ff..c07018e 100644\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n@@ -267,7 +267,7 @@\n         // was - Node#addChildren(child). short-circuits an array create and a loop.\n         reparentChild(child);\n         childNodes.add(child);\n-        child.setSiblingIndex(childNodes.size()-1);\n+        child.setSiblingIndex(childNodes.size() - 1);\n         return this;\n     }\n \n@@ -1166,12 +1166,17 @@\n \n     @Override\n     public boolean equals(Object o) {\n-        return this == o;\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+        if (!super.equals(o)) return false;\n+\n+        Element element = (Element) o;\n+\n+        return tag.equals(element.tag);\n     }\n \n     @Override\n     public int hashCode() {\n-        // todo: fixup, not very useful\n         int result = super.hashCode();\n         result = 31 * result + (tag != null ? tag.hashCode() : 0);\n         return result;\n@@ -1179,7 +1184,6 @@\n \n     @Override\n     public Element clone() {\n-        Element clone = (Element) super.clone();\n-        return clone;\n+        return (Element) super.clone();\n     }\n }\n\n"
    },
    "Jsoup-57": {
        "Buggy Function": "    public void removeIgnoreCase(String key) {\n        Validate.notEmpty(key);\n        if (attributes == null)\n            return;\n        for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n            String attrKey = it.next();\n            if (attrKey.equalsIgnoreCase(key))\n                attributes.remove(attrKey);\n        }\n    }",
        "Inducing Changes": "diff --git a/src/main/java/org/jsoup/nodes/Attributes.java b/src/main/java/org/jsoup/nodes/Attributes.java\nindex 28b013e..cc21fb6 100644\n--- a/src/main/java/org/jsoup/nodes/Attributes.java\n+++ b/src/main/java/org/jsoup/nodes/Attributes.java\n@@ -4,30 +4,39 @@\n import org.jsoup.helper.Validate;\n \n import java.io.IOException;\n-import java.util.*;\n+import java.util.AbstractMap;\n+import java.util.AbstractSet;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n \n /**\n  * The attributes of an Element.\n  * <p>\n- * Attributes are treated as a map: there can be only one value associated with an attribute key.\n+ * Attributes are treated as a map: there can be only one value associated with an attribute key/name.\n  * </p>\n  * <p>\n- * Attribute key and value comparisons are done case insensitively, and keys are normalised to\n- * lower-case.\n+ * Attribute name and value comparisons are  <b>case sensitive</b>. By default for HTML, attribute names are\n+ * normalized to lower-case on parsing. That means you should use lower-case strings when referring to attributes by\n+ * name.\n  * </p>\n- * \n+ *\n  * @author Jonathan Hedley, jonathan@hedley.net\n  */\n public class Attributes implements Iterable<Attribute>, Cloneable {\n     protected static final String dataPrefix = \"data-\";\n-    \n+\n     private LinkedHashMap<String, Attribute> attributes = null;\n     // linked hash map to preserve insertion order.\n     // null be default as so many elements have no attributes -- saves a good chunk of memory\n \n     /**\n      Get an attribute value by key.\n-     @param key the attribute key\n+     @param key the (case-sensitive) attribute key\n      @return the attribute value if set; or empty string if not set.\n      @see #hasKey(String)\n      */\n@@ -37,11 +46,28 @@\n         if (attributes == null)\n             return \"\";\n \n-        Attribute attr = attributes.get(key.toLowerCase());\n+        Attribute attr = attributes.get(key);\n         return attr != null ? attr.getValue() : \"\";\n     }\n \n     /**\n+     * Get an attribute's value by case-insensitive key\n+     * @param key the attribute name\n+     * @return the first matching attribute value if set; or empty string if not set.\n+     */\n+    public String getIgnoreCase(String key) {\n+        Validate.notEmpty(key);\n+        if (attributes == null)\n+            return \"\";\n+\n+        for (String attrKey : attributes.keySet()) {\n+            if (attrKey.equalsIgnoreCase(key))\n+                return attributes.get(attrKey).getValue();\n+        }\n+        return \"\";\n+    }\n+\n+    /**\n      Set a new attribute, or replace an existing one by key.\n      @param key attribute key\n      @param value attribute value\n@@ -50,7 +76,7 @@\n         Attribute attr = new Attribute(key, value);\n         put(attr);\n     }\n-    \n+\n     /**\n     Set a new boolean attribute, remove attribute if value is false.\n     @param key attribute key\n@@ -75,14 +101,37 @@\n     }\n \n     /**\n-     Remove an attribute by key.\n+     Remove an attribute by key. <b>Case sensitive.</b>\n      @param key attribute key to remove\n      */\n     public void remove(String key) {\n         Validate.notEmpty(key);\n         if (attributes == null)\n             return;\n-        attributes.remove(key.toLowerCase());\n+        attributes.remove(key);\n+    }\n+\n+    /**\n+     Remove an attribute by key. <b>Case insensitive.</b>\n+     @param key attribute key to remove\n+     */\n+    public void removeIgnoreCase(String key) {\n+        Validate.notEmpty(key);\n+        if (attributes == null)\n+            return;\n+        for (String attrKey : attributes.keySet()) {\n+            if (attrKey.equalsIgnoreCase(key))\n+                attributes.remove(attrKey);\n+        }\n+    }\n+\n+    /**\n+     Tests if these attributes contain an attribute with this key.\n+     @param key case-sensitive key to check for\n+     @return true if key exists, false otherwise\n+     */\n+    public boolean hasKey(String key) {\n+        return attributes != null && attributes.containsKey(key);\n     }\n \n     /**\n@@ -90,8 +139,14 @@\n      @param key key to check for\n      @return true if key exists, false otherwise\n      */\n-    public boolean hasKey(String key) {\n-        return attributes != null && attributes.containsKey(key.toLowerCase());\n+    public boolean hasKeyIgnoreCase(String key) {\n+        if (attributes == null)\n+            return false;\n+        for (String attrKey : attributes.keySet()) {\n+            if (attrKey.equalsIgnoreCase(key))\n+                return true;\n+        }\n+        return false;\n     }\n \n     /**\n@@ -115,7 +170,7 @@\n             attributes = new LinkedHashMap<String, Attribute>(incoming.size());\n         attributes.putAll(incoming.attributes);\n     }\n-    \n+\n     public Iterator<Attribute> iterator() {\n         return asList().iterator();\n     }\n@@ -159,18 +214,18 @@\n         }\n         return accum.toString();\n     }\n-    \n+\n     void html(Appendable accum, Document.OutputSettings out) throws IOException {\n         if (attributes == null)\n             return;\n-        \n+\n         for (Map.Entry<String, Attribute> entry : attributes.entrySet()) {\n             Attribute attribute = entry.getValue();\n             accum.append(\" \");\n             attribute.html(accum, out);\n         }\n     }\n-    \n+\n     @Override\n     public String toString() {\n         return html();\n@@ -185,9 +240,9 @@\n     public boolean equals(Object o) {\n         if (this == o) return true;\n         if (!(o instanceof Attributes)) return false;\n-        \n+\n         Attributes that = (Attributes) o;\n-        \n+\n         return !(attributes != null ? !attributes.equals(that.attributes) : that.attributes != null);\n     }\n \n\n"
    },
    "Jsoup-79": {
        "Buggy Function": "",
        "Inducing Changes": ""
    },
    "Jsoup-88": {
        "Buggy Function": "    public String getValue() {\n        return val;\n    }",
        "Inducing Changes": "diff --git a/src/main/java/org/jsoup/nodes/Attribute.java b/src/main/java/org/jsoup/nodes/Attribute.java\nindex 38be823..abe5d55 100644\n--- a/src/main/java/org/jsoup/nodes/Attribute.java\n+++ b/src/main/java/org/jsoup/nodes/Attribute.java\n@@ -8,9 +8,8 @@\n import java.util.Map;\n \n /**\n- A single key + value attribute. Keys are trimmed and normalised to lower-case.\n-\n- @author Jonathan Hedley, jonathan@hedley.net */\n+ A single key + value attribute. (Only used for presentation.)\n+ */\n public class Attribute implements Map.Entry<String, String>, Cloneable  {\n     private static final String[] booleanAttributes = {\n             \"allowfullscreen\", \"async\", \"autofocus\", \"checked\", \"compact\", \"declare\", \"default\", \"defer\", \"disabled\",\n@@ -20,7 +19,8 @@\n     };\n \n     private String key;\n-    private String value;\n+    private String val;\n+    Attributes parent; // used to update the holding Attributes when the key / value is changed via this interface\n \n     /**\n      * Create a new attribute from unencoded (raw) key and value.\n@@ -29,11 +29,21 @@\n      * @see #createFromEncoded\n      */\n     public Attribute(String key, String value) {\n+        this(key, value, null);\n+    }\n+\n+    /**\n+     * Create a new attribute from unencoded (raw) key and value.\n+     * @param key attribute key; case is preserved.\n+     * @param val attribute value\n+     * @param parent the containing Attributes (this Attribute is not automatically added to said Attributes)\n+     * @see #createFromEncoded*/\n+    public Attribute(String key, String val, Attributes parent) {\n         Validate.notNull(key);\n-        Validate.notNull(value);\n         this.key = key.trim();\n         Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n-        this.value = value;\n+        this.val = val;\n+        this.parent = parent;\n     }\n \n     /**\n@@ -50,7 +60,13 @@\n      */\n     public void setKey(String key) {\n         Validate.notEmpty(key);\n-        this.key = key.trim();\n+        key = key.trim();\n+        if (parent != null) {\n+            int i = parent.indexOfKey(this.key);\n+            if (i != Attributes.NotFound)\n+                parent.keys[i] = key;\n+        }\n+        this.key = key;\n     }\n \n     /**\n@@ -58,18 +74,22 @@\n      @return the attribute value\n      */\n     public String getValue() {\n-        return value;\n+        return val;\n     }\n \n     /**\n      Set the attribute value.\n-     @param value the new attribute value; must not be null\n+     @param val the new attribute value; must not be null\n      */\n-    public String setValue(String value) {\n-        Validate.notNull(value);\n-        String old = this.value;\n-        this.value = value;\n-        return old;\n+    public String setValue(String val) {\n+        String oldVal = parent.get(this.key);\n+        if (parent != null) {\n+            int i = parent.indexOfKey(this.key);\n+            if (i != Attributes.NotFound)\n+                parent.vals[i] = val;\n+        }\n+        this.val = val;\n+        return oldVal;\n     }\n \n     /**\n@@ -86,15 +106,19 @@\n         }\n         return accum.toString();\n     }\n-    \n-    protected void html(Appendable accum, Document.OutputSettings out) throws IOException {\n+\n+    protected static void html(String key, String val, Appendable accum, Document.OutputSettings out) throws IOException {\n         accum.append(key);\n-        if (!shouldCollapseAttribute(out)) {\n+        if (!shouldCollapseAttribute(key, val, out)) {\n             accum.append(\"=\\\"\");\n-            Entities.escape(accum, value, out, true, false, false);\n+            Entities.escape(accum, Attributes.checkNotNull(val) , out, true, false, false);\n             accum.append('\"');\n         }\n     }\n+    \n+    protected void html(Appendable accum, Document.OutputSettings out) throws IOException {\n+        html(key, val, accum, out);\n+    }\n \n     /**\n      Get the string representation of this attribute, implemented as {@link #html()}.\n@@ -113,10 +137,14 @@\n      */\n     public static Attribute createFromEncoded(String unencodedKey, String encodedValue) {\n         String value = Entities.unescape(encodedValue, true);\n-        return new Attribute(unencodedKey, value);\n+        return new Attribute(unencodedKey, value, null); // parent will get set when Put\n     }\n \n     protected boolean isDataAttribute() {\n+        return isDataAttribute(key);\n+    }\n+\n+    protected static boolean isDataAttribute(String key) {\n         return key.startsWith(Attributes.dataPrefix) && key.length() > Attributes.dataPrefix.length();\n     }\n \n@@ -127,37 +155,50 @@\n      * @return  Returns whether collapsible or not\n      */\n     protected final boolean shouldCollapseAttribute(Document.OutputSettings out) {\n-        return (\"\".equals(value) || value.equalsIgnoreCase(key))\n-                && out.syntax() == Document.OutputSettings.Syntax.html\n-                && isBooleanAttribute();\n+        return shouldCollapseAttribute(key, val, out);\n     }\n \n+    protected static boolean shouldCollapseAttribute(String key, String val, Document.OutputSettings out) {\n+        // todo: optimize\n+        return (val == null || \"\".equals(val) || val.equalsIgnoreCase(key))\n+            && out.syntax() == Document.OutputSettings.Syntax.html\n+            && isBooleanAttribute(key);\n+    }\n+\n+    /**\n+     * @deprecated\n+     */\n     protected boolean isBooleanAttribute() {\n+        return Arrays.binarySearch(booleanAttributes, key) >= 0 || val == null;\n+    }\n+\n+    /**\n+     * Checks if this attribute name is defined as a boolean attribute in HTML5\n+     */\n+    protected static boolean isBooleanAttribute(final String key) {\n         return Arrays.binarySearch(booleanAttributes, key) >= 0;\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n+    public boolean equals(Object o) { // note parent not considered\n         if (this == o) return true;\n-        if (!(o instanceof Attribute)) return false;\n-\n+        if (o == null || getClass() != o.getClass()) return false;\n         Attribute attribute = (Attribute) o;\n-\n         if (key != null ? !key.equals(attribute.key) : attribute.key != null) return false;\n-        return !(value != null ? !value.equals(attribute.value) : attribute.value != null);\n+        return val != null ? val.equals(attribute.val) : attribute.val == null;\n     }\n \n     @Override\n-    public int hashCode() {\n+    public int hashCode() { // note parent not considered\n         int result = key != null ? key.hashCode() : 0;\n-        result = 31 * result + (value != null ? value.hashCode() : 0);\n+        result = 31 * result + (val != null ? val.hashCode() : 0);\n         return result;\n     }\n \n     @Override\n     public Attribute clone() {\n         try {\n-            return (Attribute) super.clone(); // only fields are immutable strings key and value, so no more deep copy required\n+            return (Attribute) super.clone();\n         } catch (CloneNotSupportedException e) {\n             throw new RuntimeException(e);\n         }\n\n"
    },
    "Compress-1": {
        "Buggy Function": "    public void close() throws IOException {\n        if (!this.closed) {\n            super.close();\n            this.closed = true;\n        }\n    }",
        "Inducing Changes": "diff --git a/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java b/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\nindex f0ad1a9..47fd98b 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n@@ -24,6 +24,8 @@\n \n import org.apache.commons.compress.archivers.ar.ArArchiveInputStream;\n import org.apache.commons.compress.archivers.ar.ArArchiveOutputStream;\n+import org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream;\n+import org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream;\n import org.apache.commons.compress.archivers.jar.JarArchiveInputStream;\n import org.apache.commons.compress.archivers.jar.JarArchiveOutputStream;\n import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n@@ -53,6 +55,8 @@\n         \treturn new TarArchiveInputStream(in);\n         } else if(\"jar\".equalsIgnoreCase(archiverName)) {\n         \treturn new JarArchiveInputStream(in);\n+        } else if(\"cpio\".equalsIgnoreCase(archiverName)) {\n+        \treturn new CpioArchiveInputStream(in);\n         }\n     \treturn null;\n     }\n@@ -66,6 +70,8 @@\n         \treturn new TarArchiveOutputStream(out);\n         } else if(\"jar\".equalsIgnoreCase(archiverName)) {\n         \treturn new JarArchiveOutputStream(out);\n+        } else if(\"cpio\".equalsIgnoreCase(archiverName)) {\n+        \treturn new CpioArchiveOutputStream(out);\n         }\n     \treturn null;\n     }\n@@ -86,6 +92,8 @@\n \t\t\treturn new TarArchiveInputStream(input);\n \t\t} else if(ArArchiveInputStream.matches(signature)) {\n \t\t\treturn new ArArchiveInputStream(input);\n+\t\t} else if(CpioArchiveInputStream.matches(signature)) {\n+\t\t\treturn new CpioArchiveInputStream(input);\n \t\t} \n \t\treturn null;\n \t}\ndiff --git a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream.java b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream.java\nindex 9efdc25..5f4b96c 100644\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream.java\n@@ -565,7 +565,7 @@\n \n         int v, t, i, j, gs, ge, totc, bt, bc, iter;\n         int nSelectors \u003d 0, alphaSize, minLen, maxLen, selCtr;\n-        int nGroups, nBytes;\n+        int nGroups; //, nBytes;\n \n         alphaSize \u003d nInUse + 2;\n         for (t \u003d 0; t \u003c N_GROUPS; t++) {\n@@ -796,7 +796,7 @@\n                 }\n             }\n \n-            nBytes \u003d bytesOut;\n+            //nBytes \u003d bytesOut;\n             for (i \u003d 0; i \u003c 16; i++) {\n                 if (inUse16[i]) {\n                     bsW(1, 1);\n@@ -820,7 +820,7 @@\n         }\n \n         /* Now the selectors. */\n-        nBytes \u003d bytesOut;\n+        //nBytes \u003d bytesOut;\n         bsW (3, nGroups);\n         bsW (15, nSelectors);\n         for (i \u003d 0; i \u003c nSelectors; i++) {\n@@ -831,7 +831,7 @@\n         }\n \n         /* Now the coding tables. */\n-        nBytes \u003d bytesOut;\n+        //nBytes \u003d bytesOut;\n \n         for (t \u003d 0; t \u003c nGroups; t++) {\n             int curr \u003d len[t][0];\n@@ -850,7 +850,7 @@\n         }\n \n         /* And finally, the block data proper */\n-        nBytes \u003d bytesOut;\n+        //nBytes \u003d bytesOut;\n         selCtr \u003d 0;\n         gs \u003d 0;\n         while (true) {\n"
    },
    "Compress-3": {
        "Buggy Function": "public void finish() throws IOException {\n    writeEOFRecord();\n    writeEOFRecord();\n}\npublic void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n    TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n    if (entry.getName().length() >= TarConstants.NAMELEN) {\n\n        if (longFileMode == LONGFILE_GNU) {\n            // create a TarEntry for the LongLink, the contents\n            // of which are the entry's name\n            TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n                                                                TarConstants.LF_GNUTYPE_LONGNAME);\n\n            final byte[] nameBytes = entry.getName().getBytes(); // TODO is it correct to use the default charset here?\n            longLinkEntry.setSize(nameBytes.length + 1); // +1 for NUL\n            putArchiveEntry(longLinkEntry);\n            write(nameBytes);\n            write(0); // NUL terminator\n            closeArchiveEntry();\n        } else if (longFileMode != LONGFILE_TRUNCATE) {\n            throw new RuntimeException(\"file name '\" + entry.getName()\n                                       + \"' is too long ( > \"\n                                       + TarConstants.NAMELEN + \" bytes)\");\n        }\n    }\n\n    entry.writeEntryHeader(recordBuf);\n    buffer.writeRecord(recordBuf);\n\n    currBytes = 0;\n\n    if (entry.isDirectory()) {\n        currSize = 0;\n    } else {\n        currSize = entry.getSize();\n    }\n    currName = entry.getName();\n}\npublic void closeArchiveEntry() throws IOException {\n    if (assemLen > 0) {\n        for (int i = assemLen; i < assemBuf.length; ++i) {\n            assemBuf[i] = 0;\n        }\n\n        buffer.writeRecord(assemBuf);\n\n        currBytes += assemLen;\n        assemLen = 0;\n    }\n\n    if (currBytes < currSize) {\n        throw new IOException(\"entry '\" + currName + \"' closed at '\"\n                              + currBytes\n                              + \"' before the '\" + currSize\n                              + \"' bytes specified in the header were written\");\n    }\n}",
        "Inducing Changes": "diff --git a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveOutputStream.java b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveOutputStream.java\nindex ee7ecee..8a48da5 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveOutputStream.java\n@@ -163,4 +163,10 @@\n         return new ArArchiveEntry(inputFile, entryName);\n     }\n \n+    /* (non-Javadoc)\n+     * @see org.apache.commons.compress.archivers.ArchiveOutputStream#finish()\n+     */\n+    public void finish() throws IOException {\n+        // Nothing to do\n+    }\n }\n\n"
    },
    "Closure-153": {
        "Buggy Function": "    //buggy function from src/com/google/javascript/jscomp/Normalize.java\n    @Override\n    public void onRedeclaration(\n        Scope s, String name, Node n, Node parent, Node gramps,\n        Node nodeWithLineNumber) {\n      Preconditions.checkState(n.getType() == Token.NAME);\n      Var v = s.getVar(name);\n      // If name is \"arguments\", Var maybe null.\n      if (v != null && v.getParentNode().getType() == Token.CATCH) {\n        // Redeclaration of a catch expression variable is hard to model\n        // without support for \"with\" expressions.\n        // The EcmaScript spec (section 12.14), declares that a catch\n        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n        // \"var e\" would refer to the scope variable, but any following\n        // reference would still refer to \"e\" of the catch expression.\n        // Until we have support for this disallow it.\n        // Currently the Scope object adds the catch expression to the\n        // function scope, which is technically not true but a good\n        // approximation for most uses.\n\n        // TODO(johnlenz): Consider improving how scope handles catch\n        // expression.\n\n        // Use the name of the var before it was made unique.\n        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(\n            name);\n        compiler.report(\n            JSError.make(\n                NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber,\n                CATCH_BLOCK_VAR_ERROR, name));\n      } else if (v != null && parent.getType() == Token.FUNCTION) {\n        if (v.getParentNode().getType() == Token.VAR) {\n          s.undeclare(v);\n          s.declare(name, n, n.getJSType(), v.input);\n          replaceVarWithAssignment(v.getNameNode(), v.getParentNode(),\n              v.getParentNode().getParent());\n        }\n      } else if (parent.getType() == Token.VAR) {\n        Preconditions.checkState(parent.hasOneChild());\n\n        replaceVarWithAssignment(n, parent, gramps);\n      }\n    }\n    //buggy function from src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n  private void scanRoot(Node n, Scope parent) {\n    if (n.getType() == Token.FUNCTION) {\n      sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n\n      final Node fnNameNode = n.getFirstChild();\n      final Node args = fnNameNode.getNext();\n      final Node body = args.getNext();\n\n      // Bleed the function name into the scope, if it hasn't\n      // been declared in the outer scope.\n      String fnName = fnNameNode.getString();\n      if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n        declareVar(fnName, fnNameNode, n, null, null, n);\n      }\n\n      // Args: Declare function variables\n      Preconditions.checkState(args.getType() == Token.LP);\n      for (Node a = args.getFirstChild(); a != null;\n           a = a.getNext()) {\n        Preconditions.checkState(a.getType() == Token.NAME);\n        declareVar(a.getString(), a, args, n, null, n);\n      }\n\n      // Body\n      scanVars(body, n);\n    } else {\n      // It's the global block\n      Preconditions.checkState(scope.getParent() == null);\n      scanVars(n, null);\n    }\n  }\n  private void scanVars(Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.VAR:\n        // Declare all variables. e.g. var x = 1, y, z;\n        for (Node child = n.getFirstChild();\n             child != null;) {\n          Node next = child.getNext();\n          Preconditions.checkState(child.getType() == Token.NAME);\n          String name = child.getString();\n          declareVar(name, child, n, parent, null, n);\n          child = next;\n        }\n        return;\n\n      case Token.FUNCTION:\n        if (NodeUtil.isFunctionExpression(n)) {\n          return;\n        }\n\n        String fnName = n.getFirstChild().getString();\n        if (fnName.isEmpty()) {\n          // This is invalid, but allow it so the checks can catch it.\n          return;\n        }\n        declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n        return;   // should not examine function's children\n\n      case Token.CATCH:\n        Preconditions.checkState(n.getChildCount() == 2);\n        Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n        // the first child is the catch var and the third child\n        // is the code block\n\n        final Node var = n.getFirstChild();\n        final Node block = var.getNext();\n\n        declareVar(var.getString(), var, n, parent, null, n);\n        scanVars(block, n);\n        return;  // only one child to scan\n\n      case Token.SCRIPT:\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n        break;\n    }\n\n    // Variables can only occur in statement-level nodes, so\n    // we only need to traverse children in a couple special cases.\n    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n      for (Node child = n.getFirstChild();\n           child != null;) {\n        Node next = child.getNext();\n        scanVars(child, n);\n        child = next;\n      }\n    }\n  }\n  interface RedeclarationHandler {\n    void onRedeclaration(\n        Scope s, String name,\n        Node n, Node parent, Node gramps, Node nodeWithLineNumber);\n  }\n\n  private class DefaultRedeclarationHandler implements RedeclarationHandler {\n    public void onRedeclaration(\n        Scope s, String name,\n        Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n\n      // Don't allow multiple variables to be declared at the top level scope\n      if (scope.isGlobal()) {\n        Scope.Var origVar = scope.getVar(name);\n        Node origParent = origVar.getParentNode();\n        if (origParent.getType() == Token.CATCH &&\n            parent.getType() == Token.CATCH) {\n          // Okay, both are 'catch(x)' variables.\n          return;\n        }\n\n        boolean allowDupe = false;\n        JSDocInfo info = n.getJSDocInfo();\n        if (info == null) {\n          info = parent.getJSDocInfo();\n        }\n        allowDupe =\n            info != null && info.getSuppressions().contains(\"duplicate\");\n\n        if (!allowDupe) {\n          compiler.report(\n              JSError.make(sourceName, n,\n                           VAR_MULTIPLY_DECLARED_ERROR,\n                           name,\n                           (origVar.input != null\n                            ? origVar.input.getName()\n                            : \"??\")));\n        }\n      } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n        // Disallow shadowing \"arguments\" as we can't handle with our current\n        // scope modeling.\n        compiler.report(\n            JSError.make(sourceName, n,\n                VAR_ARGUMENTS_SHADOWED_ERROR));\n      }\n    }\n  }\n  private void declareVar(String name, Node n, Node parent,\n                          Node gramps, JSType declaredType,\n                          Node nodeWithLineNumber) {\n\n    if (scope.isDeclared(name, false)\n        || (scope.isLocal() && name.equals(ARGUMENTS))) {\n      redeclarationHandler.onRedeclaration(\n          scope, name, n, parent, gramps, nodeWithLineNumber);\n    } else {\n      scope.declare(name, n, declaredType, compiler.getInput(sourceName));\n    }\n  }",
        "Inducing Changes": "diff --git a/src/com/google/javascript/jscomp/Normalize.java b/src/com/google/javascript/jscomp/Normalize.java\nindex ef59237..d93860d 100644\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n@@ -124,7 +124,7 @@\n     //   }\n     // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n     // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    removeDuplicateDeclarations(root);\n+    removeDuplicateDeclarations(externs, root);\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n \n@@ -548,12 +548,12 @@\n   /**\n    * Remove duplicate VAR declarations.\n    */\n-  private void removeDuplicateDeclarations(Node root) {\n+  private void removeDuplicateDeclarations(Node externs, Node root) {\n     Callback tickler = new ScopeTicklingCallback();\n     ScopeCreator scopeCreator =  new SyntacticScopeCreator(\n         compiler, new DuplicateDeclarationHandler());\n     NodeTraversal t = new NodeTraversal(compiler, tickler, scopeCreator);\n-    t.traverse(root);\n+    t.traverseRoots(externs, root);\n   }\n \n   /**\n\n"
    },
    "Closure-170": {
        "Buggy Function": "private void getNumUseInUseCfgNode(Node n) {\n\n  AbstractCfgNodeTraversalCallback gatherCb =\n      new AbstractCfgNodeTraversalCallback() {\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.isName() && n.getString().equals(varName) &&\n          // do not count in if it is left child of an assignment operator\n          !(parent.isAssign() &&\n           (parent.getFirstChild() == n))) {\n        numUseWithinUseCfgNode++;\n      }\n    }\n  };\n\n  NodeTraversal.traverse(compiler, n, gatherCb);\n}\n}",
        "Inducing Changes": "diff --git a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\nindex 69d78e2..ecc1509 100644\n--- a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n@@ -422,7 +422,10 @@\n \n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n-          if (NodeUtil.isName(n) && n.getString().equals(varName)) {\n+          if (NodeUtil.isName(n) && n.getString().equals(varName) &&\n+              // do not count in if it is left child of an assignment operator\n+              !(NodeUtil.isAssign(parent) &&\n+               (parent.getFirstChild() == n))) {\n             numUseWithinUseCfgNode++;\n           }\n         }\n\n"
    },
    "Time-5": {
        "Buggy Function": "    public Period normalizedStandard(PeriodType type) {\n        type = DateTimeUtils.getPeriodType(type);\n        long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs\n        millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n        millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n        millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n        millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n        millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n        Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n        int years = getYears();\n        int months = getMonths();\n        if (years != 0 || months != 0) {\n            years = FieldUtils.safeAdd(years, months / 12);\n            months = months % 12;\n            if (years != 0) {\n                result = result.withYears(years);\n            }\n            if (months != 0) {\n                result = result.withMonths(months);\n            }\n        }\n        return result;\n    }",
        "Inducing Changes": "diff --git a/JodaTime/src/java/org/joda/time/Period.java b/JodaTime/src/java/org/joda/time/Period.java\nindex 8cb6ee4..d66b44a 100644\n--- a/JodaTime/src/java/org/joda/time/Period.java\n+++ b/JodaTime/src/java/org/joda/time/Period.java\n@@ -18,6 +18,7 @@\n import java.io.Serializable;\n \n import org.joda.time.base.BasePeriod;\n+import org.joda.time.chrono.ISOChronology;\n import org.joda.time.field.FieldUtils;\n \n /**\n@@ -930,7 +931,7 @@\n      * \u003cp\u003e\n      * Each field of the period is added separately. Thus a period of\n      * 2 hours 30 minutes plus 3 hours 40 minutes will produce a result\n-     * of 5 hours 70 minutes.\n+     * of 5 hours 70 minutes - see {@link #normalizedStandard()}.\n      * \u003cp\u003e\n      * If the period being added contains a non-zero amount for a field that\n      * is not supported in this period then an exception is thrown.\n@@ -1109,7 +1110,7 @@\n      * \u003cp\u003e\n      * Each field of the period is subtracted separately. Thus a period of\n      * 3 hours 30 minutes minus 2 hours 40 minutes will produce a result\n-     * of 1 hour and -10 minutes.\n+     * of 1 hour and -10 minutes - see {@link #normalizedStandard()}.\n      * \u003cp\u003e\n      * If the period being added contains a non-zero amount for a field that\n      * is not supported in this period then an exception is thrown.\n@@ -1441,4 +1442,89 @@\n         }\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Normalizes this period using standard rules, assuming a 12 month year,\n+     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n+     * \u003cp\u003e\n+     * This method allows you to normalize a period.\n+     * However to achieve this it makes the assumption that all years are\n+     * 12 months, all weeks are 7 days, all days are 24 hours,\n+     * all hours are 60 minutes and all minutes are 60 seconds. This is not\n+     * true when daylight savings time is considered, and may also not be true\n+     * for some chronologies. However, it is included as it is a useful operation\n+     * for many applications and business rules.\n+     * \u003cp\u003e\n+     * If the period contains years or months, then the months will be\n+     * normalized to be between 0 and 11. The days field and below will be\n+     * normalized as necessary, however this will not overflow into the months\n+     * field. Thus a period of 1 year 15 months will normalize to 2 years 3 months.\n+     * But a period of 1 month 40 days will remain as 1 month 40 days.\n+     * \u003cp\u003e\n+     * The result will always have a \u003ccode\u003ePeriodType\u003c/code\u003e of standard, thus\n+     * days will be grouped into weeks.\n+     * \n+     * @return a normalized period equivalent to this period\n+     * @throws ArithmeticException if any field is too large to be represented\n+     * @since 1.5\n+     */\n+    public Period normalizedStandard() {\n+        return normalizedStandard(PeriodType.standard());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Normalizes this period using standard rules, assuming a 12 month year,\n+     * 7 day week, 24 hour day, 60 minute hour and 60 second minute,\n+     * providing control over how the result is split into fields.\n+     * \u003cp\u003e\n+     * This method allows you to normalize a period.\n+     * However to achieve this it makes the assumption that all years are\n+     * 12 months, all weeks are 7 days, all days are 24 hours,\n+     * all hours are 60 minutes and all minutes are 60 seconds. This is not\n+     * true when daylight savings time is considered, and may also not be true\n+     * for some chronologies. However, it is included as it is a useful operation\n+     * for many applications and business rules.\n+     * \u003cp\u003e\n+     * If the period contains years or months, then the months will be\n+     * normalized to be between 0 and 11. The days field and below will be\n+     * normalized as necessary, however this will not overflow into the months\n+     * field. Thus a period of 1 year 15 months will normalize to 2 years 3 months.\n+     * But a period of 1 month 40 days will remain as 1 month 40 days.\n+     * \u003cp\u003e\n+     * The PeriodType parameter controls how the result is created. It allows\n+     * you to omit certain fields from the result if desired. For example,\n+     * you may not want the result to include weeks, in which case you pass\n+     * in \u003ccode\u003ePeriodType.yearMonthDayTime()\u003c/code\u003e.\n+     * \n+     * @param type  the period type of the new period, null means standard type\n+     * @return a normalized period equivalent to this period\n+     * @throws ArithmeticException if any field is too large to be represented\n+     * @throws UnsupportedOperationException if this period contains non-zero\n+     *  years or months but the specified period type does not support them\n+     * @since 1.5\n+     */\n+    public Period normalizedStandard(PeriodType type) {\n+        long millis \u003d getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs\n+        millis +\u003d (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n+        millis +\u003d (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n+        millis +\u003d (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n+        millis +\u003d (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n+        millis +\u003d (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n+        Period result \u003d new Period(millis, DateTimeUtils.getPeriodType(type), ISOChronology.getInstanceUTC());\n+        int years \u003d getYears();\n+        int months \u003d getMonths();\n+        if (years !\u003d 0 || months !\u003d 0) {\n+            years \u003d FieldUtils.safeAdd(years, months / 12);\n+            months \u003d months % 12;\n+            if (years !\u003d 0) {\n+                result \u003d result.withYears(years);\n+            }\n+            if (months !\u003d 0) {\n+                result \u003d result.withMonths(months);\n+            }\n+        }\n+        return result;\n+    }\n+\n }\ndiff --git a/JodaTime/src/java/org/joda/time/PeriodType.java b/JodaTime/src/java/org/joda/time/PeriodType.java\nindex e4431f3..94c4118 100644\n--- a/JodaTime/src/java/org/joda/time/PeriodType.java\n+++ b/JodaTime/src/java/org/joda/time/PeriodType.java\n@@ -682,12 +682,12 @@\n      * @param index  the index to use\n      * @param values  the array to populate\n      * @param newValue  the value to set\n-     * @throws IllegalArgumentException if not supported\n+     * @throws UnsupportedOperationException if not supported\n      */\n     boolean setIndexedField(ReadablePeriod period, int index, int[] values, int newValue) {\n         int realIndex \u003d iIndices[index];\n         if (realIndex \u003d\u003d -1) {\n-            throw new IllegalArgumentException(\"Field is not supported\");\n+            throw new UnsupportedOperationException(\"Field is not supported\");\n         }\n         values[realIndex] \u003d newValue;\n         return true;\n"
    },
    "Time-15": {
        "Buggy Function": "    public static long safeMultiply(long val1, int val2) {\n        switch (val2) {\n            case -1:\n                return -val1;\n            case 0:\n                return 0L;\n            case 1:\n                return val1;\n        }\n        long total = val1 * val2;\n        if (total / val2 != val1) {\n          throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n        return total;\n    }",
        "Inducing Changes": "diff --git a/JodaTime/src/java/org/joda/time/field/FieldUtils.java b/JodaTime/src/java/org/joda/time/field/FieldUtils.java\nindex 24ebf1e..8fd0be2 100644\n--- a/JodaTime/src/java/org/joda/time/field/FieldUtils.java\n+++ b/JodaTime/src/java/org/joda/time/field/FieldUtils.java\n@@ -113,10 +113,57 @@\n      * @param val2  the second value\n      * @return the new total\n      * @throws ArithmeticException if the value is too big or too small\n+     * @since 1.2\n+     */\n+    public static int safeMultiply(int val1, int val2) {\n+        long total = (long) val1 * (long) val2;\n+        if (total < Integer.MIN_VALUE || total > Integer.MAX_VALUE) {\n+            throw new ArithmeticException\n+                (\"The calculation caused an overflow: \" + val1 + \" * \" + val2);\n+        }\n+        return (int) total;\n+    }\n+\n+    /**\n+     * Multiply two values throwing an exception if overflow occurs.\n+     * \n+     * @param val1  the first value\n+     * @param scalar  the second value\n+     * @return the new total\n+     * @throws ArithmeticException if the value is too big or too small\n+     * @since 1.2\n+     */\n+    public static long safeMultiply(long val1, int scalar) {\n+        switch (scalar) {\n+        case -1:\n+            return -val1;\n+        case 0:\n+            return 0L;\n+        case 1:\n+            return val1;\n+        }\n+        long total = val1 * scalar;\n+        if (total / scalar != val1) {\n+            throw new ArithmeticException\n+                (\"The calculation caused an overflow: \" + val1 + \" * \" + scalar);\n+        }\n+        return total;\n+    }\n+\n+    /**\n+     * Multiply two values throwing an exception if overflow occurs.\n+     * \n+     * @param val1  the first value\n+     * @param val2  the second value\n+     * @return the new total\n+     * @throws ArithmeticException if the value is too big or too small\n      */\n     public static long safeMultiply(long val1, long val2) {\n-        if (val1 == 0 || val2 == 0) {\n-            return 0L;\n+        if (val2 == 1) {\n+            return val1;\n+        }\n+        if (val2 == 0) {\n+            return 0;\n         }\n         long total = val1 * val2;\n         if (total / val2 != val1) {\n"
    },
    "Cli-29": {
        "Buggy Function": "    static String stripLeadingAndTrailingQuotes(String str)\n    {\n        if (str.startsWith(\"\\\"\"))\n        {\n            str = str.substring(1, str.length());\n        }\n        int length = str.length();\n        if (str.endsWith(\"\\\"\"))\n        {\n            str = str.substring(0, length - 1);\n        }\n        \n        return str;\n    }",
        "Inducing Changes": "diff --git a/src/java/org/apache/commons/cli/Util.java b/src/java/org/apache/commons/cli/Util.java\nindex 1e04149..7f5944e 100644\n--- a/src/java/org/apache/commons/cli/Util.java\n+++ b/src/java/org/apache/commons/cli/Util.java\n@@ -1,7 +1,7 @@\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//cli/src/java/org/apache/commons/cli/Util.java,v 1.2 2002/12/09 23:47:25 jkeyes Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/12/09 23:47:25 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//cli/src/java/org/apache/commons/cli/Util.java,v 1.3 2003/01/17 20:00:14 jkeyes Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2003/01/17 20:00:14 $\n  *\n  * ====================================================================\n  *\n@@ -73,8 +73,7 @@\n      *\n      * @param str The string from which the hyphens should be removed.\n      *\n-     * @return the hyphens from the begining of <code>str</code> and\n-     * return the new String.\n+     * @return the new String.\n      */\n     static String stripLeadingHyphens(String str)\n     {\n@@ -89,4 +88,24 @@\n \n         return str;\n     }\n+\n+    /**\n+     * <p>Remove the leading and trailing quotes from <code>str</code>,\n+     * e.g. if str is '\"one two\"', then 'one two' is returned.</p>\n+     *\n+     * @param str The string from which the leading and trailing quotes\n+     * should be removed.\n+     *\n+     * @return The string without the leading and trailing quotes.\n+     */\n+    static String stripLeadingAndTrailingQuotes(String str)\n+    {\n+        if (str.startsWith(\"\\\"\")) {\n+            str = str.substring(1, str.length());\n+        }\n+        if (str.endsWith(\"\\\"\")) {\n+            str = str.substring(0, str.length()-1);\n+        }\n+        return str;\n+    }\n }\n\\ No newline at end of file\n\n"
    },
    "Closure-27": {
        "Buggy Function": "",
        "Inducing Changes": ""
    },
    "Codec-10": {
        "Buggy Function": "    public String caverphone(String txt) {\n        // NOTE: Version 1.0 of Caverphone is easily derivable from this code \n        // by commenting out the 2.0 lines and adding in the 1.0 lines\n\n        if( txt == null || txt.length() == 0 ) {\n            return \"1111111111\";\n        }\n\n        // 1. Convert to lowercase\n        txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n\n        // 2. Remove anything not A-Z\n        txt = txt.replaceAll(\"[^a-z]\", \"\");\n\n        // 2.5. Remove final e\n        txt = txt.replaceAll(\"e$\", \"\");             // 2.0 only\n\n        // 3. Handle various start options\n        txt = txt.replaceAll(\"^cough\", \"cou2f\");\n        txt = txt.replaceAll(\"^rough\", \"rou2f\");\n        txt = txt.replaceAll(\"^tough\", \"tou2f\");\n        txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n        txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n        txt = txt.replaceAll(\"^gn\", \"2n\");\n\n        // End \n        txt = txt.replaceAll(\"^mb\", \"m2\");\n\n        // 4. Handle replacements\n        txt = txt.replaceAll(\"cq\", \"2q\");\n        txt = txt.replaceAll(\"ci\", \"si\");\n        txt = txt.replaceAll(\"ce\", \"se\");\n        txt = txt.replaceAll(\"cy\", \"sy\");\n        txt = txt.replaceAll(\"tch\", \"2ch\");\n        txt = txt.replaceAll(\"c\", \"k\");\n        txt = txt.replaceAll(\"q\", \"k\");\n        txt = txt.replaceAll(\"x\", \"k\");\n        txt = txt.replaceAll(\"v\", \"f\");\n        txt = txt.replaceAll(\"dg\", \"2g\");\n        txt = txt.replaceAll(\"tio\", \"sio\");\n        txt = txt.replaceAll(\"tia\", \"sia\");\n        txt = txt.replaceAll(\"d\", \"t\");\n        txt = txt.replaceAll(\"ph\", \"fh\");\n        txt = txt.replaceAll(\"b\", \"p\");\n        txt = txt.replaceAll(\"sh\", \"s2\");\n        txt = txt.replaceAll(\"z\", \"s\");\n        txt = txt.replaceAll(\"^[aeiou]\", \"A\");\n        txt = txt.replaceAll(\"[aeiou]\", \"3\");\n        txt = txt.replaceAll(\"j\", \"y\");        // 2.0 only\n        txt = txt.replaceAll(\"^y3\", \"Y3\");     // 2.0 only\n        txt = txt.replaceAll(\"^y\", \"A\");       // 2.0 only\n        txt = txt.replaceAll(\"y\", \"3\");        // 2.0 only\n        txt = txt.replaceAll(\"3gh3\", \"3kh3\");\n        txt = txt.replaceAll(\"gh\", \"22\");\n        txt = txt.replaceAll(\"g\", \"k\");\n        txt = txt.replaceAll(\"s+\", \"S\");\n        txt = txt.replaceAll(\"t+\", \"T\");\n        txt = txt.replaceAll(\"p+\", \"P\");\n        txt = txt.replaceAll(\"k+\", \"K\");\n        txt = txt.replaceAll(\"f+\", \"F\");\n        txt = txt.replaceAll(\"m+\", \"M\");\n        txt = txt.replaceAll(\"n+\", \"N\");\n        txt = txt.replaceAll(\"w3\", \"W3\");\n        //txt = txt.replaceAll(\"wy\", \"Wy\");    // 1.0 only\n        txt = txt.replaceAll(\"wh3\", \"Wh3\");\n        txt = txt.replaceAll(\"w$\", \"3\");       // 2.0 only\n        //txt = txt.replaceAll(\"why\", \"Why\");  // 1.0 only\n        txt = txt.replaceAll(\"w\", \"2\");\n        txt = txt.replaceAll(\"^h\", \"A\");\n        txt = txt.replaceAll(\"h\", \"2\");\n        txt = txt.replaceAll(\"r3\", \"R3\");\n        txt = txt.replaceAll(\"r$\", \"3\");       // 2.0 only\n        //txt = txt.replaceAll(\"ry\", \"Ry\");    // 1.0 only\n        txt = txt.replaceAll(\"r\", \"2\");\n        txt = txt.replaceAll(\"l3\", \"L3\");\n        txt = txt.replaceAll(\"l$\", \"3\");       // 2.0 only\n        //txt = txt.replaceAll(\"ly\", \"Ly\");    // 1.0 only\n        txt = txt.replaceAll(\"l\", \"2\");\n        //txt = txt.replaceAll(\"j\", \"y\");      // 1.0 only\n        //txt = txt.replaceAll(\"y3\", \"Y3\");    // 1.0 only\n        //txt = txt.replaceAll(\"y\", \"2\");      // 1.0 only\n\n        // 5. Handle removals\n        txt = txt.replaceAll(\"2\", \"\");\n        txt = txt.replaceAll(\"3$\", \"A\");       // 2.0 only\n        txt = txt.replaceAll(\"3\", \"\");\n\n        // 6. put ten 1s on the end\n        txt = txt + \"111111\" + \"1111\";        // 1.0 only has 6 1s\n\n        // 7. take the first six characters as the code\n        return txt.substring(0, 10);          // 1.0 truncates to 6\n    }",
        "Inducing Changes": "Add Whole Class File of buggy method"
    },
    "Codec-18": {
        "Buggy Function": "    public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n        if (cs1 == cs2) {\n            return true;\n        }\n        if (cs1 == null || cs2 == null) {\n            return false;\n        }\n        if (cs1 instanceof String && cs2 instanceof String) {\n            return cs1.equals(cs2);\n        }\n        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n    }",
        "Inducing Changes": "diff --git a/src/main/java/org/apache/commons/codec/binary/StringUtils.java b/src/main/java/org/apache/commons/codec/binary/StringUtils.java\nindex 14a362f..8f1f57f 100644\n--- a/src/main/java/org/apache/commons/codec/binary/StringUtils.java\n+++ b/src/main/java/org/apache/commons/codec/binary/StringUtils.java\n@@ -38,6 +38,49 @@\n public class StringUtils {\n \n     /**\n+     * <p>\n+     * Compares two CharSequences, returning {@code true} if they represent equal sequences of characters.\n+     * </p>\n+     * \n+     * <p>\n+     * {@code null}s are handled without exceptions. Two {@code null} references are considered to be equal. The\n+     * comparison is case sensitive.\n+     * </p>\n+     * \n+     * <pre>\n+     * StringUtils.equals(null, null)   = true\n+     * StringUtils.equals(null, \"abc\")  = false\n+     * StringUtils.equals(\"abc\", null)  = false\n+     * StringUtils.equals(\"abc\", \"abc\") = true\n+     * StringUtils.equals(\"abc\", \"ABC\") = false\n+     * </pre>\n+     * \n+     * <p>\n+     * Copied from Apache Commons Lang r1583482 on April 10, 2014 (day of 3.3.2 release).\n+     * </p>\n+     * \n+     * @see Object#equals(Object)\n+     * @param cs1\n+     *            the first CharSequence, may be {@code null}\n+     * @param cs2\n+     *            the second CharSequence, may be {@code null}\n+     * @return {@code true} if the CharSequences are equal (case-sensitive), or both {@code null}\n+     * @since 1.10\n+     */\n+    public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n+        if (cs1 == cs2) {\n+            return true;\n+        }\n+        if (cs1 == null || cs2 == null) {\n+            return false;\n+        }\n+        if (cs1 instanceof String && cs2 instanceof String) {\n+            return cs1.equals(cs2);\n+        }\n+        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n+    }\n+\n+    /**\n      * Calls {@link String#getBytes(Charset)}\n      *\n      * @param string\n\n"
    },
    "Compress-26": {
        "Buggy Function": "    public static long skip(InputStream input, long numToSkip) throws IOException {\n        long available = numToSkip;\n        while (numToSkip > 0) {\n            long skipped = input.skip(numToSkip);\n            if (skipped == 0) {\n                break;\n            }\n            numToSkip -= skipped;\n        }\n            \n        return available - numToSkip;\n    }",
        "Inducing Changes": "diff --git a/src/main/java/org/apache/commons/compress/utils/IOUtils.java b/src/main/java/org/apache/commons/compress/utils/IOUtils.java\nindex a4355bc..5250605 100644\n--- a/src/main/java/org/apache/commons/compress/utils/IOUtils.java\n+++ b/src/main/java/org/apache/commons/compress/utils/IOUtils.java\n@@ -70,7 +70,30 @@\n         }\n         return count;\n     }\n+    \n+    /**\n+     * Skips the given number of bytes by repeatedly invoking skip on\n+     * the given input stream if necessary.\n+     *\n+     * <p>This method will only skip less than the requested number of\n+     * bytes if the end of the input stream has been reached.</p>\n \n+     * @param input stream to skip bytes in\n+     * @param numToSkip the number of bytes to skip\n+     * @return the number of bytes actually skipped\n+     * @throws IOException\n+     */\n+    public static long skip(InputStream input, long numToSkip) throws IOException {\n+        long available = numToSkip;\n+        while (numToSkip > 0) {\n+            long skipped = input.skip(numToSkip);\n+            if (skipped == 0) {\n+                break;\n+            }\n+            numToSkip -= skipped;\n+        }\n+        return (available - numToSkip);\n+    }\n \n     // toByteArray(InputStream) copied from:\n     // commons/proper/io/trunk/src/main/java/org/apache/commons/io/IOUtils.java?revision=1428941\n\n"
    },
    "Compress-39": {
        "Buggy Function": "public static String sanitize(String s) {\n    final char[] chars = s.toCharArray();\n    final int len = chars.length;\n    final StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < len; i++) {\n        final char c = chars[i];\n        if (!Character.isISOControl(c)) {\n            Character.UnicodeBlock block = Character.UnicodeBlock.of(c);\n            if (block != null && block != Character.UnicodeBlock.SPECIALS) {\n                sb.append(c);\n                continue;\n            }\n        }\n        sb.append('?');\n    }\n    return sb.toString();\n}",
        "Inducing Changes": "diff --git a/src/main/java/org/apache/commons/compress/utils/ArchiveUtils.java b/src/main/java/org/apache/commons/compress/utils/ArchiveUtils.java\nindex e39e4f3..107bf0b 100644\n--- a/src/main/java/org/apache/commons/compress/utils/ArchiveUtils.java\n+++ b/src/main/java/org/apache/commons/compress/utils/ArchiveUtils.java\n@@ -251,4 +251,37 @@\n         }\n         return true;\n     }\n+\n+    /**\n+     * Returns a \"sanitized\" version of the string given as arguments,\n+     * where sanitized means non-printable characters have been\n+     * replaced with a question mark.\n+     *\n+     * <p>This method is used to clean up file names when they are\n+     * used in exception messages as they may end up in log files or\n+     * as console output and may have been read from a corrupted\n+     * input.</p>\n+     *\n+     * @param s the string to sanitize\n+     * @return a sanitized version of the argument\n+     * @since Compress 1.12\n+     */\n+    public static String sanitize(String s) {\n+        final char[] chars = s.toCharArray();\n+        final int len = chars.length;\n+        final StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < len; i++) {\n+            final char c = chars[i];\n+            if (!Character.isISOControl(c)) {\n+                Character.UnicodeBlock block = Character.UnicodeBlock.of(c);\n+                if (block != null && block != Character.UnicodeBlock.SPECIALS) {\n+                    sb.append(c);\n+                    continue;\n+                }\n+            }\n+            sb.append('?');\n+        }\n+        return sb.toString();\n+    }\n+\n }\n\n"
    },
    "Compress-44": {
        "Buggy Function": "    public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {\n\n\n\n        this.checksum = checksum;\n        this.in = in;\n    }",
        "Inducing Changes": "diff --git a/src/main/java/org/apache/commons/compress/utils/ChecksumCalculatingInputStream.java b/src/main/java/org/apache/commons/compress/utils/ChecksumCalculatingInputStream.java\nnew file mode 100644\nindex 0000000..a698196\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/utils/ChecksumCalculatingInputStream.java\n@@ -0,0 +1,97 @@\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.utils;\n+\n+import java.io.FilterInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.zip.Checksum;\n+\n+/**\n+ * A stream that calculates the checksum of the data read.\n+ * @NotThreadSafe\n+ * @since 1.14\n+ */\n+public class ChecksumCalculatingInputStream extends InputStream {\n+    private final InputStream in;\n+    private final Checksum checksum;\n+\n+    public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {\n+        this.checksum = checksum;\n+        this.in = in;\n+    }\n+\n+    /**\n+     * Reads a single byte from the stream\n+     * @throws IOException if the underlying stream throws or the\n+     * stream is exhausted and the Checksum doesn't match the expected\n+     * value\n+     */\n+    @Override\n+    public int read() throws IOException {\n+        final int ret = in.read();\n+        if (ret >= 0) {\n+            checksum.update(ret);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Reads a byte array from the stream\n+     * @throws IOException if the underlying stream throws or the\n+     * stream is exhausted and the Checksum doesn't match the expected\n+     * value\n+     */\n+    @Override\n+    public int read(final byte[] b) throws IOException {\n+        return read(b, 0, b.length);\n+    }\n+\n+    /**\n+     * Reads from the stream into a byte array.\n+     * @throws IOException if the underlying stream throws or the\n+     * stream is exhausted and the Checksum doesn't match the expected\n+     * value\n+     */\n+    @Override\n+    public int read(final byte[] b, final int off, final int len) throws IOException {\n+        final int ret = in.read(b, off, len);\n+        if (ret >= 0) {\n+            checksum.update(b, off, ret);\n+        }\n+        return ret;\n+    }\n+\n+    @Override\n+    public long skip(final long n) throws IOException {\n+        // Can't really skip, we have to hash everything to verify the checksum\n+        if (read() >= 0) {\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * Returns the calculated checksum.\n+     * @return the calculated checksum.\n+     */\n+    public long getValue() {\n+        return checksum.getValue();\n+    }\n+\n+}\n"
    },
    "Compress-7": {
        "Buggy Function": "    public static String parseName(byte[] buffer, final int offset, final int length) {\n        StringBuffer result = new StringBuffer(length);\n        int          end = offset + length;\n\n        for (int i = offset; i < end; ++i) {\n            if (buffer[i] == 0) {\n                break;\n            }\n            result.append((char) buffer[i]);\n        }\n\n        return result.toString();\n    }",
        "Inducing Changes": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\nindex 523f9f7..05faa64 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n@@ -20,142 +20,49 @@\n \n /**\n  * This class provides static utility methods to work with byte streams.\n+ *\n  */\n-class TarUtils\n-{\n-    /**\n-     * Parse the checksum octal integer from a header buffer.\n-     *\n-     * @param offset The offset into the buffer from which to parse.\n-     * @param length The number of header bytes to parse.\n-     * @param value Description of Parameter\n-     * @param buf Description of Parameter\n-     * @return The integer value of the entry's checksum.\n-     */\n-    public static int getCheckSumOctalBytes( final long value,\n-                                             final byte[] buf,\n-                                             final int offset,\n-                                             final int length )\n-    {\n-        getOctalBytes( value, buf, offset, length );\n+// CheckStyle:HideUtilityClassConstructorCheck OFF (bc)\n+public class TarUtils {\n \n-        buf[ offset + length - 1 ] = (byte)' ';\n-        buf[ offset + length - 2 ] = 0;\n-\n-        return offset + length;\n-    }\n+    private static final int BYTE_MASK = 255;\n \n     /**\n-     * Parse an octal long integer from a header buffer.\n+     * Parse an octal string from a header buffer. This is used for the\n+     * file permission mode value.\n      *\n+     * @param header The header buffer from which to parse.\n      * @param offset The offset into the buffer from which to parse.\n      * @param length The number of header bytes to parse.\n-     * @param value Description of Parameter\n-     * @param buf Description of Parameter\n-     * @return The long value of the octal bytes.\n+     * @return The long value of the octal string.\n      */\n-    public static int getLongOctalBytes( final long value,\n-                                         final byte[] buf,\n-                                         final int offset,\n-                                         final int length )\n-    {\n-        byte[] temp = new byte[ length + 1 ];\n+    public static long parseOctal(byte[] header, int offset, int length) {\n+        long    result = 0;\n+        boolean stillPadding = true;\n+        int     end = offset + length;\n \n-        getOctalBytes( value, temp, 0, length + 1 );\n-        System.arraycopy( temp, 0, buf, offset, length );\n-\n-        return offset + length;\n-    }\n-\n-    /**\n-     * Determine the number of bytes in an entry name.\n-     *\n-     * @param offset The offset into the buffer from which to parse.\n-     * @param length The number of header bytes to parse.\n-     * @param name Description of Parameter\n-     * @param buffer Description of Parameter\n-     * @return The number of bytes in a header's entry name.\n-     */\n-    public static int getNameBytes( final StringBuffer name,\n-                                    final byte[] buffer,\n-                                    final int offset,\n-                                    final int length )\n-    {\n-        int i;\n-\n-        for( i = 0; i < length && i < name.length(); ++i )\n-        {\n-            buffer[ offset + i ] = (byte)name.charAt( i );\n-        }\n-\n-        for( ; i < length; ++i )\n-        {\n-            buffer[ offset + i ] = 0;\n-        }\n-\n-        return offset + length;\n-    }\n-\n-    /**\n-     * Parse an octal integer from a header buffer.\n-     *\n-     * @param offset The offset into the buffer from which to parse.\n-     * @param length The number of header bytes to parse.\n-     * @return The integer value of the octal bytes.\n-     */\n-    public static int getOctalBytes( final long value,\n-                                     final byte[] buffer,\n-                                     final int offset,\n-                                     final int length )\n-    {\n-        int idx = length - 1;\n-\n-        buffer[ offset + idx ] = 0;\n-        --idx;\n-        buffer[ offset + idx ] = (byte)' ';\n-        --idx;\n-\n-        if( value == 0 )\n-        {\n-            buffer[ offset + idx ] = (byte)'0';\n-            --idx;\n-        }\n-        else\n-        {\n-            long val = value;\n-            while( idx >= 0 && val > 0 )\n-            {\n-                buffer[ offset + idx ] = (byte)( (byte)'0' + (byte)( val & 7 ) );\n-                val = val >> 3;\n-                idx--;\n+        for (int i = offset; i < end; ++i) {\n+            if (header[i] == 0) {\n+                break;\n             }\n+\n+            if (header[i] == (byte) ' ' || header[i] == '0') {\n+                if (stillPadding) {\n+                    continue;\n+                }\n+\n+                if (header[i] == (byte) ' ') {\n+                    break;\n+                }\n+            }\n+\n+            stillPadding = false;\n+            // CheckStyle:MagicNumber OFF\n+            result = (result << 3) + (header[i] - '0');\n+            // CheckStyle:MagicNumber ON\n         }\n \n-        while( idx >= 0 )\n-        {\n-            buffer[ offset + idx ] = (byte)' ';\n-            idx--;\n-        }\n-\n-        return offset + length;\n-    }\n-\n-    /**\n-     * Compute the checksum of a tar entry header.\n-     *\n-     * @param buffer The tar entry's header buffer.\n-     * @return The computed checksum.\n-     */\n-    public static long computeCheckSum( final byte[] buffer )\n-    {\n-        long sum = 0;\n-\n-        for( int i = 0; i < buffer.length; ++i )\n-        {\n-            sum += 255 & buffer[ i ];\n-        }\n-\n-        return sum;\n+        return result;\n     }\n \n     /**\n@@ -166,67 +73,129 @@\n      * @param length The number of header bytes to parse.\n      * @return The header's entry name.\n      */\n-    public static StringBuffer parseName( final byte[] header,\n-                                          final int offset,\n-                                          final int length )\n-    {\n-        StringBuffer result = new StringBuffer( length );\n-        int end = offset + length;\n+    public static StringBuffer parseName(byte[] header, int offset, int length) {\n+        StringBuffer result = new StringBuffer(length);\n+        int          end = offset + length;\n \n-        for( int i = offset; i < end; ++i )\n-        {\n-            if( header[ i ] == 0 )\n-            {\n+        for (int i = offset; i < end; ++i) {\n+            if (header[i] == 0) {\n                 break;\n             }\n \n-            result.append( (char)header[ i ] );\n+            result.append((char) header[i]);\n         }\n \n         return result;\n     }\n \n     /**\n-     * Parse an octal string from a header buffer. This is used for the file\n-     * permission mode value.\n+     * Determine the number of bytes in an entry name.\n      *\n-     * @param header The header buffer from which to parse.\n+     * @param name The header name from which to parse.\n+     * @param buf The buffer from which to parse.\n      * @param offset The offset into the buffer from which to parse.\n      * @param length The number of header bytes to parse.\n-     * @return The long value of the octal string.\n+     * @return The number of bytes in a header's entry name.\n      */\n-    public static long parseOctal( final byte[] header,\n-                                   final int offset,\n-                                   final int length )\n-    {\n-        long result = 0;\n-        boolean stillPadding = true;\n-        int end = offset + length;\n+    public static int getNameBytes(StringBuffer name, byte[] buf, int offset, int length) {\n+        int i;\n \n-        for( int i = offset; i < end; ++i )\n-        {\n-            if( header[ i ] == 0 )\n-            {\n-                break;\n-            }\n-\n-            if( header[ i ] == (byte)' ' || header[ i ] == '0' )\n-            {\n-                if( stillPadding )\n-                {\n-                    continue;\n-                }\n-\n-                if( header[ i ] == (byte)' ' )\n-                {\n-                    break;\n-                }\n-            }\n-\n-            stillPadding = false;\n-            result = ( result << 3 ) + ( header[ i ] - '0' );\n+        for (i = 0; i < length && i < name.length(); ++i) {\n+            buf[offset + i] = (byte) name.charAt(i);\n         }\n \n-        return result;\n+        for (; i < length; ++i) {\n+            buf[offset + i] = 0;\n+        }\n+\n+        return offset + length;\n+    }\n+\n+    /**\n+     * Parse an octal integer from a header buffer.\n+     *\n+     * @param value The header value\n+     * @param buf The buffer from which to parse.\n+     * @param offset The offset into the buffer from which to parse.\n+     * @param length The number of header bytes to parse.\n+     * @return The integer value of the octal bytes.\n+     */\n+    public static int getOctalBytes(long value, byte[] buf, int offset, int length) {\n+        int    idx = length - 1;\n+\n+        buf[offset + idx] = 0;\n+        --idx;\n+        buf[offset + idx] = (byte) ' ';\n+        --idx;\n+\n+        if (value == 0) {\n+            buf[offset + idx] = (byte) '0';\n+            --idx;\n+        } else {\n+            for (long val = value; idx >= 0 && val > 0; --idx) {\n+                // CheckStyle:MagicNumber OFF\n+                buf[offset + idx] = (byte) ((byte) '0' + (byte) (val & 7));\n+                val = val >> 3;\n+                // CheckStyle:MagicNumber ON\n+            }\n+        }\n+\n+        for (; idx >= 0; --idx) {\n+            buf[offset + idx] = (byte) ' ';\n+        }\n+\n+        return offset + length;\n+    }\n+\n+    /**\n+     * Parse an octal long integer from a header buffer.\n+     *\n+     * @param value The header value\n+     * @param buf The buffer from which to parse.\n+     * @param offset The offset into the buffer from which to parse.\n+     * @param length The number of header bytes to parse.\n+     * @return The long value of the octal bytes.\n+     */\n+    public static int getLongOctalBytes(long value, byte[] buf, int offset, int length) {\n+        byte[] temp = new byte[length + 1];\n+\n+        getOctalBytes(value, temp, 0, length + 1);\n+        System.arraycopy(temp, 0, buf, offset, length);\n+\n+        return offset + length;\n+    }\n+\n+    /**\n+     * Parse the checksum octal integer from a header buffer.\n+     *\n+     * @param value The header value\n+     * @param buf The buffer from which to parse.\n+     * @param offset The offset into the buffer from which to parse.\n+     * @param length The number of header bytes to parse.\n+     * @return The integer value of the entry's checksum.\n+     */\n+    public static int getCheckSumOctalBytes(long value, byte[] buf, int offset, int length) {\n+        getOctalBytes(value, buf, offset, length);\n+\n+        buf[offset + length - 1] = (byte) ' ';\n+        buf[offset + length - 2] = 0;\n+\n+        return offset + length;\n+    }\n+\n+    /**\n+     * Compute the checksum of a tar entry header.\n+     *\n+     * @param buf The tar entry's header buffer.\n+     * @return The computed checksum.\n+     */\n+    public static long computeCheckSum(byte[] buf) {\n+        long sum = 0;\n+\n+        for (int i = 0; i < buf.length; ++i) {\n+            sum += BYTE_MASK & buf[i];\n+        }\n+\n+        return sum;\n     }\n }\n\n"
    },
    "Compress-8": {
        "Buggy Function": "    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        boolean stillPadding = true;\n        int     end = offset + length;\n        int     start = offset;\n\n        for (int i = start; i < end; i++){\n            final byte currentByte = buffer[i];\n            if (currentByte == 0) {\n                break;\n            }\n\n        // Skip leading spaces\n            if (currentByte == (byte) ' ' || currentByte == '0') {\n                if (stillPadding) {\n                   continue;\n            }\n                if (currentByte == (byte) ' ') {\n                break;\n                }\n            }\n\n        // Must have trailing NUL or space\n        // May have additional NUL or space\n\n            stillPadding = false;\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }",
        "Inducing Changes": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\nindex 523f9f7..05faa64 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n@@ -20,142 +20,49 @@\n \n /**\n  * This class provides static utility methods to work with byte streams.\n+ *\n  */\n-class TarUtils\n-{\n-    /**\n-     * Parse the checksum octal integer from a header buffer.\n-     *\n-     * @param offset The offset into the buffer from which to parse.\n-     * @param length The number of header bytes to parse.\n-     * @param value Description of Parameter\n-     * @param buf Description of Parameter\n-     * @return The integer value of the entry's checksum.\n-     */\n-    public static int getCheckSumOctalBytes( final long value,\n-                                             final byte[] buf,\n-                                             final int offset,\n-                                             final int length )\n-    {\n-        getOctalBytes( value, buf, offset, length );\n+// CheckStyle:HideUtilityClassConstructorCheck OFF (bc)\n+public class TarUtils {\n \n-        buf[ offset + length - 1 ] = (byte)' ';\n-        buf[ offset + length - 2 ] = 0;\n-\n-        return offset + length;\n-    }\n+    private static final int BYTE_MASK = 255;\n \n     /**\n-     * Parse an octal long integer from a header buffer.\n+     * Parse an octal string from a header buffer. This is used for the\n+     * file permission mode value.\n      *\n+     * @param header The header buffer from which to parse.\n      * @param offset The offset into the buffer from which to parse.\n      * @param length The number of header bytes to parse.\n-     * @param value Description of Parameter\n-     * @param buf Description of Parameter\n-     * @return The long value of the octal bytes.\n+     * @return The long value of the octal string.\n      */\n-    public static int getLongOctalBytes( final long value,\n-                                         final byte[] buf,\n-                                         final int offset,\n-                                         final int length )\n-    {\n-        byte[] temp = new byte[ length + 1 ];\n+    public static long parseOctal(byte[] header, int offset, int length) {\n+        long    result = 0;\n+        boolean stillPadding = true;\n+        int     end = offset + length;\n \n-        getOctalBytes( value, temp, 0, length + 1 );\n-        System.arraycopy( temp, 0, buf, offset, length );\n-\n-        return offset + length;\n-    }\n-\n-    /**\n-     * Determine the number of bytes in an entry name.\n-     *\n-     * @param offset The offset into the buffer from which to parse.\n-     * @param length The number of header bytes to parse.\n-     * @param name Description of Parameter\n-     * @param buffer Description of Parameter\n-     * @return The number of bytes in a header's entry name.\n-     */\n-    public static int getNameBytes( final StringBuffer name,\n-                                    final byte[] buffer,\n-                                    final int offset,\n-                                    final int length )\n-    {\n-        int i;\n-\n-        for( i = 0; i < length && i < name.length(); ++i )\n-        {\n-            buffer[ offset + i ] = (byte)name.charAt( i );\n-        }\n-\n-        for( ; i < length; ++i )\n-        {\n-            buffer[ offset + i ] = 0;\n-        }\n-\n-        return offset + length;\n-    }\n-\n-    /**\n-     * Parse an octal integer from a header buffer.\n-     *\n-     * @param offset The offset into the buffer from which to parse.\n-     * @param length The number of header bytes to parse.\n-     * @return The integer value of the octal bytes.\n-     */\n-    public static int getOctalBytes( final long value,\n-                                     final byte[] buffer,\n-                                     final int offset,\n-                                     final int length )\n-    {\n-        int idx = length - 1;\n-\n-        buffer[ offset + idx ] = 0;\n-        --idx;\n-        buffer[ offset + idx ] = (byte)' ';\n-        --idx;\n-\n-        if( value == 0 )\n-        {\n-            buffer[ offset + idx ] = (byte)'0';\n-            --idx;\n-        }\n-        else\n-        {\n-            long val = value;\n-            while( idx >= 0 && val > 0 )\n-            {\n-                buffer[ offset + idx ] = (byte)( (byte)'0' + (byte)( val & 7 ) );\n-                val = val >> 3;\n-                idx--;\n+        for (int i = offset; i < end; ++i) {\n+            if (header[i] == 0) {\n+                break;\n             }\n+\n+            if (header[i] == (byte) ' ' || header[i] == '0') {\n+                if (stillPadding) {\n+                    continue;\n+                }\n+\n+                if (header[i] == (byte) ' ') {\n+                    break;\n+                }\n+            }\n+\n+            stillPadding = false;\n+            // CheckStyle:MagicNumber OFF\n+            result = (result << 3) + (header[i] - '0');\n+            // CheckStyle:MagicNumber ON\n         }\n \n-        while( idx >= 0 )\n-        {\n-            buffer[ offset + idx ] = (byte)' ';\n-            idx--;\n-        }\n-\n-        return offset + length;\n-    }\n-\n-    /**\n-     * Compute the checksum of a tar entry header.\n-     *\n-     * @param buffer The tar entry's header buffer.\n-     * @return The computed checksum.\n-     */\n-    public static long computeCheckSum( final byte[] buffer )\n-    {\n-        long sum = 0;\n-\n-        for( int i = 0; i < buffer.length; ++i )\n-        {\n-            sum += 255 & buffer[ i ];\n-        }\n-\n-        return sum;\n+        return result;\n     }\n \n     /**\n@@ -166,67 +73,129 @@\n      * @param length The number of header bytes to parse.\n      * @return The header's entry name.\n      */\n-    public static StringBuffer parseName( final byte[] header,\n-                                          final int offset,\n-                                          final int length )\n-    {\n-        StringBuffer result = new StringBuffer( length );\n-        int end = offset + length;\n+    public static StringBuffer parseName(byte[] header, int offset, int length) {\n+        StringBuffer result = new StringBuffer(length);\n+        int          end = offset + length;\n \n-        for( int i = offset; i < end; ++i )\n-        {\n-            if( header[ i ] == 0 )\n-            {\n+        for (int i = offset; i < end; ++i) {\n+            if (header[i] == 0) {\n                 break;\n             }\n \n-            result.append( (char)header[ i ] );\n+            result.append((char) header[i]);\n         }\n \n         return result;\n     }\n \n     /**\n-     * Parse an octal string from a header buffer. This is used for the file\n-     * permission mode value.\n+     * Determine the number of bytes in an entry name.\n      *\n-     * @param header The header buffer from which to parse.\n+     * @param name The header name from which to parse.\n+     * @param buf The buffer from which to parse.\n      * @param offset The offset into the buffer from which to parse.\n      * @param length The number of header bytes to parse.\n-     * @return The long value of the octal string.\n+     * @return The number of bytes in a header's entry name.\n      */\n-    public static long parseOctal( final byte[] header,\n-                                   final int offset,\n-                                   final int length )\n-    {\n-        long result = 0;\n-        boolean stillPadding = true;\n-        int end = offset + length;\n+    public static int getNameBytes(StringBuffer name, byte[] buf, int offset, int length) {\n+        int i;\n \n-        for( int i = offset; i < end; ++i )\n-        {\n-            if( header[ i ] == 0 )\n-            {\n-                break;\n-            }\n-\n-            if( header[ i ] == (byte)' ' || header[ i ] == '0' )\n-            {\n-                if( stillPadding )\n-                {\n-                    continue;\n-                }\n-\n-                if( header[ i ] == (byte)' ' )\n-                {\n-                    break;\n-                }\n-            }\n-\n-            stillPadding = false;\n-            result = ( result << 3 ) + ( header[ i ] - '0' );\n+        for (i = 0; i < length && i < name.length(); ++i) {\n+            buf[offset + i] = (byte) name.charAt(i);\n         }\n \n-        return result;\n+        for (; i < length; ++i) {\n+            buf[offset + i] = 0;\n+        }\n+\n+        return offset + length;\n+    }\n+\n+    /**\n+     * Parse an octal integer from a header buffer.\n+     *\n+     * @param value The header value\n+     * @param buf The buffer from which to parse.\n+     * @param offset The offset into the buffer from which to parse.\n+     * @param length The number of header bytes to parse.\n+     * @return The integer value of the octal bytes.\n+     */\n+    public static int getOctalBytes(long value, byte[] buf, int offset, int length) {\n+        int    idx = length - 1;\n+\n+        buf[offset + idx] = 0;\n+        --idx;\n+        buf[offset + idx] = (byte) ' ';\n+        --idx;\n+\n+        if (value == 0) {\n+            buf[offset + idx] = (byte) '0';\n+            --idx;\n+        } else {\n+            for (long val = value; idx >= 0 && val > 0; --idx) {\n+                // CheckStyle:MagicNumber OFF\n+                buf[offset + idx] = (byte) ((byte) '0' + (byte) (val & 7));\n+                val = val >> 3;\n+                // CheckStyle:MagicNumber ON\n+            }\n+        }\n+\n+        for (; idx >= 0; --idx) {\n+            buf[offset + idx] = (byte) ' ';\n+        }\n+\n+        return offset + length;\n+    }\n+\n+    /**\n+     * Parse an octal long integer from a header buffer.\n+     *\n+     * @param value The header value\n+     * @param buf The buffer from which to parse.\n+     * @param offset The offset into the buffer from which to parse.\n+     * @param length The number of header bytes to parse.\n+     * @return The long value of the octal bytes.\n+     */\n+    public static int getLongOctalBytes(long value, byte[] buf, int offset, int length) {\n+        byte[] temp = new byte[length + 1];\n+\n+        getOctalBytes(value, temp, 0, length + 1);\n+        System.arraycopy(temp, 0, buf, offset, length);\n+\n+        return offset + length;\n+    }\n+\n+    /**\n+     * Parse the checksum octal integer from a header buffer.\n+     *\n+     * @param value The header value\n+     * @param buf The buffer from which to parse.\n+     * @param offset The offset into the buffer from which to parse.\n+     * @param length The number of header bytes to parse.\n+     * @return The integer value of the entry's checksum.\n+     */\n+    public static int getCheckSumOctalBytes(long value, byte[] buf, int offset, int length) {\n+        getOctalBytes(value, buf, offset, length);\n+\n+        buf[offset + length - 1] = (byte) ' ';\n+        buf[offset + length - 2] = 0;\n+\n+        return offset + length;\n+    }\n+\n+    /**\n+     * Compute the checksum of a tar entry header.\n+     *\n+     * @param buf The tar entry's header buffer.\n+     * @return The computed checksum.\n+     */\n+    public static long computeCheckSum(byte[] buf) {\n+        long sum = 0;\n+\n+        for (int i = 0; i < buf.length; ++i) {\n+            sum += BYTE_MASK & buf[i];\n+        }\n+\n+        return sum;\n     }\n }\n\n"
    },
    "Gson-15": {
        "Buggy Function": "  public JsonWriter value(double value) throws IOException {\n    writeDeferredName();\n    if (Double.isNaN(value) || Double.isInfinite(value)) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    beforeValue();\n    out.append(Double.toString(value));\n    return this;\n  }",
        "Inducing Changes": "Add Whole Class File of buggy method"
    },
    "JacksonCore-14": {
        "Buggy Function": "protected final void _verifyRelease(byte[] toRelease, byte[] src) {\n    if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n}\n\nprotected final void _verifyRelease(char[] toRelease, char[] src) {\n    if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n}\n\nprivate IllegalArgumentException wrongBuf() { return new IllegalArgumentException(\"Trying to release buffer not owned by the context\"); }\n",
        "Inducing Changes": "diff --git a/src/main/java/com/fasterxml/jackson/core/io/IOContext.java b/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\nindex 49496c3..7ce6f2f 100644\n--- a/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\n@@ -227,6 +227,7 @@\n \n     public void releaseConcatBuffer(char[] buf) {\n         if (buf != null) {\n+            // 14-Jan-2014, tatu: Let's actually allow upgrade of the original buffer.\n             _verifyRelease(buf, _concatCBuffer);\n             _concatCBuffer = null;\n             _bufferRecycler.releaseCharBuffer(BufferRecycler.CHAR_CONCAT_BUFFER, buf);\n@@ -235,6 +236,7 @@\n \n     public void releaseNameCopyBuffer(char[] buf) {\n         if (buf != null) {\n+            // 14-Jan-2014, tatu: Let's actually allow upgrade of the original buffer.\n             _verifyRelease(buf, _nameCopyBuffer);\n             _nameCopyBuffer = null;\n             _bufferRecycler.releaseCharBuffer(BufferRecycler.CHAR_NAME_COPY_BUFFER, buf);\n@@ -248,14 +250,16 @@\n      */\n \n     protected void _verifyAlloc(Object buffer) {\n-        if (buffer != null) {\n-            throw new IllegalStateException(\"Trying to call same allocXxx() method second time\");\n-        }\n+        if (buffer != null) { throw new IllegalStateException(\"Trying to call same allocXxx() method second time\"); }\n     }\n \n-    protected void _verifyRelease(Object toRelease, Object src) {\n-        if (toRelease != src) {\n-            throw new IllegalArgumentException(\"Trying to release buffer not owned by the context\");\n-        }\n+    protected void _verifyRelease(byte[] toRelease, byte[] src) {\n+        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n     }\n+\n+    protected void _verifyRelease(char[] toRelease, char[] src) {\n+        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n+    }\n+\n+    private IllegalArgumentException wrongBuf() { return new IllegalArgumentException(\"Trying to release buffer not owned by the context\"); }\n }\n\n"
    },
    "JacksonCore-4": {
        "Buggy Function": "    public char[] expandCurrentSegment()\n    {\n        final char[] curr = _currentSegment;\n        // Let's grow by 50% by default\n        final int len = curr.length;\n        // but above intended maximum, slow to increase by 25%\n        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n        return (_currentSegment = Arrays.copyOf(curr, newLen));\n    }",
        "Inducing Changes": "Add Whole Class File of buggy method"
    },
    "JacksonCore-5": {
        "Buggy Function": "    private final static int _parseIndex(String str) {\n        final int len = str.length();\n        // [Issue#133]: beware of super long indexes; assume we never\n        // have arrays over 2 billion entries so ints are fine.\n        if (len == 0 || len > 10) {\n            return -1;\n        }\n        for (int i = 0; i < len; ++i) {\n            char c = str.charAt(i++);\n            if (c > '9' || c < '0') {\n                return -1;\n            }\n        }\n        if (len == 10) {\n            long l = NumberInput.parseLong(str);\n            if (l > Integer.MAX_VALUE) {\n                return -1;\n            }\n        }\n        return NumberInput.parseInt(str);\n    }",
        "Inducing Changes": "Add Whole Class File of buggy method"
    },
    "JacksonCore-6": {
        "Buggy Function": "    private final static int _parseIndex(String str) {\n        final int len = str.length();\n        // [core#133]: beware of super long indexes; assume we never\n        // have arrays over 2 billion entries so ints are fine.\n        if (len == 0 || len > 10) {\n            return -1;\n        }\n        // [core#176]: no leading zeroes allowed\n        for (int i = 0; i < len; ++i) {\n            char c = str.charAt(i);\n            if (c > '9' || c < '0') {\n                return -1;\n            }\n        }\n        if (len == 10) {\n            long l = NumberInput.parseLong(str);\n            if (l > Integer.MAX_VALUE) {\n                return -1;\n            }\n        }\n        return NumberInput.parseInt(str);\n    }",
        "Inducing Changes": "Add Whole Class File of buggy method"
    },
    "JacksonCore-8": {
        "Buggy Function": "    public char[] getTextBuffer()\n    {\n        // Are we just using shared input buffer?\n        if (_inputStart >= 0) return _inputBuffer;\n        if (_resultArray != null)  return _resultArray;\n        if (_resultString != null) {\n            return (_resultArray = _resultString.toCharArray());\n        }\n        // Nope; but does it fit in just one segment?\n        if (!_hasSegments)  return _currentSegment;\n        // Nope, need to have/create a non-segmented array and return it\n        return contentsAsArray();\n    }",
        "Inducing Changes": "Add Whole Class File of buggy method"
    },
    "Jsoup-27": {
        "Buggy Function": "    static String getCharsetFromContentType(String contentType) {\n        if (contentType == null) return null;\n        Matcher m = charsetPattern.matcher(contentType);\n        if (m.find()) {\n            String charset = m.group(1).trim();\n            charset = charset.toUpperCase(Locale.ENGLISH);\n            return charset;\n        }\n        return null;\n    }",
        "Inducing Changes": "diff --git a/src/main/java/org/jsoup/DataUtil.java b/src/main/java/org/jsoup/DataUtil.java\nindex 906b75a..d8ee2ef 100644\n--- a/src/main/java/org/jsoup/DataUtil.java\n+++ b/src/main/java/org/jsoup/DataUtil.java\n@@ -1,16 +1,25 @@\n package org.jsoup;\n \n import org.apache.commons.lang.Validate;\n+import org.jsoup.nodes.Document;\n+import org.jsoup.nodes.Element;\n \n import java.io.*;\n import java.net.URL;\n import java.net.HttpURLConnection;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n \n /**\n  * Internal static utilities for handling data.\n  *\n  */\n class DataUtil {\n+    private static final Pattern charsetPattern \u003d Pattern.compile(\"(?i)\\\\bcharset\u003d([^\\\\s;]*)\");\n+    private static final String defaultCharset \u003d \"UTF-8\"; // used if not found in header or http-equiv\n+    private static final int bufferSize \u003d 0x20000; // ~130K.\n     \n     /**\n      * Loads a file to a String.\n@@ -53,27 +62,57 @@\n                     contentType, url.toString()));\n         \n         InputStream inStream \u003d new BufferedInputStream(conn.getInputStream());\n-        String charSet \u003d \"UTF-8\"; // todo[must]: get from content-encoding, or http-equiv (two-pass?)\n+        String charSet \u003d getCharsetFromContentType(contentType); // may be null, readInputStream deals with it\n \n         String data \u003d readInputStream(inStream, charSet);\n         inStream.close();\n         return data;\n     }\n \n+    // reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n+    // switching the chartset midstream when a meta http-equiv tag defines the charset.\n     private static String readInputStream(InputStream inStream, String charsetName) throws IOException {\n-        char[] buffer \u003d new char[0x20000]; // ~ 130K\n-        StringBuilder data \u003d new StringBuilder(0x20000);\n-        Reader inReader \u003d new InputStreamReader(inStream, charsetName);\n+        byte[] buffer \u003d new byte[bufferSize];\n+        ByteArrayOutputStream outStream \u003d new ByteArrayOutputStream(bufferSize);\n         int read;\n-        do {\n-            read \u003d inReader.read(buffer, 0, buffer.length);\n-            if (read \u003e 0) {\n-                data.append(buffer, 0, read);\n+        while(true) {\n+            read  \u003d inStream.read(buffer);\n+            if (read \u003d\u003d -1) break;\n+            outStream.write(buffer, 0, read);\n+        }\n+        ByteBuffer byteData \u003d ByteBuffer.wrap(outStream.toByteArray());\n+        \n+        String docData;\n+        if (charsetName \u003d\u003d null) { // determine from http-equiv. safe parse as UTF-8\n+            docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n+            Document doc \u003d Jsoup.parse(docData);\n+            Element httpEquiv \u003d doc.select(\"meta[http-equiv]\").first();\n+            if (httpEquiv !\u003d null) { // if not found, will keep utf-8 as best attempt\n+                String foundCharset \u003d getCharsetFromContentType(httpEquiv.attr(\"content\"));\n+                if (foundCharset !\u003d null \u0026\u0026 !foundCharset.equals(defaultCharset)) { // need to re-decode\n+                    byteData.rewind();\n+                    docData \u003d Charset.forName(foundCharset).decode(byteData).toString();\n+                }\n             }\n-\n-        } while (read \u003e\u003d 0);\n-\n-        return data.toString();\n+        } else { // specified by content type header (or by user on file load)\n+            docData \u003d Charset.forName(charsetName).decode(byteData).toString();\n+        }\n+        return docData;\n+    }\n+    \n+    /**\n+     * Parse out a charset from a content type header.\n+     * @param contentType e.g. \"text/html; charset\u003dEUC-JP\"\n+     * @return \"EUC-JP\", or null if not found. Charset is trimmed and uppercased.\n+     */\n+    static String getCharsetFromContentType(String contentType) {\n+        if (contentType \u003d\u003d null) return null;\n+        \n+        Matcher m \u003d charsetPattern.matcher(contentType);\n+        if (m.find()) {\n+            return m.group(1).trim().toUpperCase();\n+        }\n+        return null;\n     }\n     \n     \n"
    },
    "Jsoup-4": {
        "Buggy Function": "static String unescape(String string) {\n    if (!string.contains(\"&\"))\n        return string;\n\n    Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\n    StringBuffer accum = new StringBuffer(string.length()); // pity matcher can't use stringbuilder, avoid syncs\n\n    while (m.find()) {\n        int charval = -1;\n        String num = m.group(3);\n        if (num != null) {\n            try {\n                int base = m.group(2) != null ? 16 : 10; // 2 is hex indicator\n                charval = Integer.valueOf(num, base);\n            } catch (NumberFormatException e) {\n            } // skip\n        } else {\n            String name = m.group(1).toLowerCase();\n            if (full.containsKey(name))\n                charval = full.get(name);\n        }\n\n        if (charval != -1 || charval > 0xFFFF) { // out of range\n            String c = Character.toString((char) charval);\n            m.appendReplacement(accum, c);\n        } else {\n            m.appendReplacement(accum, m.group(0)); // replace with original string\n        }\n    }\n    m.appendTail(accum);\n    return accum.toString();\n}\nstatic {\n    base = new HashMap<String, Character>(baseArray.length);\n    full = new HashMap<String, Character>(fullArray.length);\n    baseByVal = new HashMap<Character, String>(baseArray.length);\n    fullByVal = new HashMap<Character, String>(fullArray.length);\n\n    for (Object[] entity : baseArray) {\n        Character c = Character.valueOf((char) ((Integer) entity[1]).intValue());\n        base.put((String) entity[0], c);\n        baseByVal.put(c, ((String) entity[0]).toLowerCase());\n    }\n    for (Object[] entity : fullArray) {\n        Character c = Character.valueOf((char) ((Integer) entity[1]).intValue());\n        full.put((String) entity[0], c);\n        fullByVal.put(c, ((String) entity[0]).toLowerCase());\n    }\n}",
        "Inducing Changes": "--- a/src/main/java/org/jsoup/Entities.java\n+++ b/src/main/java/org/jsoup/nodes/Entities.java\n@@ -1,4 +1,6 @@-package org.jsoup;\n+package org.jsoup.nodes;\n+\n+import org.jsoup.parser.TokenQueue;\n \n import java.util.HashMap;\n import java.util.Map;\n@@ -13,31 +15,88 @@  * Draft implementation. Do not consume.\n  */\n class Entities {\n-    static final Map<String, Integer> base;\n-    static final Map<String, Integer> full;\n-    static final Map<Integer, String> fullByVal;\n+    public enum EscapeMode {\n+        base, extended\n+    }\n \n-    static String escape(String string, Charset charset) {\n-        // todo: this needs option to: use base names only (with numerical as fallback)\n-        StringBuilder accum = new StringBuilder((int) (string.length() * 1.5));\n-        CharsetEncoder encoder = charset.newEncoder();\n+    private static final Map<String, Character> base;\n+    private static final Map<String, Character> full;\n+    private static final Map<Character, String> baseByVal;\n+    private static final Map<Character, String> fullByVal;\n+\n+    static String escape(String string, CharsetEncoder encoder, EscapeMode escapeMode) {\n+        StringBuilder accum = new StringBuilder(string.length() * 2);\n+        Map<Character, String> map = escapeMode == EscapeMode.extended ? fullByVal : baseByVal;\n \n         for (int pos = 0; pos < string.length(); pos++) {\n             Character c = string.charAt(pos);\n-            if (fullByVal.containsKey((int) c))\n-                accum.append(\"&\").append(fullByVal.get((int) c)).append(\";\");\n+            if (map.containsKey(c))\n+                accum.append(\"&\").append(map.get(c)).append(\";\");\n             else if (encoder.canEncode(c))\n                 accum.append(c);\n             else\n-                accum.append(\"&#\").append((int)c).append(\";\");\n+                accum.append(\"&#\").append((int) c).append(\";\");\n         }\n \n         return accum.toString();\n     }\n \n-    // base entities can be unescaped without trailing ;\n+    static String unescape(String string) {\n+        if (!string.contains(\"&\"))\n+            return string;\n+\n+        StringBuilder accum = new StringBuilder(string.length());\n+        TokenQueue cq = new TokenQueue(string);\n+\n+        // formats dealt with: [&amp] (no semi), [&amp;], [&#123;] (int), &#\n+        while (!cq.isEmpty()) {\n+            accum.append(cq.consumeTo(\"&\"));\n+            if (!cq.matches(\"&\")) { // ran to end\n+                accum.append(cq.remainder());\n+                break;\n+            }\n+            cq.advance(); // past &\n+            String val;\n+            int charval = -1;\n+\n+            boolean isNum = false;\n+            if (cq.matches(\"#\")) {\n+                isNum = true;\n+                cq.consume();\n+            }\n+            val = cq.consumeWord(); // and num!\n+            if (val.length() == 0) {\n+                accum.append(\"&\");\n+                continue;\n+            }\n+            if (cq.matches(\";\"))\n+                cq.advance();\n+\n+            if (isNum) {\n+                try {\n+                    if (val.charAt(0) == 'x' || val.charAt(0) == 'X')\n+                        charval = Integer.valueOf(val.substring(1), 16);\n+                    else\n+                        charval = Integer.valueOf(val, 10);\n+                } catch (NumberFormatException e) {\n+                    // skip\n+                }\n+            } else {\n+                if (full.containsKey(val.toLowerCase()))\n+                    charval = full.get(val.toLowerCase());\n+            }\n+            if (charval == -1 || charval > 0xFFFF) // out of range\n+                accum.append(\"&\").append(val).append(\";\");\n+            else\n+                accum.append((char) charval);\n+        }\n+\n+        return accum.toString();\n+    }\n+\n+    // most common, base entities can be unescaped without trailing ;\n     // e.g. &amp\n-    static final Object[][] baseArray = {\n+    private static final Object[][] baseArray = {\n             {\"AElig\", 0x000C6},\n             {\"AMP\", 0x00026},\n             {\"Aacute\", 0x000C1},\n@@ -146,7 +205,9 @@             {\"yuml\", 0x000FF}\n     };\n \n-    static final Object[][] fullArray = {\n+    // in most situations, will be better to use UTF8 and use the character directly, or use the numerical escape.\n+    // are people really likely to remember \"&CounterClockwiseContourIntegral;\"? good grief.\n+    private static final Object[][] fullArray = {\n             {\"AElig\", 0x000C6},\n             {\"AMP\", 0x00026},\n             {\"Aacute\", 0x000C1},\n@@ -2182,14 +2243,20 @@     };\n \n     static {\n-        base = new HashMap<String, Integer>(baseArray.length);\n-        full = new HashMap<String, Integer>(fullArray.length);\n-        fullByVal = new HashMap<Integer, String>(fullArray.length);\n+        base = new HashMap<String, Character>(baseArray.length);\n+        full = new HashMap<String, Character>(fullArray.length);\n+        baseByVal = new HashMap<Character, String>(baseArray.length);\n+        fullByVal = new HashMap<Character, String>(fullArray.length);\n \n-        for (Object[] entity : baseArray) base.put(((String) entity[0]).toLowerCase(), (Integer) entity[1]);\n+        for (Object[] entity : baseArray) {\n+            Character c = Character.valueOf((char) ((Integer) entity[1]).intValue());\n+            base.put((String) entity[0], c);\n+            baseByVal.put(c, ((String) entity[0]).toLowerCase());\n+        }\n         for (Object[] entity : fullArray) {\n-            full.put(((String) entity[0]).toLowerCase(), (Integer) entity[1]);\n-            fullByVal.put((Integer) entity[1], ((String) entity[0]));\n+            Character c = Character.valueOf((char) ((Integer) entity[1]).intValue());\n+            full.put((String) entity[0], c);\n+            fullByVal.put(c, ((String) entity[0]).toLowerCase());\n         }\n     }"
    },
    "Jsoup-85": {
        "Buggy Function": "    public Attribute(String key, String val, Attributes parent) {\n        Validate.notNull(key);\n        this.key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        this.val = val;\n        this.parent = parent;\n    }",
        "Inducing Changes": "Add Whole Class File of buggy method"
    },
    "Jsoup-9": {
        "Buggy Function": "static String unescape(String string) {\n    if (!string.contains(\"&\"))\n        return string;\n\n    Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\n    StringBuffer accum = new StringBuffer(string.length()); // pity matcher can't use stringbuilder, avoid syncs\n    // todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required\n\n    while (m.find()) {\n        int charval = -1;\n        String num = m.group(3);\n        if (num != null) {\n            try {\n                int base = m.group(2) != null ? 16 : 10; // 2 is hex indicator\n                charval = Integer.valueOf(num, base);\n            } catch (NumberFormatException e) {\n            } // skip\n        } else {\n            String name = m.group(1);\n            if (full.containsKey(name))\n                charval = full.get(name);\n        }\n\n        if (charval != -1 || charval > 0xFFFF) { // out of range\n            String c = Character.toString((char) charval);\n            m.appendReplacement(accum, Matcher.quoteReplacement(c));\n        } else {\n            m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); // replace with original string\n        }\n    }\n    m.appendTail(accum);\n    return accum.toString();\n}",
        "Inducing Changes": "diff --git a/src/main/java/org/jsoup/nodes/Entities.java b/src/main/java/org/jsoup/nodes/Entities.java\nnew file mode 100644\nindex 0000000..37266af\n--- a/src/main/java/org/jsoup/nodes/Entities.java\n+++ b/src/main/java/org/jsoup/nodes/Entities.java\n@@ -43,0 +43,95 @@\n+    static String unescape(String string) {\n+        if (!string.contains(\"&\"))\n+            return string;\n+\n+        StringBuilder accum = new StringBuilder(string.length());\n+        TokenQueue cq = new TokenQueue(string);\n+\n+        // formats dealt with: [&amp] (no semi), [&amp;], [&#123;] (int), &#\n+        while (!cq.isEmpty()) {\n+            accum.append(cq.consumeTo(\"&\"));\n+            if (!cq.matches(\"&\")) { // ran to end\n+                accum.append(cq.remainder());\n+                break;\n+            }\n+            cq.advance(); // past &\n+            String val;\n+            int charval = -1;\n+\n+            boolean isNum = false;\n+            if (cq.matches(\"#\")) {\n+                isNum = true;\n+                cq.consume();\n+            }\n+            val = cq.consumeWord(); // and num!\n+            if (val.length() == 0) {\n+                accum.append(\"&\");\n+                continue;\n+            }\n+            if (cq.matches(\";\"))\n+                cq.advance();\n+\n+            if (isNum) {\n+                try {\n+                    if (val.charAt(0) == 'x' || val.charAt(0) == 'X')\n+                        charval = Integer.valueOf(val.substring(1), 16);\n+                    else\n+                        charval = Integer.valueOf(val, 10);\n+                } catch (NumberFormatException e) {\n+                    // skip\n+                }\n+            } else {\n+                if (full.containsKey(val.toLowerCase()))\n+                    charval = full.get(val.toLowerCase());\n+            }\n+            if (charval == -1 || charval > 0xFFFF) // out of range\n+                accum.append(\"&\").append(val).append(\";\");\n+            else\n+                accum.append((char) charval);\n+        }\n+\n+        return accum.toString();\n+    }"
    },
    "Lang-14": {
        "Buggy Function": "    public static boolean equals(CharSequence cs1, CharSequence cs2) {\n        if (cs1 == cs2) {\n            return true;\n        }\n        if (cs1 == null || cs2 == null) {\n            return false;\n        }\n            return cs1.equals(cs2);\n    }",
        "Inducing Changes": "diff --git a/src/main/java/org/apache/commons/lang3/StringUtils.java b/src/main/java/org/apache/commons/lang3/StringUtils.java\nindex c68c3a4..595f4bf 100644\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n@@ -173,7 +173,7 @@\n     // Empty checks\n     //-----------------------------------------------------------------------\n     /**\n-     * <p>Checks if a String is empty (\"\") or null.</p>\n+     * <p>Checks if a CharSequence is empty (\"\") or null.</p>\n      *\n      * <pre>\n      * StringUtils.isEmpty(null)      = true\n@@ -184,18 +184,18 @@\n      * </pre>\n      *\n      * <p>NOTE: This method changed in Lang version 2.0.\n-     * It no longer trims the String.\n+     * It no longer trims the CharSequence.\n      * That functionality is available in isBlank().</p>\n      *\n-     * @param str  the String to check, may be null\n-     * @return <code>true</code> if the String is empty or null\n+     * @param cs  the CharSequence to check, may be null\n+     * @return <code>true</code> if the CharSequence is empty or null\n      */\n-    public static boolean isEmpty(CharSequence str) {\n-        return str == null || str.length() == 0;\n+    public static boolean isEmpty(CharSequence cs) {\n+        return cs == null || cs.length() == 0;\n     }\n \n     /**\n-     * <p>Checks if a String is not empty (\"\") and not null.</p>\n+     * <p>Checks if a CharSequence is not empty (\"\") and not null.</p>\n      *\n      * <pre>\n      * StringUtils.isNotEmpty(null)      = false\n@@ -205,15 +205,15 @@\n      * StringUtils.isNotEmpty(\"  bob  \") = true\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n-     * @return <code>true</code> if the String is not empty and not null\n+     * @param cs  the CharSequence to check, may be null\n+     * @return <code>true</code> if the CharSequence is not empty and not null\n      */\n-    public static boolean isNotEmpty(CharSequence str) {\n-        return !StringUtils.isEmpty(str);\n+    public static boolean isNotEmpty(CharSequence cs) {\n+        return !StringUtils.isEmpty(cs);\n     }\n \n     /**\n-     * <p>Checks if a String is whitespace, empty (\"\") or null.</p>\n+     * <p>Checks if a CharSequence is whitespace, empty (\"\") or null.</p>\n      *\n      * <pre>\n      * StringUtils.isBlank(null)      = true\n@@ -223,17 +223,17 @@\n      * StringUtils.isBlank(\"  bob  \") = false\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n-     * @return <code>true</code> if the String is null, empty or whitespace\n+     * @param cs  the CharSequence to check, may be null\n+     * @return <code>true</code> if the CharSequence is null, empty or whitespace\n      * @since 2.0\n      */\n-    public static boolean isBlank(CharSequence str) {\n+    public static boolean isBlank(CharSequence cs) {\n         int strLen;\n-        if (str == null || (strLen = str.length()) == 0) {\n+        if (cs == null || (strLen = cs.length()) == 0) {\n             return true;\n         }\n         for (int i = 0; i < strLen; i++) {\n-            if ((Character.isWhitespace(str.charAt(i)) == false)) {\n+            if ((Character.isWhitespace(cs.charAt(i)) == false)) {\n                 return false;\n             }\n         }\n@@ -241,7 +241,7 @@\n     }\n \n     /**\n-     * <p>Checks if a String is not empty (\"\"), not null and not whitespace only.</p>\n+     * <p>Checks if a CharSequence is not empty (\"\"), not null and not whitespace only.</p>\n      *\n      * <pre>\n      * StringUtils.isNotBlank(null)      = false\n@@ -251,13 +251,13 @@\n      * StringUtils.isNotBlank(\"  bob  \") = true\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n-     * @return <code>true</code> if the String is\n+     * @param cs  the CharSequence to check, may be null\n+     * @return <code>true</code> if the CharSequence is\n      *  not empty and not null and not whitespace\n      * @since 2.0\n      */\n-    public static boolean isNotBlank(CharSequence str) {\n-        return !StringUtils.isBlank(str);\n+    public static boolean isNotBlank(CharSequence cs) {\n+        return !StringUtils.isBlank(cs);\n     }\n \n     // Trim\n@@ -677,7 +677,7 @@\n     // Equals\n     //-----------------------------------------------------------------------\n     /**\n-     * <p>Compares two Strings, returning <code>true</code> if they are equal.</p>\n+     * <p>Compares two CharSequences, returning <code>true</code> if they are equal.</p>\n      *\n      * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n      * references are considered to be equal. The comparison is case sensitive.</p>\n@@ -691,13 +691,13 @@\n      * </pre>\n      *\n      * @see java.lang.String#equals(Object)\n-     * @param str1  the first String, may be null\n-     * @param str2  the second String, may be null\n-     * @return <code>true</code> if the Strings are equal, case sensitive, or\n+     * @param cs1  the first CharSequence, may be null\n+     * @param cs2  the second CharSequence, may be null\n+     * @return <code>true</code> if the CharSequences are equal, case sensitive, or\n      *  both <code>null</code>\n      */\n-    public static boolean equals(String str1, String str2) {\n-        return str1 == null ? str2 == null : str1.equals(str2);\n+    public static boolean equals(CharSequence cs1, CharSequence cs2) {\n+        return cs1 == null ? cs2 == null : cs1.equals(cs2);\n     }\n \n     /**\n@@ -1347,7 +1347,7 @@\n     // IndexOfAny chars\n     //-----------------------------------------------------------------------\n     /**\n-     * <p>Search a String to find the first index of any\n+     * <p>Search a CharSequence to find the first index of any\n      * character in the given set of characters.</p>\n      *\n      * <p>A <code>null</code> String will return <code>-1</code>.\n@@ -1363,17 +1363,17 @@\n      * StringUtils.indexOfAny(\"aba\", ['z'])           = -1\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param cs  the CharSequence to check, may be null\n      * @param searchChars  the chars to search for, may be null\n      * @return the index of any of the chars, -1 if no match or null input\n      * @since 2.0\n      */\n-    public static int indexOfAny(String str, char[] searchChars) {\n-        if (isEmpty(str) || ArrayUtils.isEmpty(searchChars)) {\n+    public static int indexOfAny(CharSequence cs, char[] searchChars) {\n+        if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n             return -1;\n         }\n-        for (int i = 0; i < str.length(); i++) {\n-            char ch = str.charAt(i);\n+        for (int i = 0; i < cs.length(); i++) {\n+            char ch = cs.charAt(i);\n             for (int j = 0; j < searchChars.length; j++) {\n                 if (searchChars[j] == ch) {\n                     return i;\n@@ -1384,7 +1384,7 @@\n     }\n \n     /**\n-     * <p>Search a String to find the first index of any\n+     * <p>Search a CharSequence to find the first index of any\n      * character in the given set of characters.</p>\n      *\n      * <p>A <code>null</code> String will return <code>-1</code>.\n@@ -1400,25 +1400,25 @@\n      * StringUtils.indexOfAny(\"aba\",\"z\")          = -1\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param cs  the CharSequence to check, may be null\n      * @param searchChars  the chars to search for, may be null\n      * @return the index of any of the chars, -1 if no match or null input\n      * @since 2.0\n      */\n-    public static int indexOfAny(String str, String searchChars) {\n-        if (isEmpty(str) || isEmpty(searchChars)) {\n+    public static int indexOfAny(CharSequence cs, String searchChars) {\n+        if (isEmpty(cs) || isEmpty(searchChars)) {\n             return -1;\n         }\n-        return indexOfAny(str, searchChars.toCharArray());\n+        return indexOfAny(cs, searchChars.toCharArray());\n     }\n \n     // ContainsAny\n     //-----------------------------------------------------------------------\n     /**\n-     * <p>Checks if the String contains any character in the given\n+     * <p>Checks if the CharSequence contains any character in the given\n      * set of characters.</p>\n      *\n-     * <p>A <code>null</code> String will return <code>false</code>.\n+     * <p>A <code>null</code> CharSequence will return <code>false</code>.\n      * A <code>null</code> or zero length search array will return <code>false</code>.</p>\n      *\n      * <pre>\n@@ -1431,18 +1431,18 @@\n      * StringUtils.containsAny(\"aba\", ['z'])           = false\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param cs  the CharSequence to check, may be null\n      * @param searchChars  the chars to search for, may be null\n      * @return the <code>true</code> if any of the chars are found,\n      * <code>false</code> if no match or null input\n      * @since 2.4\n      */\n-    public static boolean containsAny(String str, char[] searchChars) {\n-        if (str == null || str.length() == 0 || searchChars == null || searchChars.length == 0) {\n+    public static boolean containsAny(CharSequence cs, char[] searchChars) {\n+        if (cs == null || cs.length() == 0 || searchChars == null || searchChars.length == 0) {\n             return false;\n         }\n-        for (int i = 0; i < str.length(); i++) {\n-            char ch = str.charAt(i);\n+        for (int i = 0; i < cs.length(); i++) {\n+            char ch = cs.charAt(i);\n             for (int j = 0; j < searchChars.length; j++) {\n                 if (searchChars[j] == ch) {\n                     return true;\n@@ -1454,11 +1454,11 @@\n \n     /**\n      * <p>\n-     * Checks if the String contains any character in the given set of characters.\n+     * Checks if the CharSequence contains any character in the given set of characters.\n      * </p>\n      * \n      * <p>\n-     * A <code>null</code> String will return <code>false</code>. A <code>null</code> search string will return\n+     * A <code>null</code> CharSequence will return <code>false</code>. A <code>null</code> search CharSequence will return\n      * <code>false</code>.\n      * </p>\n      * \n@@ -1472,27 +1472,27 @@\n      * StringUtils.containsAny(\"aba\",\"z\")          = false\n      * </pre>\n      * \n-     * @param str\n-     *            the String to check, may be null\n+     * @param cs\n+     *            the CharSequence to check, may be null\n      * @param searchChars\n      *            the chars to search for, may be null\n      * @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input\n      * @since 2.4\n      */\n-    public static boolean containsAny(String str, String searchChars) {\n+    public static boolean containsAny(CharSequence cs, String searchChars) {\n         if (searchChars == null) {\n             return false;\n         }\n-        return containsAny(str, searchChars.toCharArray());\n+        return containsAny(cs, searchChars.toCharArray());\n     }\n \n     // IndexOfAnyBut chars\n     //-----------------------------------------------------------------------\n     /**\n-     * <p>Search a String to find the first index of any\n+     * <p>Searches a CharSequence to find the first index of any\n      * character not in the given set of characters.</p>\n      *\n-     * <p>A <code>null</code> String will return <code>-1</code>.\n+     * <p>A <code>null</code> CharSequence will return <code>-1</code>.\n      * A <code>null</code> or zero length search array will return <code>-1</code>.</p>\n      *\n      * <pre>\n@@ -1505,17 +1505,17 @@\n      * StringUtils.indexOfAnyBut(\"aba\", 'ab')       = -1\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param cs  the CharSequence to check, may be null\n      * @param searchChars  the chars to search for, may be null\n      * @return the index of any of the chars, -1 if no match or null input\n      * @since 2.0\n      */\n-    public static int indexOfAnyBut(String str, char[] searchChars) {\n-        if (isEmpty(str) || ArrayUtils.isEmpty(searchChars)) {\n+    public static int indexOfAnyBut(CharSequence cs, char[] searchChars) {\n+        if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n             return -1;\n         }\n-        outer : for (int i = 0; i < str.length(); i++) {\n-            char ch = str.charAt(i);\n+        outer : for (int i = 0; i < cs.length(); i++) {\n+            char ch = cs.charAt(i);\n             for (int j = 0; j < searchChars.length; j++) {\n                 if (searchChars[j] == ch) {\n                     continue outer;\n@@ -1563,11 +1563,11 @@\n     // ContainsOnly\n     //-----------------------------------------------------------------------\n     /**\n-     * <p>Checks if the String contains only certain characters.</p>\n+     * <p>Checks if the CharSequence contains only certain characters.</p>\n      *\n-     * <p>A <code>null</code> String will return <code>false</code>.\n+     * <p>A <code>null</code> CharSequence will return <code>false</code>.\n      * A <code>null</code> valid character array will return <code>false</code>.\n-     * An empty String (\"\") always returns <code>true</code>.</p>\n+     * An empty CharSequence (length()=0) always returns <code>true</code>.</p>\n      *\n      * <pre>\n      * StringUtils.containsOnly(null, *)       = false\n@@ -1579,30 +1579,30 @@\n      * StringUtils.containsOnly(\"abz\", 'abc')  = false\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param cs  the String to check, may be null\n      * @param valid  an array of valid chars, may be null\n      * @return true if it only contains valid chars and is non-null\n      */\n-    public static boolean containsOnly(String str, char[] valid) {\n+    public static boolean containsOnly(CharSequence cs, char[] valid) {\n         // All these pre-checks are to maintain API with an older version\n-        if ((valid == null) || (str == null)) {\n+        if (valid == null || cs == null) {\n             return false;\n         }\n-        if (str.length() == 0) {\n+        if (cs.length() == 0) {\n             return true;\n         }\n         if (valid.length == 0) {\n             return false;\n         }\n-        return indexOfAnyBut(str, valid) == -1;\n+        return indexOfAnyBut(cs, valid) == -1;\n     }\n \n     /**\n-     * <p>Checks if the String contains only certain characters.</p>\n+     * <p>Checks if the CharSequence contains only certain characters.</p>\n      *\n-     * <p>A <code>null</code> String will return <code>false</code>.\n+     * <p>A <code>null</code> CharSequence will return <code>false</code>.\n      * A <code>null</code> valid character String will return <code>false</code>.\n-     * An empty String (\"\") always returns <code>true</code>.</p>\n+     * An empty String (length()=0) always returns <code>true</code>.</p>\n      *\n      * <pre>\n      * StringUtils.containsOnly(null, *)       = false\n@@ -1614,26 +1614,26 @@\n      * StringUtils.containsOnly(\"abz\", \"abc\")  = false\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param cs  the CharSequence to check, may be null\n      * @param validChars  a String of valid chars, may be null\n      * @return true if it only contains valid chars and is non-null\n      * @since 2.0\n      */\n-    public static boolean containsOnly(String str, String validChars) {\n-        if (str == null || validChars == null) {\n+    public static boolean containsOnly(CharSequence cs, String validChars) {\n+        if (cs == null || validChars == null) {\n             return false;\n         }\n-        return containsOnly(str, validChars.toCharArray());\n+        return containsOnly(cs, validChars.toCharArray());\n     }\n \n     // ContainsNone\n     //-----------------------------------------------------------------------\n     /**\n-     * <p>Checks that the String does not contain certain characters.</p>\n+     * <p>Checks that the CharSequence does not contain certain characters.</p>\n      *\n-     * <p>A <code>null</code> String will return <code>true</code>.\n+     * <p>A <code>null</code> CharSequence will return <code>true</code>.\n      * A <code>null</code> invalid character array will return <code>true</code>.\n-     * An empty String (\"\") always returns true.</p>\n+     * An empty CharSequence (length()=0) always returns true.</p>\n      *\n      * <pre>\n      * StringUtils.containsNone(null, *)       = true\n@@ -1645,19 +1645,19 @@\n      * StringUtils.containsNone(\"abz\", 'xyz')  = false\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param cs  the CharSequence to check, may be null\n      * @param invalidChars  an array of invalid chars, may be null\n      * @return true if it contains none of the invalid chars, or is null\n      * @since 2.0\n      */\n-    public static boolean containsNone(String str, char[] invalidChars) {\n-        if (str == null || invalidChars == null) {\n+    public static boolean containsNone(CharSequence cs, char[] invalidChars) {\n+        if (cs == null || invalidChars == null) {\n             return true;\n         }\n-        int strSize = str.length();\n+        int strSize = cs.length();\n         int validSize = invalidChars.length;\n         for (int i = 0; i < strSize; i++) {\n-            char ch = str.charAt(i);\n+            char ch = cs.charAt(i);\n             for (int j = 0; j < validSize; j++) {\n                 if (invalidChars[j] == ch) {\n                     return false;\n@@ -1668,9 +1668,9 @@\n     }\n \n     /**\n-     * <p>Checks that the String does not contain certain characters.</p>\n+     * <p>Checks that the CharSequence does not contain certain characters.</p>\n      *\n-     * <p>A <code>null</code> String will return <code>true</code>.\n+     * <p>A <code>null</code> CharSequence will return <code>true</code>.\n      * A <code>null</code> invalid character array will return <code>true</code>.\n      * An empty String (\"\") always returns true.</p>\n      *\n@@ -1684,16 +1684,16 @@\n      * StringUtils.containsNone(\"abz\", \"xyz\")  = false\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param cs  the CharSequence to check, may be null\n      * @param invalidChars  a String of invalid chars, may be null\n      * @return true if it contains none of the invalid chars, or is null\n      * @since 2.0\n      */\n-    public static boolean containsNone(String str, String invalidChars) {\n-        if (str == null || invalidChars == null) {\n+    public static boolean containsNone(CharSequence cs, String invalidChars) {\n+        if (cs == null || invalidChars == null) {\n             return true;\n         }\n-        return containsNone(str, invalidChars.toCharArray());\n+        return containsNone(cs, invalidChars.toCharArray());\n     }\n \n     // IndexOfAny strings\n@@ -1725,7 +1725,7 @@\n      * @return the first index of any of the searchStrs in str, -1 if no match\n      */\n     public static int indexOfAny(String str, String[] searchStrs) {\n-        if ((str == null) || (searchStrs == null)) {\n+        if (str == null || searchStrs == null) {\n             return -1;\n         }\n         int sz = searchStrs.length;\n@@ -4606,17 +4606,20 @@\n         }\n     }\n \n-    /**\n-     * Gets a String's length or <code>0</code> if the String is <code>null</code>.\n-     * \n-     * @param str\n-     *            a String or <code>null</code>\n-     * @return String length or <code>0</code> if the String is <code>null</code>.\n-     * @since 2.4\n-     */\n-    public static int length(CharSequence str) {\n-        return str == null ? 0 : str.length();\n-    }\n+\t/**\n+\t * Gets a CharSequence length or <code>0</code> if the CharSequence is\n+\t * <code>null</code>.\n+\t * \n+\t * @param cs\n+\t *            a CharSequence or <code>null</code>\n+\t * @return CharSequence length or <code>0</code> if the CharSequence is\n+\t *         <code>null</code>.\n+\t * @since 2.4\n+\t * @deprecated See {@link CharSequenceUtils#length(CharSequence)}\n+\t */\n+\tpublic static int length(CharSequence cs) {\n+\t\treturn CharSequenceUtils.length(cs);\n+\t}\n     \n     // Centering\n     //-----------------------------------------------------------------------\n@@ -4842,25 +4845,28 @@\n      * StringUtils.capitalize(\"cAt\") = \"CAt\"\n      * </pre>\n      *\n-     * @param str  the String to capitalize, may be null\n+     * @param cs the String to capitalize, may be null\n      * @return the capitalized String, <code>null</code> if null String input\n      * @see WordUtils#capitalize(String)\n      * @see #uncapitalize(String)\n      * @since 2.0\n      */\n-    public static String capitalize(String str) {\n+    public static String capitalize(CharSequence cs) {\n+        if (cs == null ) {\n+            return null;\n+        }\n         int strLen;\n-        if (str == null || (strLen = str.length()) == 0) {\n-            return str;\n+        if ((strLen = cs.length()) == 0) {\n+            return cs.toString();\n         }\n         return new StringBuilder(strLen)\n-            .append(Character.toTitleCase(str.charAt(0)))\n-            .append(str.substring(1))\n+            .append(Character.toTitleCase(cs.charAt(0)))\n+            .append(CharSequenceUtils.subSequence(cs, 1))\n             .toString();\n     }\n \n     /**\n-     * <p>Uncapitalizes a String changing the first letter to title case as\n+     * <p>Uncapitalizes a CharSequence changing the first letter to title case as\n      * per {@link Character#toLowerCase(char)}. No other letters are changed.</p>\n      *\n      * <p>For a word based algorithm, see {@link WordUtils#uncapitalize(String)}.\n@@ -4873,20 +4879,23 @@\n      * StringUtils.uncapitalize(\"CAT\") = \"cAT\"\n      * </pre>\n      *\n-     * @param str  the String to uncapitalize, may be null\n+     * @param cs the String to uncapitalize, may be null\n      * @return the uncapitalized String, <code>null</code> if null String input\n      * @see WordUtils#uncapitalize(String)\n-     * @see #capitalize(String)\n+     * @see #capitalize(CharSequence)\n      * @since 2.0\n      */\n-    public static String uncapitalize(String str) {\n+    public static String uncapitalize(CharSequence cs) {\n+        if (cs == null ) {\n+            return null;\n+        }\n         int strLen;\n-        if (str == null || (strLen = str.length()) == 0) {\n-            return str;\n+        if ((strLen = cs.length()) == 0) {\n+            return cs.toString();\n         }\n         return new StringBuilder(strLen)\n-            .append(Character.toLowerCase(str.charAt(0)))\n-            .append(str.substring(1))\n+            .append(Character.toLowerCase(cs.charAt(0)))\n+            .append(CharSequenceUtils.subSequence(cs, 1))\n             .toString();\n     }\n \n@@ -4976,10 +4985,10 @@\n     // Character Tests\n     //-----------------------------------------------------------------------\n     /**\n-     * <p>Checks if the String contains only unicode letters.</p>\n+     * <p>Checks if the CharSequence contains only unicode letters.</p>\n      *\n      * <p><code>null</code> will return <code>false</code>.\n-     * An empty String (\"\") will return <code>true</code>.</p>\n+     * An empty CharSequence (length()=0) will return <code>true</code>.</p>\n      *\n      * <pre>\n      * StringUtils.isAlpha(null)   = false\n@@ -4990,16 +4999,16 @@\n      * StringUtils.isAlpha(\"ab-c\") = false\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param cs  the CharSequence to check, may be null\n      * @return <code>true</code> if only contains letters, and is non-null\n      */\n-    public static boolean isAlpha(String str) {\n-        if (str == null) {\n+    public static boolean isAlpha(CharSequence cs) {\n+        if (cs == null) {\n             return false;\n         }\n-        int sz = str.length();\n+        int sz = cs.length();\n         for (int i = 0; i < sz; i++) {\n-            if (Character.isLetter(str.charAt(i)) == false) {\n+            if (Character.isLetter(cs.charAt(i)) == false) {\n                 return false;\n             }\n         }\n@@ -5007,11 +5016,11 @@\n     }\n \n     /**\n-     * <p>Checks if the String contains only unicode letters and\n+     * <p>Checks if the CharSequence contains only unicode letters and\n      * space (' ').</p>\n      *\n      * <p><code>null</code> will return <code>false</code>\n-     * An empty String (\"\") will return <code>true</code>.</p>\n+     * An empty CharSequence (length()=0) will return <code>true</code>.</p>\n      *\n      * <pre>\n      * StringUtils.isAlphaSpace(null)   = false\n@@ -5023,17 +5032,17 @@\n      * StringUtils.isAlphaSpace(\"ab-c\") = false\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param cs  the CharSequence to check, may be null\n      * @return <code>true</code> if only contains letters and space,\n      *  and is non-null\n      */\n-    public static boolean isAlphaSpace(String str) {\n-        if (str == null) {\n+    public static boolean isAlphaSpace(CharSequence cs) {\n+        if (cs == null) {\n             return false;\n         }\n-        int sz = str.length();\n+        int sz = cs.length();\n         for (int i = 0; i < sz; i++) {\n-            if ((Character.isLetter(str.charAt(i)) == false) && (str.charAt(i) != ' ')) {\n+            if ((Character.isLetter(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {\n                 return false;\n             }\n         }\n@@ -5041,10 +5050,10 @@\n     }\n \n     /**\n-     * <p>Checks if the String contains only unicode letters or digits.</p>\n+     * <p>Checks if the CharSequence contains only unicode letters or digits.</p>\n      *\n      * <p><code>null</code> will return <code>false</code>.\n-     * An empty String (\"\") will return <code>true</code>.</p>\n+     * An empty CharSequence (length()=0) will return <code>true</code>.</p>\n      *\n      * <pre>\n      * StringUtils.isAlphanumeric(null)   = false\n@@ -5056,17 +5065,17 @@\n      * StringUtils.isAlphanumeric(\"ab-c\") = false\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param cs  the CharSequence to check, may be null\n      * @return <code>true</code> if only contains letters or digits,\n      *  and is non-null\n      */\n-    public static boolean isAlphanumeric(String str) {\n-        if (str == null) {\n+    public static boolean isAlphanumeric(CharSequence cs) {\n+        if (cs == null) {\n             return false;\n         }\n-        int sz = str.length();\n+        int sz = cs.length();\n         for (int i = 0; i < sz; i++) {\n-            if (Character.isLetterOrDigit(str.charAt(i)) == false) {\n+            if (Character.isLetterOrDigit(cs.charAt(i)) == false) {\n                 return false;\n             }\n         }\n@@ -5074,11 +5083,11 @@\n     }\n \n     /**\n-     * <p>Checks if the String contains only unicode letters, digits\n+     * <p>Checks if the CharSequence contains only unicode letters, digits\n      * or space (<code>' '</code>).</p>\n      *\n      * <p><code>null</code> will return <code>false</code>.\n-     * An empty String (\"\") will return <code>true</code>.</p>\n+     * An empty CharSequence (length()=0) will return <code>true</code>.</p>\n      *\n      * <pre>\n      * StringUtils.isAlphanumeric(null)   = false\n@@ -5090,17 +5099,17 @@\n      * StringUtils.isAlphanumeric(\"ab-c\") = false\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param cs  the CharSequence to check, may be null\n      * @return <code>true</code> if only contains letters, digits or space,\n      *  and is non-null\n      */\n-    public static boolean isAlphanumericSpace(String str) {\n-        if (str == null) {\n+    public static boolean isAlphanumericSpace(CharSequence cs) {\n+        if (cs == null) {\n             return false;\n         }\n-        int sz = str.length();\n+        int sz = cs.length();\n         for (int i = 0; i < sz; i++) {\n-            if ((Character.isLetterOrDigit(str.charAt(i)) == false) && (str.charAt(i) != ' ')) {\n+            if ((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {\n                 return false;\n             }\n         }\n@@ -5108,10 +5117,10 @@\n     }\n \n     /**\n-     * <p>Checks if the string contains only ASCII printable characters.</p>\n+     * <p>Checks if the CharSequence contains only ASCII printable characters.</p>\n      * \n      * <p><code>null</code> will return <code>false</code>.\n-     * An empty String (\"\") will return <code>true</code>.</p>\n+     * An empty CharSequence (length()=0) will return <code>true</code>.</p>\n      * \n      * <pre>\n      * StringUtils.isAsciiPrintable(null)     = false\n@@ -5127,18 +5136,18 @@\n      * StringUtils.isAsciiPrintable(\"Ceki G\\u00fclc\\u00fc\") = false\n      * </pre>\n      *\n-     * @param str the string to check, may be null\n+     * @param cs the CharSequence to check, may be null\n      * @return <code>true</code> if every character is in the range\n      *  32 thru 126\n      * @since 2.1\n      */\n-    public static boolean isAsciiPrintable(String str) {\n-        if (str == null) {\n+    public static boolean isAsciiPrintable(CharSequence cs) {\n+        if (cs == null) {\n             return false;\n         }\n-        int sz = str.length();\n+        int sz = cs.length();\n         for (int i = 0; i < sz; i++) {\n-            if (CharUtils.isAsciiPrintable(str.charAt(i)) == false) {\n+            if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) {\n                 return false;\n             }\n         }\n@@ -5146,11 +5155,11 @@\n     }\n \n     /**\n-     * <p>Checks if the String contains only unicode digits.\n+     * <p>Checks if the CharSequence contains only unicode digits.\n      * A decimal point is not a unicode digit and returns false.</p>\n      *\n      * <p><code>null</code> will return <code>false</code>.\n-     * An empty String (\"\") will return <code>true</code>.</p>\n+     * An empty CharSequence (length()=0) will return <code>true</code>.</p>\n      *\n      * <pre>\n      * StringUtils.isNumeric(null)   = false\n@@ -5163,16 +5172,16 @@\n      * StringUtils.isNumeric(\"12.3\") = false\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param cs  the CharSequence to check, may be null\n      * @return <code>true</code> if only contains digits, and is non-null\n      */\n-    public static boolean isNumeric(String str) {\n-        if (str == null) {\n+    public static boolean isNumeric(CharSequence cs) {\n+        if (cs == null) {\n             return false;\n         }\n-        int sz = str.length();\n+        int sz = cs.length();\n         for (int i = 0; i < sz; i++) {\n-            if (Character.isDigit(str.charAt(i)) == false) {\n+            if (Character.isDigit(cs.charAt(i)) == false) {\n                 return false;\n             }\n         }\n@@ -5180,12 +5189,12 @@\n     }\n \n     /**\n-     * <p>Checks if the String contains only unicode digits or space\n+     * <p>Checks if the CharSequence contains only unicode digits or space\n      * (<code>' '</code>).\n      * A decimal point is not a unicode digit and returns false.</p>\n      *\n      * <p><code>null</code> will return <code>false</code>.\n-     * An empty String (\"\") will return <code>true</code>.</p>\n+     * An empty CharSequence (length()=0) will return <code>true</code>.</p>\n      *\n      * <pre>\n      * StringUtils.isNumeric(null)   = false\n@@ -5198,17 +5207,17 @@\n      * StringUtils.isNumeric(\"12.3\") = false\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param cs  the CharSequence to check, may be null\n      * @return <code>true</code> if only contains digits or space,\n      *  and is non-null\n      */\n-    public static boolean isNumericSpace(String str) {\n-        if (str == null) {\n+    public static boolean isNumericSpace(CharSequence cs) {\n+        if (cs == null) {\n             return false;\n         }\n-        int sz = str.length();\n+        int sz = cs.length();\n         for (int i = 0; i < sz; i++) {\n-            if ((Character.isDigit(str.charAt(i)) == false) && (str.charAt(i) != ' ')) {\n+            if ((Character.isDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {\n                 return false;\n             }\n         }\n@@ -5216,10 +5225,10 @@\n     }\n \n     /**\n-     * <p>Checks if the String contains only whitespace.</p>\n+     * <p>Checks if the CharSequence contains only whitespace.</p>\n      *\n      * <p><code>null</code> will return <code>false</code>.\n-     * An empty String (\"\") will return <code>true</code>.</p>\n+     * An empty CharSequence (length()=0) will return <code>true</code>.</p>\n      *\n      * <pre>\n      * StringUtils.isWhitespace(null)   = false\n@@ -5230,17 +5239,17 @@\n      * StringUtils.isWhitespace(\"ab-c\") = false\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param cs  the CharSequence to check, may be null\n      * @return <code>true</code> if only contains whitespace, and is non-null\n      * @since 2.0\n      */\n-    public static boolean isWhitespace(String str) {\n-        if (str == null) {\n+    public static boolean isWhitespace(CharSequence cs) {\n+        if (cs == null) {\n             return false;\n         }\n-        int sz = str.length();\n+        int sz = cs.length();\n         for (int i = 0; i < sz; i++) {\n-            if ((Character.isWhitespace(str.charAt(i)) == false)) {\n+            if ((Character.isWhitespace(cs.charAt(i)) == false)) {\n                 return false;\n             }\n         }\n@@ -5248,10 +5257,10 @@\n     }\n \n     /**\n-     * <p>Checks if the String contains only lowercase characters.</p>\n+     * <p>Checks if the CharSequence contains only lowercase characters.</p>\n      *\n      * <p><code>null</code> will return <code>false</code>.\n-     * An empty String (\"\") will return <code>false</code>.</p>\n+     * An empty CharSequence (length()=0) will return <code>false</code>.</p>\n      *\n      * <pre>\n      * StringUtils.isAllLowerCase(null)   = false\n@@ -5261,17 +5270,17 @@\n      * StringUtils.isAllLowerCase(\"abC\") = false\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param cs  the CharSequence to check, may be null\n      * @return <code>true</code> if only contains lowercase characters, and is non-null\n      * @since 2.5\n      */\n-    public static boolean isAllLowerCase(String str) {\n-        if (str == null || isEmpty(str)) {\n+    public static boolean isAllLowerCase(CharSequence cs) {\n+        if (cs == null || isEmpty(cs)) {\n             return false;\n         }\n-        int sz = str.length();\n+        int sz = cs.length();\n         for (int i = 0; i < sz; i++) {\n-            if (Character.isLowerCase(str.charAt(i)) == false) {\n+            if (Character.isLowerCase(cs.charAt(i)) == false) {\n                 return false;\n             }\n         }\n@@ -5279,10 +5288,10 @@\n     }\n \n     /**\n-     * <p>Checks if the String contains only uppercase characters.</p>\n+     * <p>Checks if the CharSequence contains only uppercase characters.</p>\n      *\n      * <p><code>null</code> will return <code>false</code>.\n-     * An empty String (\"\") will return <code>false</code>.</p>\n+     * An empty String (length()=0) will return <code>false</code>.</p>\n      *\n      * <pre>\n      * StringUtils.isAllUpperCase(null)   = false\n@@ -5292,17 +5301,17 @@\n      * StringUtils.isAllUpperCase(\"aBC\") = false\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param cs the CharSequence to check, may be null\n      * @return <code>true</code> if only contains uppercase characters, and is non-null\n      * @since 2.5\n      */\n-    public static boolean isAllUpperCase(String str) {\n-        if (str == null || isEmpty(str)) {\n+    public static boolean isAllUpperCase(CharSequence cs) {\n+        if (cs == null || isEmpty(cs)) {\n             return false;\n         }\n-        int sz = str.length();\n+        int sz = cs.length();\n         for (int i = 0; i < sz; i++) {\n-            if (Character.isUpperCase(str.charAt(i)) == false) {\n+            if (Character.isUpperCase(cs.charAt(i)) == false) {\n                 return false;\n             }\n         }\n@@ -5393,7 +5402,7 @@\n         if (str == null) {\n             return null;\n         }\n-        return new StringBuilder(str).reverse().toString();\n+        return CharSequenceUtils.reverse(str).toString();\n     }\n \n     /**\n@@ -5619,8 +5628,8 @@\n     }\n \n     /**\n-     * <p>Compares two Strings, and returns the index at which the\n-     * Strings begin to differ.</p>\n+     * <p>Compares two CharSequences, and returns the index at which the\n+     * CharSequences begin to differ.</p>\n      *\n      * <p>For example,\n      * <code>indexOfDifference(\"i am a machine\", \"i am a robot\") -> 7</code></p>\n@@ -5636,33 +5645,33 @@\n      * StringUtils.indexOfDifference(\"abcde\", \"xyz\") = 0\n      * </pre>\n      *\n-     * @param str1  the first String, may be null\n-     * @param str2  the second String, may be null\n-     * @return the index where str2 and str1 begin to differ; -1 if they are equal\n+     * @param cs1  the first CharSequence, may be null\n+     * @param cs2  the second CharSequence, may be null\n+     * @return the index where cs1 and cs2 begin to differ; -1 if they are equal\n      * @since 2.0\n      */\n-    public static int indexOfDifference(String str1, String str2) {\n-        if (str1 == str2) {\n+    public static int indexOfDifference(CharSequence cs1, CharSequence cs2) {\n+        if (cs1 == cs2) {\n             return -1;\n         }\n-        if (str1 == null || str2 == null) {\n+        if (cs1 == null || cs2 == null) {\n             return 0;\n         }\n         int i;\n-        for (i = 0; i < str1.length() && i < str2.length(); ++i) {\n-            if (str1.charAt(i) != str2.charAt(i)) {\n+        for (i = 0; i < cs1.length() && i < cs2.length(); ++i) {\n+            if (cs1.charAt(i) != cs2.charAt(i)) {\n                 break;\n             }\n         }\n-        if (i < str2.length() || i < str1.length()) {\n+        if (i < cs2.length() || i < cs1.length()) {\n             return i;\n         }\n         return -1;\n     }\n \n     /**\n-     * <p>Compares all Strings in an array and returns the index at which the\n-     * Strings begin to differ.</p>\n+     * <p>Compares all CharSequences in an array and returns the index at which the\n+     * CharSequences begin to differ.</p>\n      *\n      * <p>For example,\n      * <code>indexOfDifference(new String[] {\"i am a machine\", \"i am a robot\"}) -> 7</code></p>\n@@ -5687,17 +5696,17 @@\n      * StringUtils.indexOfDifference(new String[] {\"i am a machine\", \"i am a robot\"}) = 7\n      * </pre>\n      *\n-     * @param strs  array of strings, entries may be null\n+     * @param css  array of CharSequences, entries may be null\n      * @return the index where the strings begin to differ; -1 if they are all equal\n      * @since 2.4\n      */\n-    public static int indexOfDifference(String[] strs) {\n-        if (strs == null || strs.length <= 1) {\n+    public static int indexOfDifference(CharSequence[] css) {\n+        if (css == null || css.length <= 1) {\n             return -1;\n         }\n         boolean anyStringNull = false;\n         boolean allStringsNull = true;\n-        int arrayLen = strs.length;\n+        int arrayLen = css.length;\n         int shortestStrLen = Integer.MAX_VALUE;\n         int longestStrLen = 0;\n \n@@ -5705,13 +5714,13 @@\n         // sure we are not exceeding the length of the string each time through\n         // the bottom loop.\n         for (int i = 0; i < arrayLen; i++) {\n-            if (strs[i] == null) {\n+            if (css[i] == null) {\n                 anyStringNull = true;\n                 shortestStrLen = 0;\n             } else {\n                 allStringsNull = false;\n-                shortestStrLen = Math.min(strs[i].length(), shortestStrLen);\n-                longestStrLen = Math.max(strs[i].length(), longestStrLen);\n+                shortestStrLen = Math.min(css[i].length(), shortestStrLen);\n+                longestStrLen = Math.max(css[i].length(), longestStrLen);\n             }\n         }\n \n@@ -5728,9 +5737,9 @@\n         // find the position with the first difference across all strings\n         int firstDiff = -1;\n         for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {\n-            char comparisonChar = strs[0].charAt(stringPos);\n+            char comparisonChar = css[0].charAt(stringPos);\n             for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {\n-                if (strs[arrayPos].charAt(stringPos) != comparisonChar) {\n+                if (css[arrayPos].charAt(stringPos) != comparisonChar) {\n                     firstDiff = stringPos;\n                     break;\n                 }\n@@ -5838,7 +5847,7 @@\n      * @return result distance\n      * @throws IllegalArgumentException if either String input <code>null</code>\n      */\n-    public static int getLevenshteinDistance(String s, String t) {\n+    public static int getLevenshteinDistance(CharSequence s, CharSequence t) {\n         if (s == null || t == null) {\n             throw new IllegalArgumentException(\"Strings must not be null\");\n         }\n@@ -5871,7 +5880,7 @@\n \n         if (n > m) {\n             // swap the input strings to consume less memory\n-            String tmp = s;\n+        \tCharSequence tmp = s;\n             s = t;\n             t = tmp;\n             n = m;\n@@ -6109,7 +6118,7 @@\n      */\n     private static boolean endsWith(String str, String suffix, boolean ignoreCase) {\n         if (str == null || suffix == null) {\n-            return (str == null && suffix == null);\n+            return str == null && suffix == null;\n         }\n         if (suffix.length() > str.length()) {\n             return false;\n\n"
    },
    "Lang-19": {
        "Buggy Function": "    public int translate(CharSequence input, int index, Writer out) throws IOException {\n        int seqEnd = input.length();\n        // Uses -2 to ensure there is something after the &#\n        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {\n            int start = index + 2;\n            boolean isHex = false;\n\n            char firstChar = input.charAt(start);\n            if(firstChar == 'x' || firstChar == 'X') {\n                start++;\n                isHex = true;\n\n                // Check there's more than just an x after the &#\n            }\n\n            int end = start;\n            // Note that this supports character codes without a ; on the end\n            while(input.charAt(end) != ';') \n            {\n                end++;\n            }\n\n            int entityValue;\n            try {\n                if(isHex) {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n                } else {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n                }\n            } catch(NumberFormatException nfe) {\n            System.err.println(\"FAIL: \" + input.subSequence(start, end) + \"[\" + start +\"][\"+ end +\"]\");\n                return 0;\n            }\n\n            if(entityValue > 0xFFFF) {\n                char[] chrs = Character.toChars(entityValue);\n                out.write(chrs[0]);\n                out.write(chrs[1]);\n            } else {\n                out.write(entityValue);\n            }\n\n\n            return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n        }\n        return 0;\n    }",
        "Inducing Changes": "Add Whole Class File of buggy method"
    },
    "Lang-21": {
        "Buggy Function": "    public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());\n    }",
        "Inducing Changes": "diff --git a/src/java/org/apache/commons/lang/time/DateUtils.java b/src/java/org/apache/commons/lang/time/DateUtils.java\nindex dfbe70a..9cfd761 100644\n--- a/src/java/org/apache/commons/lang/time/DateUtils.java\n+++ b/src/java/org/apache/commons/lang/time/DateUtils.java\n@@ -31,7 +31,7 @@\n  * @author \u003ca href\u003d\"mailto:ggregory@seagullsw.com\"\u003eGary Gregory\u003c/a\u003e\n  * @author Phil Steitz\n  * @since 2.0\n- * @version $Id: DateUtils.java,v 1.32 2004/10/13 21:48:00 scolebourne Exp $\n+ * @version $Id: DateUtils.java,v 1.33 2004/10/16 17:08:42 scolebourne Exp $\n  */\n public class DateUtils {\n     \n@@ -125,8 +125,8 @@\n      * 28 Mar 2002 13:45 and 12 Mar 2002 13:45 would return false.\n      * \u003c/p\u003e\n      * \n-     * @param date1  the first date, not null\n-     * @param date2  the second date, not null\n+     * @param date1  the first date, not altered, not null\n+     * @param date2  the second date, not altered, not null\n      * @return true if they represent the same day\n      * @throws IllegalArgumentException if either date is \u003ccode\u003enull\u003c/code\u003e\n      * @since 2.1\n@@ -142,7 +142,6 @@\n         return isSameDay(cal1, cal2);\n     }\n \n-    //-----------------------------------------------------------------------\n     /**\n      * \u003cp\u003eChecks if two calendar objects are on the same day ignoring time.\u003c/p\u003e\n      *\n@@ -150,8 +149,8 @@\n      * 28 Mar 2002 13:45 and 12 Mar 2002 13:45 would return false.\n      * \u003c/p\u003e\n      * \n-     * @param cal1  the first calendar, not null\n-     * @param cal2  the second calendar, not null\n+     * @param cal1  the first calendar, not altered, not null\n+     * @param cal2  the second calendar, not altered, not null\n      * @return true if they represent the same day\n      * @throws IllegalArgumentException if either calendar is \u003ccode\u003enull\u003c/code\u003e\n      * @since 2.1\n@@ -167,6 +166,70 @@\n \n     //-----------------------------------------------------------------------\n     /**\n+     * \u003cp\u003eChecks if two date objects represent the same instant in time.\u003c/p\u003e\n+     *\n+     * \u003cp\u003eThis method compares the long millisecond time of the two objects.\u003c/p\u003e\n+     * \n+     * @param date1  the first date, not altered, not null\n+     * @param date2  the second date, not altered, not null\n+     * @return true if they represent the same millisecond instant\n+     * @throws IllegalArgumentException if either date is \u003ccode\u003enull\u003c/code\u003e\n+     * @since 2.1\n+     */\n+    public static boolean isSameInstant(Date date1, Date date2) {\n+        if (date1 \u003d\u003d null || date2 \u003d\u003d null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        return (date1.getTime() \u003d\u003d date2.getTime());\n+    }\n+\n+    /**\n+     * \u003cp\u003eChecks if two calendar objects represent the same instant in time.\u003c/p\u003e\n+     *\n+     * \u003cp\u003eThis method compares the long millisecond time of the two objects.\u003c/p\u003e\n+     * \n+     * @param cal1  the first calendar, not altered, not null\n+     * @param cal2  the second calendar, not altered, not null\n+     * @return true if they represent the same millisecond instant\n+     * @throws IllegalArgumentException if either date is \u003ccode\u003enull\u003c/code\u003e\n+     * @since 2.1\n+     */\n+    public static boolean isSameInstant(Calendar cal1, Calendar cal2) {\n+        if (cal1 \u003d\u003d null || cal2 \u003d\u003d null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        return (cal1.getTime().getTime() \u003d\u003d cal2.getTime().getTime());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * \u003cp\u003eChecks if two calendar objects represent the same local time.\u003c/p\u003e\n+     *\n+     * \u003cp\u003eThis method compares the values of the fields of the two objects.\n+     * In addition, both calendars must be the same of the same type.\u003c/p\u003e\n+     * \n+     * @param cal1  the first calendar, not altered, not null\n+     * @param cal2  the second calendar, not altered, not null\n+     * @return true if they represent the same millisecond instant\n+     * @throws IllegalArgumentException if either date is \u003ccode\u003enull\u003c/code\u003e\n+     * @since 2.1\n+     */\n+    public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n+        if (cal1 \u003d\u003d null || cal2 \u003d\u003d null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        return (cal1.get(Calendar.MILLISECOND) \u003d\u003d cal2.get(Calendar.MILLISECOND) \u0026\u0026\n+                cal1.get(Calendar.SECOND) \u003d\u003d cal2.get(Calendar.SECOND) \u0026\u0026\n+                cal1.get(Calendar.MINUTE) \u003d\u003d cal2.get(Calendar.MINUTE) \u0026\u0026\n+                cal1.get(Calendar.HOUR) \u003d\u003d cal2.get(Calendar.HOUR) \u0026\u0026\n+                cal1.get(Calendar.DAY_OF_YEAR) \u003d\u003d cal2.get(Calendar.DAY_OF_YEAR) \u0026\u0026\n+                cal1.get(Calendar.YEAR) \u003d\u003d cal2.get(Calendar.YEAR) \u0026\u0026\n+                cal1.get(Calendar.ERA) \u003d\u003d cal2.get(Calendar.ERA) \u0026\u0026\n+                cal1.getClass() \u003d\u003d cal2.getClass());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * \u003cp\u003eRound this date, leaving the field specified as the most\n      * significant field.\u003c/p\u003e\n      *\n"
    },
    "Lang-22": {
        "Buggy Function": "    private static int greatestCommonDivisor(int u, int v) {\n        // From Commons Math:\n        //if either operand is abs 1, return 1:\n        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n            return 1;\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        if (u>0) { u=-u; } // make u negative\n        if (v>0) { v=-v; } // make v negative\n        // B1. [Find power of 2]\n        int k=0;\n        while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...\n            u/=2; v/=2; k++; // cast out twos.\n        }\n        if (k==31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        //     one is odd.\n        int t = ((u&1)==1) ? v : -(u/2)/*B3*/;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u<0 && v<0; */\n            // B4/B3: cast out twos from t.\n            while ((t&1)==0) { // while t is even..\n                t/=2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t>0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            t = (v - u)/2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t!=0);\n        return -u*(1<<k); // gcd is u*2^k\n    }",
        "Inducing Changes": "diff --git a/src/java/org/apache/commons/lang/math/Fraction.java b/src/java/org/apache/commons/lang/math/Fraction.java\nindex c00c2c7..5f8e565 100644\n--- a/src/java/org/apache/commons/lang/math/Fraction.java\n+++ b/src/java/org/apache/commons/lang/math/Fraction.java\n@@ -567,11 +567,14 @@\n      * @return the greatest common divisor, never zero\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n+        //if either op. is abs 0 or 1, return 1:\n+        if (Math.abs(u) \u003c\u003d 1 || Math.abs(v) \u003c\u003d 1) {\n+            return 1;\n+        }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can\u0027t necessarily negate a negative number without\n         // overflow)\n-        /* assert u!\u003d0 \u0026\u0026 v!\u003d0; */\n         if (u\u003e0) { u\u003d-u; } // make u negative\n         if (v\u003e0) { v\u003d-v; } // make v negative\n         // B1. [Find power of 2]\n"
    },
    "Lang-25": {
        "Buggy Function": "private static final String[][] ISO8859_1_ESCAPE = {\n    {\"\\u00A0\", \"&nbsp;\"}, // non-breaking space\n    {\"\\u00A1\", \"&iexcl;\"}, // inverted exclamation mark\n    {\"\\u00A2\", \"&cent;\"}, // cent sign\n    {\"\\u00A3\", \"&pound;\"}, // pound sign\n    {\"\\u00A4\", \"&curren;\"}, // currency sign\n    {\"\\u00A5\", \"&yen;\"}, // yen sign = yuan sign\n    {\"\\u00A6\", \"&brvbar;\"}, // broken bar = broken vertical bar\n    {\"\\u00A7\", \"&sect;\"}, // section sign\n    {\"\\u00A8\", \"&uml;\"}, // diaeresis = spacing diaeresis\n    {\"\\u00A9\", \"&copy;\"}, // � - copyright sign\n    {\"\\u00AA\", \"&ordf;\"}, // feminine ordinal indicator\n    {\"\\u00AB\", \"&laquo;\"}, // left-pointing double angle quotation mark = left pointing guillemet\n    {\"\\u00AC\", \"&not;\"}, // not sign\n    {\"\\u00AD\", \"&shy;\"}, // soft hyphen = discretionary hyphen\n    {\"\\u00AE\", \"&reg;\"}, // � - registered trademark sign\n    {\"\\u00AF\", \"&macr;\"}, // macron = spacing macron = overline = APL overbar\n    {\"\\u00B0\", \"&deg;\"}, // degree sign\n    {\"\\u00B1\", \"&plusmn;\"}, // plus-minus sign = plus-or-minus sign\n    {\"\\u00B2\", \"&sup2;\"}, // superscript two = superscript digit two = squared\n    {\"\\u00B3\", \"&sup3;\"}, // superscript three = superscript digit three = cubed\n    {\"\\u00B4\", \"&acute;\"}, // acute accent = spacing acute\n    {\"\\u00B5\", \"&micro;\"}, // micro sign\n    {\"\\u00B6\", \"&para;\"}, // pilcrow sign = paragraph sign\n    {\"\\u00B7\", \"&middot;\"}, // middle dot = Georgian comma = Greek middle dot\n    {\"\\u00B8\", \"&cedil;\"}, // cedilla = spacing cedilla\n    {\"\\u00B9\", \"&sup1;\"}, // superscript one = superscript digit one\n    {\"\\u00BA\", \"&ordm;\"}, // masculine ordinal indicator\n    {\"\\u00BB\", \"&raquo;\"}, // right-pointing double angle quotation mark = right pointing guillemet\n    {\"\\u00BC\", \"&frac14;\"}, // vulgar fraction one quarter = fraction one quarter\n    {\"\\u00BD\", \"&frac12;\"}, // vulgar fraction one half = fraction one half\n    {\"\\u00BE\", \"&frac34;\"}, // vulgar fraction three quarters = fraction three quarters\n    {\"\\u00BF\", \"&iquest;\"}, // inverted question mark = turned question mark\n    {\"\\u00C0\", \"&Agrave;\"}, // � - uppercase A, grave accent\n    {\"\\u00C1\", \"&Aacute;\"}, // � - uppercase A, acute accent\n    {\"\\u00C2\", \"&Acirc;\"}, // � - uppercase A, circumflex accent\n    {\"\\u00C3\", \"&Atilde;\"}, // � - uppercase A, tilde\n    {\"\\u00C4\", \"&Auml;\"}, // � - uppercase A, umlaut\n    {\"\\u00C5\", \"&Aring;\"}, // � - uppercase A, ring\n    {\"\\u00C6\", \"&AElig;\"}, // � - uppercase AE\n    {\"\\u00C7\", \"&Ccedil;\"}, // � - uppercase C, cedilla\n    {\"\\u00C8\", \"&Egrave;\"}, // � - uppercase E, grave accent\n    {\"\\u00C9\", \"&Eacute;\"}, // � - uppercase E, acute accent\n    {\"\\u00CB\", \"&Ecirc;\"}, // � - uppercase E, circumflex accent\n    {\"\\u00CC\", \"&Euml;\"}, // � - uppercase E, umlaut\n    {\"\\u00CD\", \"&Igrave;\"}, // � - uppercase I, grave accent\n    {\"\\u00CE\", \"&Iacute;\"}, // � - uppercase I, acute accent\n    {\"\\u00CF\", \"&Icirc;\"}, // � - uppercase I, circumflex accent\n    {\"\\u00D0\", \"&Iuml;\"}, // � - uppercase I, umlaut\n    {\"\\u00D1\", \"&ETH;\"}, // � - uppercase Eth, Icelandic\n    {\"\\u00D2\", \"&Ntilde;\"}, // � - uppercase N, tilde\n    {\"\\u00D3\", \"&Ograve;\"}, // � - uppercase O, grave accent\n    {\"\\u00D4\", \"&Oacute;\"}, // � - uppercase O, acute accent\n    {\"\\u00D5\", \"&Ocirc;\"}, // � - uppercase O, circumflex accent\n    {\"\\u00D6\", \"&Otilde;\"}, // � - uppercase O, tilde\n    {\"\\u00D7\", \"&Ouml;\"}, // � - uppercase O, umlaut\n    {\"\\u00D8\", \"&times;\"}, // multiplication sign\n    {\"\\u00D9\", \"&Oslash;\"}, // � - uppercase O, slash\n    {\"\\u00DA\", \"&Ugrave;\"}, // � - uppercase U, grave accent\n    {\"\\u00DB\", \"&Uacute;\"}, // � - uppercase U, acute accent\n    {\"\\u00DC\", \"&Ucirc;\"}, // � - uppercase U, circumflex accent\n    {\"\\u00DD\", \"&Uuml;\"}, // � - uppercase U, umlaut\n    {\"\\u00DE\", \"&Yacute;\"}, // � - uppercase Y, acute accent\n    {\"\\u00DF\", \"&THORN;\"}, // � - uppercase THORN, Icelandic\n    {\"\\u00E0\", \"&szlig;\"}, // � - lowercase sharps, German\n    {\"\\u00E1\", \"&agrave;\"}, // � - lowercase a, grave accent\n    {\"\\u00E2\", \"&aacute;\"}, // � - lowercase a, acute accent\n    {\"\\u00E3\", \"&acirc;\"}, // � - lowercase a, circumflex accent\n    {\"\\u00E4\", \"&atilde;\"}, // � - lowercase a, tilde\n    {\"\\u00E5\", \"&auml;\"}, // � - lowercase a, umlaut\n    {\"\\u00E5\", \"&aring;\"}, // � - lowercase a, ring\n    {\"\\u00E6\", \"&aelig;\"}, // � - lowercase ae\n    {\"\\u00E7\", \"&ccedil;\"}, // � - lowercase c, cedilla\n    {\"\\u00E8\", \"&egrave;\"}, // � - lowercase e, grave accent\n    {\"\\u00E9\", \"&eacute;\"}, // � - lowercase e, acute accent\n    {\"\\u00EA\", \"&ecirc;\"}, // � - lowercase e, circumflex accent\n    {\"\\u00EB\", \"&euml;\"}, // � - lowercase e, umlaut\n    {\"\\u00EC\", \"&igrave;\"}, // � - lowercase i, grave accent\n    {\"\\u00ED\", \"&iacute;\"}, // � - lowercase i, acute accent\n    {\"\\u00EE\", \"&icirc;\"}, // � - lowercase i, circumflex accent\n    {\"\\u00EF\", \"&iuml;\"}, // � - lowercase i, umlaut\n    {\"\\u00F0\", \"&eth;\"}, // � - lowercase eth, Icelandic\n    {\"\\u00F1\", \"&ntilde;\"}, // � - lowercase n, tilde\n    {\"\\u00F2\", \"&ograve;\"}, // � - lowercase o, grave accent\n    {\"\\u00F3\", \"&oacute;\"}, // � - lowercase o, acute accent\n    {\"\\u00F4\", \"&ocirc;\"}, // � - lowercase o, circumflex accent\n    {\"\\u00F5\", \"&otilde;\"}, // � - lowercase o, tilde\n    {\"\\u00F6\", \"&ouml;\"}, // � - lowercase o, umlaut\n    {\"\\u00F7\", \"&divide;\"}, // division sign\n    {\"\\u00F8\", \"&oslash;\"}, // � - lowercase o, slash\n    {\"\\u00F9\", \"&ugrave;\"}, // � - lowercase u, grave accent\n    {\"\\u00FA\", \"&uacute;\"}, // � - lowercase u, acute accent\n    {\"\\u00FB\", \"&ucirc;\"}, // � - lowercase u, circumflex accent\n    {\"\\u00FC\", \"&uuml;\"}, // � - lowercase u, umlaut\n    {\"\\u00FD\", \"&yacute;\"}, // � - lowercase y, acute accent\n    {\"\\u00FE\", \"&thorn;\"}, // � - lowercase thorn, Icelandic\n    {\"\\u00FF\", \"&yuml;\"}, // � - lowercase y, umlaut\n};",
        "Inducing Changes": "Add Whole Class File of buggy method"
    },
    "Lang-26": {
        "Buggy Function": "    public String format(Date date) {\n        Calendar c = new GregorianCalendar(mTimeZone);\n        c.setTime(date);\n        return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n    }",
        "Inducing Changes": "Add Whole Class File of buggy method"
    },
    "Lang-28": {
        "Buggy Function": "    public int translate(CharSequence input, int index, Writer out) throws IOException {\n        // TODO: Protect from ArrayIndexOutOfBounds\n        if(input.charAt(index) == '&' && input.charAt(index + 1) == '#') {\n            int start = index + 2;\n            boolean isHex = false;\n\n            char firstChar = input.charAt(start);\n            if(firstChar == 'x' || firstChar == 'X') {\n                start++;\n                isHex = true;\n            }\n\n            int end = start;\n            while(input.charAt(end) != ';') {\n                end++;\n            }\n\n            int entityValue;\n            try {\n                if(isHex) {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n                } else {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n                }\n            } catch(NumberFormatException nfe) {\n                return 0;\n            }\n\n                out.write(entityValue);\n            return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n        }\n        return 0;\n    }",
        "Inducing Changes": "Add Whole Class File of buggy method"
    },
    "Lang-31": {
        "Buggy Function": "\tpublic static boolean containsAny(CharSequence cs, char[] searchChars) {\n\t\tif (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n\t\t\treturn false;\n\t\t}\n\t\tint csLength = cs.length();\n\t\tint searchLength = searchChars.length;\n\t\tfor (int i = 0; i < csLength; i++) {\n\t\t\tchar ch = cs.charAt(i);\n\t\t\tfor (int j = 0; j < searchLength; j++) {\n\t\t\t\tif (searchChars[j] == ch) {\n\t\t\t\t\t\t// ch is a supplementary character\n\t\t\t\t\t\t// ch is in the Basic Multilingual Plane\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}",
        "Inducing Changes": "diff --git a/src/java/org/apache/commons/lang/StringUtils.java b/src/java/org/apache/commons/lang/StringUtils.java\nindex 57c36c6..ab1422d 100644\n--- a/src/java/org/apache/commons/lang/StringUtils.java\n+++ b/src/java/org/apache/commons/lang/StringUtils.java\n@@ -40,8 +40,8 @@\n  *      - null-safe index-of checks\n  *  \u003cli\u003e\u003cb\u003eIndexOfAny/LastIndexOfAny/IndexOfAnyBut/LastIndexOfAnyBut\u003c/b\u003e\n  *      - index-of any of a set of Strings\u003c/li\u003e\n- *  \u003cli\u003e\u003cb\u003eContainsOnly/ContainsNone\u003c/b\u003e\n- *      - does String contains only/none of these characters\u003c/li\u003e\n+ *  \u003cli\u003e\u003cb\u003eContainsOnly/ContainsNone/ContainsAny\u003c/b\u003e\n+ *      - does String contains only/none/any of these characters\u003c/li\u003e\n  *  \u003cli\u003e\u003cb\u003eSubstring/Left/Right/Mid\u003c/b\u003e\n  *      - null-safe substring extractions\u003c/li\u003e\n  *  \u003cli\u003e\u003cb\u003eSubstringBefore/SubstringAfter/SubstringBetween\u003c/b\u003e\n@@ -1137,6 +1137,78 @@\n         return indexOfAny(str, searchChars.toCharArray());\n     }\n \n+    // ContainsAny\n+    //-----------------------------------------------------------------------\n+    /**\n+     * \u003cp\u003eChecks if the String contains any character in the given\n+     * set of characters.\u003c/p\u003e\n+     *\n+     * \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e String will return \u003ccode\u003efalse\u003c/code\u003e.\n+     * A \u003ccode\u003enull\u003c/code\u003e or zero length search array will return \u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n+     *\n+     * \u003cpre\u003e\n+     * StringUtils.containsAny(null, *)                \u003d false\n+     * StringUtils.containsAny(\"\", *)                  \u003d false\n+     * StringUtils.containsAny(*, null)                \u003d false\n+     * StringUtils.containsAny(*, [])                  \u003d false\n+     * StringUtils.containsAny(\"zzabyycdxx\",[\u0027z\u0027,\u0027a\u0027]) \u003d true\n+     * StringUtils.containsAny(\"zzabyycdxx\",[\u0027b\u0027,\u0027y\u0027]) \u003d true\n+     * StringUtils.containsAny(\"aba\", [\u0027z\u0027])           \u003d false\n+     * \u003c/pre\u003e\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchChars  the chars to search for, may be null\n+     * @return the \u003ccode\u003etrue\u003c/code\u003e if any of the chars are found,\n+     * \u003ccode\u003efalse\u003c/code\u003e if no match or null input\n+     * @since 2.4\n+     */\n+    public static boolean containsAny(String str, char[] searchChars) {\n+        if (str \u003d\u003d null || str.length() \u003d\u003d 0 ||\n+            searchChars \u003d\u003d null || searchChars.length \u003d\u003d 0) {\n+            return false;\n+        }\n+        for (int i \u003d 0; i \u003c str.length(); i++) {\n+            char ch \u003d str.charAt(i);\n+            for (int j \u003d 0; j \u003c searchChars.length; j++) {\n+                if (searchChars[j] \u003d\u003d ch) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * \u003cp\u003eChecks if the String contains any character in the given\n+     * set of characters.\u003c/p\u003e\n+     *\n+     * \u003cp\u003eA \u003ccode\u003enull\u003c/code\u003e String will return \u003ccode\u003efalse\u003c/code\u003e.\n+     * A \u003ccode\u003enull\u003c/code\u003e search string will return \u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n+     *\n+     * \u003cpre\u003e\n+     * StringUtils.containsAny(null, *)            \u003d false\n+     * StringUtils.containsAny(\"\", *)              \u003d false\n+     * StringUtils.containsAny(*, null)            \u003d false\n+     * StringUtils.containsAny(*, \"\")              \u003d false\n+     * StringUtils.containsAny(\"zzabyycdxx\", \"za\") \u003d true\n+     * StringUtils.containsAny(\"zzabyycdxx\", \"by\") \u003d true\n+     * StringUtils.containsAny(\"aba\",\"z\")          \u003d false\n+     * \u003c/pre\u003e\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchChars  the chars to search for, may be null\n+     * @return the \u003ccode\u003etrue\u003c/code\u003e if any of the chars are found,\n+     * \u003ccode\u003efalse\u003c/code\u003e if no match or null input\n+     * @since 2.4\n+     */\n+    public static boolean containsAny(String str, String searchChars) {\n+        if (searchChars \u003d\u003d null) {\n+            return false;\n+        } else {\n+            return containsAny(str, searchChars.toCharArray());\n+        }\n+    }\n+\n     // IndexOfAnyBut chars\n     //-----------------------------------------------------------------------\n     /**\n"
    },
    "Lang-40": {
        "Buggy Function": "    public static boolean containsIgnoreCase(String str, String searchStr) {\n        if (str == null || searchStr == null) {\n            return false;\n        }\n        return contains(str.toUpperCase(), searchStr.toUpperCase());\n    }",
        "Inducing Changes": "diff --git a/src/java/org/apache/commons/lang/StringUtils.java b/src/java/org/apache/commons/lang/StringUtils.java\nindex 4d0d8c5..47bc32f 100644\n--- a/src/java/org/apache/commons/lang/StringUtils.java\n+++ b/src/java/org/apache/commons/lang/StringUtils.java\n@@ -1034,6 +1034,36 @@\n         return str.indexOf(searchStr) >= 0;\n     }\n \n+ /**\n+     * <p>Checks if String contains a search String irrespective of case,\n+     * handling <code>null</code>. This method uses\n+     * {@link #contains(String, String)}.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>false</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.contains(null, *) = false\n+     * StringUtils.contains(*, null) = false\n+     * StringUtils.contains(\"\", \"\") = true\n+     * StringUtils.contains(\"abc\", \"\") = true\n+     * StringUtils.contains(\"abc\", \"a\") = true\n+     * StringUtils.contains(\"abc\", \"z\") = false\n+     * StringUtils.contains(\"abc\", \"A\") = true\n+     * StringUtils.contains(\"abc\", \"Z\") = false\n+     * </pre>\n+     *\n+     * @param str the String to check, may be null\n+     * @param searchStr the String to find, may be null\n+     * @return true if the String contains the search String irrespective of\n+     * case or false if not or <code>null</code> string input\n+     */\n+    public static boolean containsIgnoreCase(String str, String searchStr) {\n+        if (str == null || searchStr == null) {\n+            return false;\n+        }\n+        return contains(str.toUpperCase(), searchStr.toUpperCase());\n+    } \n+\n     // IndexOfAny chars\n     //-----------------------------------------------------------------------\n     /**\n\n"
    },
    "Lang-43": {
        "Buggy Function": "    private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n            StringBuffer appendTo, boolean escapingOn) {\n        int start = pos.getIndex();\n        char[] c = pattern.toCharArray();\n        if (escapingOn && c[start] == QUOTE) {\n            return appendTo == null ? null : appendTo.append(QUOTE);\n        }\n        int lastHold = start;\n        for (int i = pos.getIndex(); i < pattern.length(); i++) {\n            if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n                        QUOTE);\n                pos.setIndex(i + ESCAPED_QUOTE.length());\n                lastHold = pos.getIndex();\n                continue;\n            }\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                next(pos);\n                return appendTo == null ? null : appendTo.append(c, lastHold,\n                        pos.getIndex() - lastHold);\n            default:\n                next(pos);\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + start);\n    }",
        "Inducing Changes": "diff --git a/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java b/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\nindex 4c75c75..d0cf6ed 100644\n--- a/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\n+++ b/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\n@@ -20,25 +20,19 @@\n import java.text.MessageFormat;\n import java.text.ParsePosition;\n import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n import java.util.Locale;\n+import java.util.Map;\n \n-import org.apache.commons.lang.StringUtils;\n import org.apache.commons.lang.Validate;\n \n /**\n  * Extends <code>MessageFormat</code> to allow pluggable/additional formatting\n- * options for embedded format elements; requires a \"meta-format\", that is a\n- * <code>Format</code> capable of parsing and formatting other\n- * <code>Format</code>s.\n- * \n- * Limitations:\n- * <ul>\n- * <li><code>toPattern()</code> results are tailored to JDK 1.4+ output and\n- * will produce fairly drastically different results on earlier JDKs.</li>\n- * <li>Recursive choice formats do not inherit knowledge of the extended\n- * formatters and are limited to those available with\n- * <code>java.text.MessageFormat</code>.</li>\n- * </ul>\n+ * options for embedded format elements; requires elaboration.\n+ *\n+ * Note that the mutator methods for the replacement Formats are to be considered\n+ * unnecessary and thus have been disabled (UnsupportedOperationException).\n  * \n  * @author Matt Benson\n  * @since 2.4\n@@ -47,299 +41,24 @@\n public class ExtendedMessageFormat extends MessageFormat {\n     private static final long serialVersionUID = -2362048321261811743L;\n \n-    /**\n-     * Get a default meta-format for the default Locale. This will produce\n-     * behavior identical to a <code>java.lang.MessageFormat</code> using the\n-     * default locale.\n-     * \n-     * @return Format\n-     */\n-    public static Format createDefaultMetaFormat() {\n-        return createDefaultMetaFormat(Locale.getDefault());\n-    }\n+    private static final String DUMMY_PATTERN = \"\";\n+    private static final String ESCAPED_QUOTE = \"''\";\n+    private static final char START_FMT = ',';\n+    private static final char END_FE = '}';\n+    private static final char START_FE = '{';\n+    private static final char QUOTE = '\\'';\n \n-    /**\n-     * Get a default meta-format for the specified Locale. This will produce\n-     * behavior identical to a <code>java.lang.MessageFormat</code> using\n-     * <code>locale</code>.\n-     * \n-     * @param locale the Locale for the resulting Format instance.\n-     * @return Format\n-     */\n-    public static Format createDefaultMetaFormat(Locale locale) {\n-        return DefaultMetaFormatFactory.getFormat(locale);\n-    }\n-\n-    /**\n-     * Conceptual demarcation of methods to parse the pattern.\n-     */\n-    private static class Parser {\n-        private static final String ESCAPED_QUOTE = \"''\";\n-        private static final char START_FMT = ',';\n-        private static final char END_FE = '}';\n-        private static final char START_FE = '{';\n-        private static final char QUOTE = '\\'';\n-\n-        /**\n-         * Strip all formats from the pattern.\n-         * \n-         * @param pattern String to strip\n-         * @return stripped pattern\n-         */\n-        private String stripFormats(String pattern) {\n-            StringBuffer sb = new StringBuffer(pattern.length());\n-            ParsePosition pos = new ParsePosition(0);\n-            char[] c = pattern.toCharArray();\n-            while (pos.getIndex() < pattern.length()) {\n-                switch (c[pos.getIndex()]) {\n-                case QUOTE:\n-                    appendQuotedString(pattern, pos, sb, true);\n-                    break;\n-                case START_FE:\n-                    int start = pos.getIndex();\n-                    readArgumentIndex(pattern, next(pos));\n-                    sb.append(c, start, pos.getIndex() - start);\n-                    if (c[pos.getIndex()] == START_FMT) {\n-                        eatFormat(pattern, next(pos));\n-                    }\n-                    if (c[pos.getIndex()] != END_FE) {\n-                        throw new IllegalArgumentException(\n-                                \"Unreadable format element at position \"\n-                                        + start);\n-                    }\n-                    // fall through\n-                default:\n-                    sb.append(c[pos.getIndex()]);\n-                    next(pos);\n-                }\n-            }\n-            return sb.toString();\n-        }\n-\n-        /**\n-         * Insert formats back into the pattern for toPattern() support.\n-         * \n-         * @param pattern source\n-         * @param formats the Formats to insert\n-         * @param metaFormat Format to format the Formats\n-         * @return full pattern\n-         */\n-        private String insertFormats(String pattern, Format[] formats,\n-                Format metaFormat) {\n-            if (formats == null || formats.length == 0) {\n-                return pattern;\n-            }\n-            StringBuffer sb = new StringBuffer(pattern.length() * 2);\n-            ParsePosition pos = new ParsePosition(0);\n-            int fe = -1;\n-            while (pos.getIndex() < pattern.length()) {\n-                char c = pattern.charAt(pos.getIndex());\n-                switch (c) {\n-                case QUOTE:\n-                    appendQuotedString(pattern, pos, sb, false);\n-                    break;\n-                case START_FE:\n-                    fe++;\n-                    sb.append(START_FE).append(\n-                            readArgumentIndex(pattern, next(pos)));\n-                    if (formats[fe] != null) {\n-                        String formatName = metaFormat.format(formats[fe]);\n-                        if (StringUtils.isNotEmpty(formatName)) {\n-                            sb.append(START_FMT).append(formatName);\n-                        }\n-                    }\n-                    break;\n-                default:\n-                    sb.append(pattern.charAt(pos.getIndex()));\n-                    next(pos);\n-                }\n-            }\n-            return sb.toString();\n-        }\n-\n-        /**\n-         * Parse the formats from the given pattern.\n-         * \n-         * @param pattern String to parse\n-         * @param metaFormat Format to parse the Formats\n-         * @return array of parsed Formats\n-         */\n-        private Format[] parseFormats(String pattern, Format metaFormat) {\n-            ArrayList result = new ArrayList();\n-            ParsePosition pos = new ParsePosition(0);\n-            while (pos.getIndex() < pattern.length()) {\n-                switch (pattern.charAt(pos.getIndex())) {\n-                case QUOTE:\n-                    getQuotedString(pattern, next(pos), true);\n-                    break;\n-                case START_FE:\n-                    int start = pos.getIndex();\n-                    readArgumentIndex(pattern, next(pos));\n-                    if (pattern.charAt(pos.getIndex()) == START_FMT) {\n-                        seekNonWs(pattern, next(pos));\n-                    }\n-                    result.add(metaFormat.parseObject(pattern, pos));\n-                    seekNonWs(pattern, pos);\n-                    if (pattern.charAt(pos.getIndex()) != END_FE) {\n-                        throw new IllegalArgumentException(\n-                                \"Unreadable format element at position \"\n-                                        + start);\n-                    }\n-                    // fall through\n-                default:\n-                    next(pos);\n-                }\n-            }\n-            return (Format[]) result.toArray(new Format[result.size()]);\n-        }\n-\n-        /**\n-         * Consume whitespace from the current parse position.\n-         * \n-         * @param pattern String to read\n-         * @param pos current position\n-         */\n-        private void seekNonWs(String pattern, ParsePosition pos) {\n-            int len = 0;\n-            char[] buffer = pattern.toCharArray();\n-            do {\n-                len = StrMatcher.splitMatcher().isMatch(buffer, pos.getIndex());\n-                pos.setIndex(pos.getIndex() + len);\n-            } while (len > 0 && pos.getIndex() < pattern.length());\n-        }\n-\n-        /**\n-         * Convenience method to advance parse position by 1\n-         * \n-         * @param pos ParsePosition\n-         * @return <code>pos</code>\n-         */\n-        private ParsePosition next(ParsePosition pos) {\n-            pos.setIndex(pos.getIndex() + 1);\n-            return pos;\n-        }\n-\n-        /**\n-         * Read the argument index from the current format element\n-         * \n-         * @param pattern pattern to parse\n-         * @param pos current parse position\n-         * @return argument index as string\n-         */\n-        private String readArgumentIndex(String pattern, ParsePosition pos) {\n-            int start = pos.getIndex();\n-            for (; pos.getIndex() < pattern.length(); next(pos)) {\n-                char c = pattern.charAt(pos.getIndex());\n-                if (c == START_FMT || c == END_FE) {\n-                    return pattern.substring(start, pos.getIndex());\n-                }\n-                if (!Character.isDigit(c)) {\n-                    throw new IllegalArgumentException(\n-                            \"Invalid format argument index at position \"\n-                                    + start);\n-                }\n-            }\n-            throw new IllegalArgumentException(\n-                    \"Unterminated format element at position \" + start);\n-        }\n-\n-        /**\n-         * Consume a quoted string, adding it to <code>appendTo</code> if\n-         * specified.\n-         * \n-         * @param pattern pattern to parse\n-         * @param pos current parse position\n-         * @param appendTo optional StringBuffer to append\n-         * @param escapingOn whether to process escaped quotes\n-         * @return <code>appendTo</code>\n-         */\n-        private StringBuffer appendQuotedString(String pattern,\n-                ParsePosition pos, StringBuffer appendTo, boolean escapingOn) {\n-            int start = pos.getIndex();\n-            char[] c = pattern.toCharArray();\n-            if (escapingOn && c[start] == QUOTE) {\n-                return appendTo == null ? null : appendTo.append(QUOTE);\n-            }\n-            int lastHold = start;\n-            for (int i = pos.getIndex(); i < pattern.length(); i++) {\n-                if (escapingOn\n-                        && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n-                    appendTo.append(c, lastHold, pos.getIndex() - lastHold)\n-                            .append(QUOTE);\n-                    pos.setIndex(i + ESCAPED_QUOTE.length());\n-                    lastHold = pos.getIndex();\n-                    continue;\n-                }\n-                switch (c[pos.getIndex()]) {\n-                case QUOTE:\n-                    next(pos);\n-                    return appendTo == null ? null : appendTo.append(c,\n-                            lastHold, pos.getIndex() - lastHold);\n-                default:\n-                    next(pos);\n-                }\n-            }\n-            throw new IllegalArgumentException(\n-                    \"Unterminated quoted string at position \" + start);\n-        }\n-\n-        /**\n-         * Consume quoted string only\n-         * \n-         * @param pattern pattern to parse\n-         * @param pos current parse position\n-         * @param escapingOn whether to process escaped quotes\n-         */\n-        private void getQuotedString(String pattern, ParsePosition pos,\n-                boolean escapingOn) {\n-            appendQuotedString(pattern, pos, null, escapingOn);\n-        }\n-\n-        /**\n-         * Consume the entire format found at the current position.\n-         * \n-         * @param pattern string to parse\n-         * @param pos current parse position\n-         */\n-        private void eatFormat(String pattern, ParsePosition pos) {\n-            int start = pos.getIndex();\n-            int depth = 1;\n-            for (; pos.getIndex() < pattern.length(); next(pos)) {\n-                switch (pattern.charAt(pos.getIndex())) {\n-                case START_FE:\n-                    depth++;\n-                    break;\n-                case END_FE:\n-                    depth--;\n-                    if (depth == 0) {\n-                        return;\n-                    }\n-                    break;\n-                case QUOTE:\n-                    getQuotedString(pattern, pos, false);\n-                    break;\n-                }\n-            }\n-            throw new IllegalArgumentException(\n-                    \"Unterminated format element at position \" + start);\n-        }\n-    }\n-\n-    private static final Parser PARSER = new Parser();\n-\n-    private Format metaFormat;\n-    private String strippedPattern;\n+    private String toPattern;\n+    private Map registry;\n \n     /**\n      * Create a new ExtendedMessageFormat for the default locale.\n      * \n      * @param pattern String\n-     * @param metaFormat Format\n-     * @throws IllegalArgumentException if <code>metaFormat</code> is\n-     *             <code>null</code> or in case of a bad pattern.\n+     * @throws IllegalArgumentException in case of a bad pattern.\n      */\n-    public ExtendedMessageFormat(String pattern, Format metaFormat) {\n-        this(pattern, Locale.getDefault(), metaFormat);\n+    public ExtendedMessageFormat(String pattern) {\n+        this(pattern, Locale.getDefault());\n     }\n \n     /**\n@@ -347,89 +66,376 @@\n      * \n      * @param pattern String\n      * @param locale Locale\n-     * @param metaFormat Format\n-     * @throws IllegalArgumentException if <code>metaFormat</code> is\n-     *             <code>null</code> or in case of a bad pattern.\n+     * @throws IllegalArgumentException in case of a bad pattern.\n      */\n-    public ExtendedMessageFormat(String pattern, Locale locale,\n-            Format metaFormat) {\n-        /*\n-         * We have to do some acrobatics here: the call to the super constructor\n-         * will invoke applyPattern(), but we don't want to apply the pattern\n-         * until we've installed our custom metaformat. So we check for that in\n-         * our (final) applyPattern implementation, and re-call at the end of\n-         * this constructor.\n-         */\n-        super(pattern);\n-        setLocale(locale);\n-        setMetaFormat(metaFormat);\n+    public ExtendedMessageFormat(String pattern, Locale locale) {\n+        this(pattern, locale, null);\n+    }\n+\n+    /**\n+     * Create a new ExtendedMessageFormat for the default locale.\n+     * \n+     * @param pattern String\n+     * @param registry Registry of format factories:  Map<String, FormatFactory>\n+     * @throws IllegalArgumentException in case of a bad pattern.\n+     */\n+    public ExtendedMessageFormat(String pattern, Map registry) {\n+        this(pattern, Locale.getDefault(), registry);\n+    }\n+\n+    /**\n+     * Create a new ExtendedMessageFormat.\n+     * \n+     * @param pattern String\n+     * @param locale Locale\n+     * @param registry Registry of format factories:  Map<String, FormatFactory>\n+     * @throws IllegalArgumentException in case of a bad pattern.\n+     */\n+    public ExtendedMessageFormat(String pattern, Locale locale, Map registry) {\n+        super(DUMMY_PATTERN, locale);\n+        this.registry = registry;\n         applyPattern(pattern);\n     }\n \n     /**\n+     * {@inheritDoc}\n+     */\n+    public String toPattern() {\n+        return toPattern;\n+    }\n+\n+    /**\n      * Apply the specified pattern.\n      * \n      * @param pattern String\n      */\n     public final void applyPattern(String pattern) {\n-        if (metaFormat == null) {\n+        if (registry == null) {\n+            super.applyPattern(pattern);\n+            toPattern = super.toPattern();\n             return;\n         }\n-        applyPatternPre(pattern);\n-        strippedPattern = PARSER.stripFormats(pattern);\n-        super.applyPattern(strippedPattern);\n-        setFormats(PARSER.parseFormats(pattern, metaFormat));\n-        applyPatternPost(pattern);\n+        ArrayList foundFormats = new ArrayList();\n+        ArrayList foundDescriptions = new ArrayList();\n+        StringBuffer stripCustom = new StringBuffer(pattern.length());\n+\n+        ParsePosition pos = new ParsePosition(0);\n+        char[] c = pattern.toCharArray();\n+        int fmtCount = 0;\n+        while (pos.getIndex() < pattern.length()) {\n+            switch (c[pos.getIndex()]) {\n+            case QUOTE:\n+                appendQuotedString(pattern, pos, stripCustom, true);\n+                break;\n+            case START_FE:\n+                fmtCount++;\n+                seekNonWs(pattern, pos);\n+                int start = pos.getIndex();\n+                int index = readArgumentIndex(pattern, next(pos));\n+                stripCustom.append(START_FE).append(index);\n+                seekNonWs(pattern, pos);\n+                Format format = null;\n+                String formatDescription = null;\n+                if (c[pos.getIndex()] == START_FMT) {\n+                    formatDescription = parseFormatDescription(pattern,\n+                            next(pos));\n+                    format = getFormat(formatDescription);\n+                    if (format == null) {\n+                        stripCustom.append(START_FMT).append(formatDescription);\n+                    }\n+                }\n+                foundFormats.add(format);\n+                foundDescriptions.add(format == null ? null : formatDescription);\n+                Validate.isTrue(foundFormats.size() == fmtCount);\n+                Validate.isTrue(foundDescriptions.size() == fmtCount);\n+                if (c[pos.getIndex()] != END_FE) {\n+                    throw new IllegalArgumentException(\n+                            \"Unreadable format element at position \" + start);\n+                }\n+                // fall through\n+            default:\n+                stripCustom.append(c[pos.getIndex()]);\n+                next(pos);\n+            }\n+        }\n+        super.applyPattern(stripCustom.toString());\n+        toPattern = insertFormats(super.toPattern(), foundDescriptions);\n+        if (containsElements(foundFormats)) {\n+            Format[] origFormats = getFormats();\n+            for (int i = 0; i < origFormats.length; i++) {\n+                Format f = (Format) foundFormats.get(i);\n+                if (f != null) {\n+                    origFormats[i] = f;\n+                }\n+            }\n+            super.setFormats(origFormats);\n+        }\n     }\n \n     /**\n-     * Pre-execution hook by means of which a subclass can customize the\n-     * behavior of the final applyPattern implementation.\n-     * \n-     * @param pattern String\n+     * {@inheritDoc}\n+     * UNSUPPORTED\n      */\n-    protected void applyPatternPre(String pattern) {\n-        // noop\n+    public void setFormat(int formatElementIndex, Format newFormat) {\n+        throw new UnsupportedOperationException();\n     }\n \n     /**\n-     * Post-execution hook by means of which a subclass can customize the\n-     * behavior of the final applyPattern implementation.\n-     * \n-     * @param pattern String\n+     * {@inheritDoc}\n+     * UNSUPPORTED\n      */\n-    protected void applyPatternPost(String pattern) {\n-        // noop\n+    public void setFormatByArgumentIndex(int argumentIndex, Format newFormat) {\n+        throw new UnsupportedOperationException();\n     }\n \n     /**\n-     * Render the pattern from the current state of the\n-     * <code>ExtendedMessageFormat</code>.\n-     * \n-     * @return pattern String\n+     * {@inheritDoc}\n+     * UNSUPPORTED\n      */\n-    public String toPattern() {\n-        return PARSER.insertFormats(strippedPattern, getFormats(), metaFormat);\n+    public void setFormats(Format[] newFormats) {\n+        throw new UnsupportedOperationException();\n     }\n \n     /**\n-     * Get the meta-format currently configured.\n-     * \n-     * @return Format.\n+     * {@inheritDoc}\n+     * UNSUPPORTED\n      */\n-    public synchronized Format getMetaFormat() {\n-        return metaFormat;\n+    public void setFormatsByArgumentIndex(Format[] newFormats) {\n+        throw new UnsupportedOperationException();\n     }\n \n     /**\n-     * Set the meta-format. Has no effect until a subsequent call to\n-     * {@link #applyPattern(String)}.\n+     * Get a custom format from a format description.\n      * \n-     * @param metaFormat the Format metaFormat to set.\n+     * @param desc String\n+     * @return Format\n      */\n-    public synchronized void setMetaFormat(Format metaFormat) {\n-        Validate.notNull(metaFormat, \"metaFormat is null\");\n-        this.metaFormat = metaFormat;\n+    private Format getFormat(String desc) {\n+        if (registry != null) {\n+            String name = desc;\n+            String args = null;\n+            int i = desc.indexOf(START_FMT);\n+            if (i > 0) {\n+                name = desc.substring(0, i).trim();\n+                args = desc.substring(i + 1).trim();\n+            }\n+            FormatFactory factory = (FormatFactory) registry.get(name);\n+            if (factory != null) {\n+                return factory.getFormat(name, args, getLocale());\n+            }\n+        }\n+        return null;\n     }\n \n+    /**\n+     * Read the argument index from the current format element\n+     * \n+     * @param pattern pattern to parse\n+     * @param pos current parse position\n+     * @return argument index\n+     */\n+    private int readArgumentIndex(String pattern, ParsePosition pos) {\n+        int start = pos.getIndex();\n+        seekNonWs(pattern, pos);\n+        StringBuffer result = new StringBuffer();\n+        boolean error = false;\n+        for (; !error && pos.getIndex() < pattern.length(); next(pos)) {\n+            char c = pattern.charAt(pos.getIndex());\n+            if (Character.isWhitespace(c)) {\n+                seekNonWs(pattern, pos);\n+                c = pattern.charAt(pos.getIndex());\n+                if (c != START_FMT && c != END_FE) {\n+                    error = true;\n+                    continue;\n+                }\n+            }\n+            if ((c == START_FMT || c == END_FE) && result.length() > 0) {\n+                try {\n+                    return Integer.parseInt(result.toString());\n+                } catch (NumberFormatException e) {\n+                    //we've already ensured only digits, so unless something outlandishly large was specified we should be okay.\n+                }\n+            }\n+            error = !Character.isDigit(c);\n+            result.append(c);\n+        }\n+        if (error) {\n+            throw new IllegalArgumentException(\n+                    \"Invalid format argument index at position \" + start + \": \"\n+                            + pattern.substring(start, pos.getIndex()));\n+        }\n+        throw new IllegalArgumentException(\n+                \"Unterminated format element at position \" + start);\n+    }\n+\n+    /**\n+     * Parse the format component of a format element.\n+     * \n+     * @param pattern string to parse\n+     * @param pos current parse position\n+     * @return Format description String\n+     */\n+    private String parseFormatDescription(String pattern, ParsePosition pos) {\n+        int start = pos.getIndex();\n+        seekNonWs(pattern, pos);\n+        int text = pos.getIndex();\n+        int depth = 1;\n+        for (; pos.getIndex() < pattern.length(); next(pos)) {\n+            switch (pattern.charAt(pos.getIndex())) {\n+            case START_FE:\n+                depth++;\n+                break;\n+            case END_FE:\n+                depth--;\n+                if (depth == 0) {\n+                    return pattern.substring(text, pos.getIndex());\n+                }\n+                break;\n+            case QUOTE:\n+                getQuotedString(pattern, pos, false);\n+                break;\n+            }\n+        }\n+        throw new IllegalArgumentException(\n+                \"Unterminated format element at position \" + start);\n+    }\n+\n+    /**\n+     * Insert formats back into the pattern for toPattern() support.\n+     *\n+     * @param pattern source\n+     * @param formats the Formats to insert\n+     * @param metaFormat Format to format the Formats\n+     * @return full pattern\n+     */\n+    private String insertFormats(String pattern, ArrayList customPatterns) {\n+        if (!containsElements(customPatterns)) {\n+            return pattern;\n+        }\n+        StringBuffer sb = new StringBuffer(pattern.length() * 2);\n+        ParsePosition pos = new ParsePosition(0);\n+        int fe = -1;\n+        int depth = 0;\n+        while (pos.getIndex() < pattern.length()) {\n+            char c = pattern.charAt(pos.getIndex());\n+            switch (c) {\n+            case QUOTE:\n+                appendQuotedString(pattern, pos, sb, false);\n+                break;\n+            case START_FE:\n+                depth++;\n+                if (depth == 1) {\n+                    fe++;\n+                    sb.append(START_FE).append(\n+                            readArgumentIndex(pattern, next(pos)));\n+                    String customPattern = (String) customPatterns.get(fe);\n+                    if (customPattern != null) {\n+                        sb.append(START_FMT).append(customPattern);\n+                    }\n+                }\n+                break;\n+            case END_FE:\n+                depth--;\n+                //fall through:\n+            default:\n+                sb.append(c);\n+                next(pos);\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Consume whitespace from the current parse position.\n+     * \n+     * @param pattern String to read\n+     * @param pos current position\n+     */\n+    private void seekNonWs(String pattern, ParsePosition pos) {\n+        int len = 0;\n+        char[] buffer = pattern.toCharArray();\n+        do {\n+            len = StrMatcher.splitMatcher().isMatch(buffer, pos.getIndex());\n+            pos.setIndex(pos.getIndex() + len);\n+        } while (len > 0 && pos.getIndex() < pattern.length());\n+    }\n+\n+    /**\n+     * Convenience method to advance parse position by 1\n+     * \n+     * @param pos ParsePosition\n+     * @return <code>pos</code>\n+     */\n+    private ParsePosition next(ParsePosition pos) {\n+        pos.setIndex(pos.getIndex() + 1);\n+        return pos;\n+    }\n+\n+    /**\n+     * Consume a quoted string, adding it to <code>appendTo</code> if\n+     * specified.\n+     * \n+     * @param pattern pattern to parse\n+     * @param pos current parse position\n+     * @param appendTo optional StringBuffer to append\n+     * @param escapingOn whether to process escaped quotes\n+     * @return <code>appendTo</code>\n+     */\n+    private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n+            StringBuffer appendTo, boolean escapingOn) {\n+        int start = pos.getIndex();\n+        char[] c = pattern.toCharArray();\n+        if (escapingOn && c[start] == QUOTE) {\n+            return appendTo == null ? null : appendTo.append(QUOTE);\n+        }\n+        int lastHold = start;\n+        for (int i = pos.getIndex(); i < pattern.length(); i++) {\n+            if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n+                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n+                        QUOTE);\n+                pos.setIndex(i + ESCAPED_QUOTE.length());\n+                lastHold = pos.getIndex();\n+                continue;\n+            }\n+            switch (c[pos.getIndex()]) {\n+            case QUOTE:\n+                next(pos);\n+                return appendTo == null ? null : appendTo.append(c, lastHold,\n+                        pos.getIndex() - lastHold);\n+            default:\n+                next(pos);\n+            }\n+        }\n+        throw new IllegalArgumentException(\n+                \"Unterminated quoted string at position \" + start);\n+    }\n+\n+    /**\n+     * Consume quoted string only\n+     * \n+     * @param pattern pattern to parse\n+     * @param pos current parse position\n+     * @param escapingOn whether to process escaped quotes\n+     */\n+    private void getQuotedString(String pattern, ParsePosition pos,\n+            boolean escapingOn) {\n+        appendQuotedString(pattern, pos, null, escapingOn);\n+    }\n+\n+    /**\n+     * Learn whether the specified Collection contains non-null elements.\n+     * @param coll to check\n+     * @return <code>true</code> if some Object was found, <code>false</code> otherwise.\n+     */\n+    private boolean containsElements(Collection coll) {\n+        if (coll == null || coll.size() == 0) {\n+            return false;\n+        }\n+        for (Iterator iter = coll.iterator(); iter.hasNext();) {\n+            if (iter.next() != null) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n }\n\n"
    },
    "Lang-44": {
        "Buggy Function": "    public static Number createNumber(String val) throws NumberFormatException {\n        if (val == null) {\n            return null;\n        }\n        if (val.length() == 0) {\n            throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n        }\n        if (val.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n            return createInteger(val);\n        }   \n        char lastChar = val.charAt(val.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = val.indexOf('.');\n        int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                }\n                dec = val.substring(decPos + 1, expPos);\n            } else {\n                dec = val.substring(decPos + 1);\n            }\n            mant = val.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = val.substring(0, expPos);\n            } else {\n                mant = val;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos > -1 && expPos < val.length() - 1) {\n                exp = val.substring(expPos + 1, val.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = val.substring(0, val.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // empty catch\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // empty catch\n                    }\n                    //Fall through\n                default :\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < val.length() - 1) {\n                exp = val.substring(expPos + 1, val.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(val);\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    return createLong(val);\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                return createBigInteger(val);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(val);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    Double d = createDouble(val);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n\n                return createBigDecimal(val);\n\n            }\n\n        }\n    }",
        "Inducing Changes": "Add Whole Class File of buggy method"
    },
    "Lang-45": {
        "Buggy Function": "    public static String abbreviate(String str, int lower, int upper, String appendToEnd) {\n        // initial parameter checks\n        if (str == null) {\n            return null;\n        }\n        if (str.length() == 0) {\n            return StringUtils.EMPTY;\n        }\n\n        // if the lower value is greater than the length of the string,\n        // set to the length of the string\n        // if the upper value is -1 (i.e. no limit) or is greater\n        // than the length of the string, set to the length of the string\n        if (upper == -1 || upper > str.length()) {\n            upper = str.length();\n        }\n        // if upper is less than lower, raise it to lower\n        if (upper < lower) {\n            upper = lower;\n        }\n\n        StringBuffer result = new StringBuffer();\n        int index = StringUtils.indexOf(str, \" \", lower);\n        if (index == -1) {\n            result.append(str.substring(0, upper));\n            // only if abbreviation has occured do we append the appendToEnd value\n            if (upper != str.length()) {\n                result.append(StringUtils.defaultString(appendToEnd));\n            }\n        } else if (index > upper) {\n            result.append(str.substring(0, upper));\n            result.append(StringUtils.defaultString(appendToEnd));\n        } else {\n            result.append(str.substring(0, index));\n            result.append(StringUtils.defaultString(appendToEnd));\n        }\n        return result.toString();\n    }",
        "Inducing Changes": "diff --git a/src/java/org/apache/commons/lang/WordUtils.java b/src/java/org/apache/commons/lang/WordUtils.java\nindex 1f133af..865d7a3 100644\n--- a/src/java/org/apache/commons/lang/WordUtils.java\n+++ b/src/java/org/apache/commons/lang/WordUtils.java\n@@ -581,4 +581,59 @@\n         return false;\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Abbreviates a string nicely.\n+     * \n+     * This method searches for the first space after the lower limit and abbreviates\n+     * the String there. It will also append any String passed as a parameter\n+     * to the end of the String. The upper limit can be specified to forcibly\n+     * abbreviate a String.\n+     * \n+     * @param str         the string to be abbreviated. If null is passed, null is returned.\n+     *                    If the empty String is passed, the empty string is returned.\n+     * @param lower       the lower limit.\n+     * @param upper       the upper limit; specify -1 if no limit is desired.\n+     *                    If the upper limit is lower than the lower limit, it will be\n+     *                    adjusted to be the same as the lower limit.\n+     * @param appendToEnd String to be appended to the end of the abbreviated string.\n+     *                    This is appended ONLY if the string was indeed abbreviated.\n+     *                    The append does not count towards the lower or upper limits.\n+     * @return the abbreviated String.\n+     */\n+    public static String abbreviate(String str, int lower, int upper, String appendToEnd) {\n+        // initial parameter checks\n+        if (str == null) {\n+            return null;\n+        }\n+        if (str.length() == 0) {\n+            return StringUtils.EMPTY;\n+        }\n+\n+        // if the upper value is -1 (i.e. no limit) or is greater\n+        // than the length of the string, set to the length of the string\n+        if (upper == -1 || upper > str.length()) {\n+            upper = str.length();\n+        }\n+        // if upper is less than lower, raise it to lower\n+        if (upper < lower) {\n+            upper = lower;\n+        }\n+\n+        StringBuffer result = new StringBuffer();\n+        int index = StringUtils.indexOf(str, \" \", lower);\n+        if (index == -1) {\n+            result.append(str.substring(0, upper));\n+            // only if abbreviation has occured do we append the appendToEnd value\n+            if (upper != str.length()) result.append(StringUtils.defaultString(appendToEnd));\n+        } else if (index > upper) {\n+            result.append(str.substring(0, upper));\n+            result.append(StringUtils.defaultString(appendToEnd));\n+        } else {\n+            result.append(str.substring(0, index));\n+            result.append(StringUtils.defaultString(appendToEnd));\n+        }\n+        return result.toString();\n+    }\n+\n }\n\n"
    },
    "Lang-47": {
        "Buggy Function": "public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(strLen - width, strLen, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}\npublic StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
        "Inducing Changes": "Add Whole Class File of buggy method"
    },
    "Lang-48": {
        "Buggy Function": "    public EqualsBuilder append(Object lhs, Object rhs) {\n        if (isEquals == false) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null || rhs == null) {\n            this.setEquals(false);\n            return this;\n        }\n        Class lhsClass = lhs.getClass();\n        if (!lhsClass.isArray()) {\n                // The simple case, not an array, just test the element\n                isEquals = lhs.equals(rhs);\n        } else if (lhs.getClass() != rhs.getClass()) {\n            // Here when we compare different dimensions, for example: a boolean[][] to a boolean[] \n            this.setEquals(false);\n        }\n        // 'Switch' on type of array, to dispatch to the correct handler\n        // This handles multi dimensional arrays of the same depth\n        else if (lhs instanceof long[]) {\n            append((long[]) lhs, (long[]) rhs);\n        } else if (lhs instanceof int[]) {\n            append((int[]) lhs, (int[]) rhs);\n        } else if (lhs instanceof short[]) {\n            append((short[]) lhs, (short[]) rhs);\n        } else if (lhs instanceof char[]) {\n            append((char[]) lhs, (char[]) rhs);\n        } else if (lhs instanceof byte[]) {\n            append((byte[]) lhs, (byte[]) rhs);\n        } else if (lhs instanceof double[]) {\n            append((double[]) lhs, (double[]) rhs);\n        } else if (lhs instanceof float[]) {\n            append((float[]) lhs, (float[]) rhs);\n        } else if (lhs instanceof boolean[]) {\n            append((boolean[]) lhs, (boolean[]) rhs);\n        } else {\n            // Not an array of primitives\n            append((Object[]) lhs, (Object[]) rhs);\n        }\n        return this;\n    }",
        "Inducing Changes": "Add Whole Class File of buggy method"
    },
    "Lang-49": {
        "Buggy Function": "    public Fraction reduce() {\n        int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n        if (gcd == 1) {\n            return this;\n        }\n        return Fraction.getFraction(numerator / gcd, denominator / gcd);\n    }",
        "Inducing Changes": "Add Whole Class File of buggy method"
    },
    "Lang-52": {
        "Buggy Function": "    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {\n        if (out == null) {\n            throw new IllegalArgumentException(\"The Writer must not be null\");\n        }\n        if (str == null) {\n            return;\n        }\n        int sz;\n        sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            char ch = str.charAt(i);\n\n            // handle unicode\n            if (ch > 0xfff) {\n                out.write(\"\\\\u\" + hex(ch));\n            } else if (ch > 0xff) {\n                out.write(\"\\\\u0\" + hex(ch));\n            } else if (ch > 0x7f) {\n                out.write(\"\\\\u00\" + hex(ch));\n            } else if (ch < 32) {\n                switch (ch) {\n                    case '\\b':\n                        out.write('\\\\');\n                        out.write('b');\n                        break;\n                    case '\\n':\n                        out.write('\\\\');\n                        out.write('n');\n                        break;\n                    case '\\t':\n                        out.write('\\\\');\n                        out.write('t');\n                        break;\n                    case '\\f':\n                        out.write('\\\\');\n                        out.write('f');\n                        break;\n                    case '\\r':\n                        out.write('\\\\');\n                        out.write('r');\n                        break;\n                    default :\n                        if (ch > 0xf) {\n                            out.write(\"\\\\u00\" + hex(ch));\n                        } else {\n                            out.write(\"\\\\u000\" + hex(ch));\n                        }\n                        break;\n                }\n            } else {\n                switch (ch) {\n                    case '\\'':\n                        if (escapeSingleQuote) {\n                          out.write('\\\\');\n                        }\n                        out.write('\\'');\n                        break;\n                    case '\"':\n                        out.write('\\\\');\n                        out.write('\"');\n                        break;\n                    case '\\\\':\n                        out.write('\\\\');\n                        out.write('\\\\');\n                        break;\n                    default :\n                        out.write(ch);\n                        break;\n                }\n            }\n        }\n    }",
        "Inducing Changes": "Add Whole Class File of buggy method"
    },
    "Lang-54": {
        "Buggy Function": "    public static Locale toLocale(String str) {\n        if (str == null) {\n            return null;\n        }\n        int len = str.length();\n        if (len != 2 && len != 5 && len < 7) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        char ch0 = str.charAt(0);\n        char ch1 = str.charAt(1);\n        if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len == 2) {\n            return new Locale(str, \"\");\n        } else {\n            if (str.charAt(2) != '_') {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            char ch3 = str.charAt(3);\n            char ch4 = str.charAt(4);\n            if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            if (len == 5) {\n                return new Locale(str.substring(0, 2), str.substring(3, 5));\n            } else {\n                if (str.charAt(5) != '_') {\n                    throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n                }\n                return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n            }\n        }\n    }",
        "Inducing Changes": "Add Whole Class File of buggy method"
    },
    "Lang-55": {
        "Buggy Function": "    public void stop() {\n        if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch is not running. \");\n        }\n            stopTime = System.currentTimeMillis();\n        this.runningState = STATE_STOPPED;\n    }",
        "Inducing Changes": "Add Whole Class File of buggy method"
    },
    "Lang-57": {
        "Buggy Function": "    public static boolean isAvailableLocale(Locale locale) {\n        return cAvailableLocaleSet.contains(locale);\n    }",
        "Inducing Changes": "diff --git a/src/java/org/apache/commons/lang/LocaleUtils.java b/src/java/org/apache/commons/lang/LocaleUtils.java\nindex f702446..4375948 100644\n--- a/src/java/org/apache/commons/lang/LocaleUtils.java\n+++ b/src/java/org/apache/commons/lang/LocaleUtils.java\n@@ -16,9 +16,13 @@\n package org.apache.commons.lang;\n \n import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Locale;\n+import java.util.Map;\n import java.util.Set;\n \n /**\n@@ -34,6 +38,19 @@\n  */\n public class LocaleUtils {\n \n+    /** Unmodifiable list of available locales. */\n+    private static final List cAvailableLocaleList;\n+    /** Unmodifiable set of available locales. */\n+    private static Set cAvailableLocaleSet;\n+    /** Unmodifiable map of language locales by country. */\n+    private static final Map cLanguagesByCountry = Collections.synchronizedMap(new HashMap());\n+    /** Unmodifiable map of country locales by language. */\n+    private static final Map cCountriesByLanguage = Collections.synchronizedMap(new HashMap());\n+    static {\n+        List list = Arrays.asList(Locale.getAvailableLocales());\n+        cAvailableLocaleList = Collections.unmodifiableList(list);\n+    }\n+\n     /**\n      * <p><code>LocaleUtils</code> instances should NOT be constructed in standard programming.\n      * Instead, the class should be used as <code>LocaleUtils.toLocale(\"en_GB\");</code>.</p>\n@@ -57,34 +74,48 @@\n      *   LocaleUtils.toLocale(\"en_GB\")  = new Locale(\"en\", \"GB\")\n      *   LocaleUtils.toLocale(\"en_GB_xxx\")  = new Locale(\"en\", \"GB\", \"xxx\")\n      * </pre>\n+     * \n+     * <p>This method validates the input strictly.\n+     * The language code must be lowercase.\n+     * The country code must be uppercase.\n+     * The separator must be an underscore.\n+     * The length must be correct.\n+     * </p>\n      *\n      * @param str  the locale String to convert, null returns null\n-     * @return a Locale\n+     * @return a Locale, null if null input\n      * @throws IllegalArgumentException if the string is an invalid format\n      */\n     public static Locale toLocale(String str) {\n         if (str == null) {\n             return null;\n         }\n-        if (str.length() != 2 &&\n-            str.length() != 5 &&\n-            str.length() < 7) {\n+        int len = str.length();\n+        if (len != 2 && len != 5 && len < 7) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n-        if (Character.isLowerCase(str.charAt(0)) == false ||\n-            Character.isLowerCase(str.charAt(1)) == false) {\n+        char ch0 = str.charAt(0);\n+        char ch1 = str.charAt(1);\n+        if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n-        if (str.length() == 2) {\n+        if (len == 2) {\n             return new Locale(str, \"\");\n         } else {\n-            if (Character.isUpperCase(str.charAt(3)) == false ||\n-                Character.isUpperCase(str.charAt(4)) == false) {\n+            if (str.charAt(2) != '_') {\n                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n             }\n-            if (str.length() == 5) {\n+            char ch3 = str.charAt(3);\n+            char ch4 = str.charAt(4);\n+            if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {\n+                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+            }\n+            if (len == 5) {\n                 return new Locale(str.substring(0, 2), str.substring(3, 5));\n             } else {\n+                if (str.charAt(5) != '_') {\n+                    throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+                }\n                 return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n             }\n         }\n@@ -101,7 +132,7 @@\n      * </pre>\n      *\n      * @param locale  the locale to start from\n-     * @return the list of Locale objects, 0 being locale\n+     * @return the unmodifiable list of Locale objects, 0 being locale, never null\n      */\n     public static List localeLookupList(Locale locale) {\n         return localeLookupList(locale, locale);\n@@ -117,12 +148,13 @@\n      *   = [Locale(\"fr\",\"CA\",\"xxx\"), Locale(\"fr\",\"CA\"), Locale(\"fr\"), Locale(\"en\"]\n      * </pre>\n      *\n-     * <p>This method takes a country code and searches to find the\n-     * languages available for that country. Variant locales are removed.</p>\n+     * <p>The result list begins with the most specific locale, then the\n+     * next more general and so on, finishing with the default locale.\n+     * The list will never contain the same locale twice.</p>\n      *\n      * @param locale  the locale to start from, null returns empty list\n      * @param defaultLocale  the default locale to use if no other is found\n-     * @return the list of Locale objects, 0 being locale\n+     * @return the unmodifiable list of Locale objects, 0 being locale, never null\n      */\n     public static List localeLookupList(Locale locale, Locale defaultLocale) {\n         List list = new ArrayList(4);\n@@ -138,55 +170,116 @@\n                 list.add(defaultLocale);\n             }\n         }\n-        return list;\n+        return Collections.unmodifiableList(list);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n-     * <p>Obtains the set of languages supported for a given country.</p>\n-     \n-     * <p>This method takes a country code and searches to find the\n-     * languages available for that country. Variant locales are removed.</p>\n+     * <p>Obtains an unmodifiable list of installed locales.</p>\n+     * \n+     * <p>This method is a wrapper around {@link Locale#getAvailableLocales()}.\n+     * It is more efficient, as the JDK method must create a new array each\n+     * time it is called.</p>\n      *\n-     * @param countryCode  the 2 letter country code, null returns empty\n-     * @return a Set of Locale objects\n+     * @return the unmodifiable list of available locales\n      */\n-    public static Set languagesByCountry(String countryCode) {\n-        Set set = new HashSet();\n-        Locale[] array = Locale.getAvailableLocales();\n-        if (countryCode != null) {\n-            for (int i = 0; i < array.length; i++) {\n-                if (countryCode.equals(array[i].getCountry()) &&\n-                        array[i].getVariant().length() == 0) {\n-                    set.add(array[i]);\n-                }\n-            }\n+    public static List availableLocaleList() {\n+        return cAvailableLocaleList;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Obtains an unmodifiable set of installed locales.</p>\n+     * \n+     * <p>This method is a wrapper around {@link Locale#getAvailableLocales()}.\n+     * It is more efficient, as the JDK method must create a new array each\n+     * time it is called.</p>\n+     *\n+     * @return the unmodifiable set of available locales\n+     */\n+    public static Set availableLocaleSet() {\n+        Set set = cAvailableLocaleSet;\n+        if (set == null) {\n+            set = new HashSet(availableLocaleList());\n+            set = Collections.unmodifiableSet(set);\n+            cAvailableLocaleSet = set;\n         }\n         return set;\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n-     * <p>Obtains the set of countries supported for a given language.</p>\n+     * <p>Checks if the locale specified is in the list of available locales.</p>\n+     *\n+     * @return true if the locale is a known locale\n+     */\n+    public static boolean isAvailableLocale(Locale locale) {\n+        return cAvailableLocaleSet.contains(locale);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Obtains the list of languages supported for a given country.</p>\n+     *\n+     * <p>This method takes a country code and searches to find the\n+     * languages available for that country. Variant locales are removed.</p>\n+     *\n+     * @param countryCode  the 2 letter country code, null returns empty\n+     * @return an unmodifiable List of Locale objects, never null\n+     */\n+    public static List languagesByCountry(String countryCode) {\n+        List langs = (List) cLanguagesByCountry.get(countryCode);\n+        if (langs == null) {\n+            if (countryCode != null) {\n+                langs = new ArrayList();\n+                List locales = availableLocaleList();\n+                for (int i = 0; i < locales.size(); i++) {\n+                    Locale locale = (Locale) locales.get(i);\n+                    if (countryCode.equals(locale.getCountry()) &&\n+                            locale.getVariant().length() == 0) {\n+                        langs.add(locale);\n+                    }\n+                }\n+                langs = Collections.unmodifiableList(langs);\n+            } else {\n+                langs = Collections.EMPTY_LIST;\n+            }\n+            cLanguagesByCountry.put(countryCode, langs);\n+        }\n+        return langs;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Obtains the list of countries supported for a given language.</p>\n      * \n      * <p>This method takes a language code and searches to find the\n      * countries available for that language. Variant locales are removed.</p>\n      *\n      * @param languageCode  the 2 letter language code, null returns empty\n-     * @return a Set of Locale objects\n+     * @return an unmodifiable List of Locale objects, never null\n      */\n-    public static Set countriesByLanguage(String languageCode) {\n-        Set set = new HashSet();\n-        Locale[] array = Locale.getAvailableLocales();\n-        if (languageCode != null) {\n-            for (int i = 0; i < array.length; i++) {\n-                if (languageCode.equals(array[i].getLanguage()) &&\n-                        array[i].getVariant().length() == 0) {\n-                    set.add(array[i]);\n+    public static List countriesByLanguage(String languageCode) {\n+        List countries = (List) cCountriesByLanguage.get(languageCode);\n+        if (countries == null) {\n+            if (languageCode != null) {\n+                countries = new ArrayList();\n+                List locales = availableLocaleList();\n+                for (int i = 0; i < locales.size(); i++) {\n+                    Locale locale = (Locale) locales.get(i);\n+                    if (languageCode.equals(locale.getLanguage()) &&\n+                            locale.getCountry().length() != 0 &&\n+                            locale.getVariant().length() == 0) {\n+                        countries.add(locale);\n+                    }\n                 }\n+                countries = Collections.unmodifiableList(countries);\n+            } else {\n+                countries = Collections.EMPTY_LIST;\n             }\n+            cCountriesByLanguage.put(languageCode, countries);\n         }\n-        return set;\n+        return countries;\n     }\n \n }\n\n"
    },
    "Lang-60": {
        "Buggy Function": "public boolean contains(char ch) {\n    char[] thisBuf = buffer;\n    for (int i = 0; i < thisBuf.length; i++) {\n        if (thisBuf[i] == ch) {\n            return true;\n        }\n    }\n    return false;\n}\npublic int indexOf(char ch, int startIndex) {\n    startIndex = (startIndex < 0 ? 0 : startIndex);\n    if (startIndex >= size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    for (int i = startIndex; i < thisBuf.length; i++) {\n        if (thisBuf[i] == ch) {\n            return i;\n        }\n    }\n    return -1;\n}",
        "Inducing Changes": "Add Whole Class File of buggy method"
    },
    "Lang-61": {
        "Buggy Function": "    public int indexOf(String str, int startIndex) {\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n        if (str == null || startIndex >= size) {\n            return -1;\n        }\n        int strLen = str.length();\n        if (strLen == 1) {\n            return indexOf(str.charAt(0), startIndex);\n        }\n        if (strLen == 0) {\n            return startIndex;\n        }\n        if (strLen > size) {\n            return -1;\n        }\n        char[] thisBuf = buffer;\n        int len = thisBuf.length - strLen;\n        outer:\n        for (int i = startIndex; i < len; i++) {\n            for (int j = 0; j < strLen; j++) {\n                if (str.charAt(j) != thisBuf[i + j]) {\n                    continue outer;\n                }\n            }\n            return i;\n        }\n        return -1;\n    }",
        "Inducing Changes": "Add Whole Class File of buggy method"
    },
    "Lang-64": {
        "Buggy Function": "public int compareTo(Object other) {\n    return iValue - ((ValuedEnum) other).iValue;\n}",
        "Inducing Changes": "Add Whole Class File of buggy method"
    },
    "Math-101": {
        "Buggy Function": "    public Complex parse(String source, ParsePosition pos) {\n        int initialIndex = pos.getIndex();\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse real\n        Number re = parseNumber(source, getRealFormat(), pos);\n        if (re == null) {\n            // invalid real number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // parse sign\n        int startIndex = pos.getIndex();\n        char c = parseNextCharacter(source, pos);\n        int sign = 0;\n        switch (c) {\n        case 0 :\n            // no sign\n            // return real only complex number\n            return new Complex(re.doubleValue(), 0.0);\n        case '-' :\n            sign = -1;\n            break;\n        case '+' :\n            sign = 1;\n            break;\n        default :\n            // invalid sign\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse imaginary\n        Number im = parseNumber(source, getRealFormat(), pos);\n        if (im == null) {\n            // invalid imaginary number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // parse imaginary character\n        int n = getImaginaryCharacter().length();\n        startIndex = pos.getIndex();\n        int endIndex = startIndex + n;\n        if (\n            source.substring(startIndex, endIndex).compareTo(\n            getImaginaryCharacter()) != 0) {\n            // set index back to initial, error index should be the start index\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n        pos.setIndex(endIndex);\n\n        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n    }",
        "Inducing Changes": "diff --git a/src/java/org/apache/commons/math/complex/ComplexFormat.java b/src/java/org/apache/commons/math/complex/ComplexFormat.java\nindex c36c542..d5c3484 100644\n--- a/src/java/org/apache/commons/math/complex/ComplexFormat.java\n+++ b/src/java/org/apache/commons/math/complex/ComplexFormat.java\n@@ -16,93 +16,101 @@\n \n package org.apache.commons.math.complex;\n \n+import java.text.FieldPosition;\n+import java.text.Format;\n import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n \n /**\n  * Formats a Complex number in cartesian format \"Re(c) + Im(c)i\".  'i' can\n- * be replaced with 'j', and the number of decimal places to display \n+ * be replaced with 'j', and the number format for both real and imaginary parts\n  * can be configured.\n  *\n  * @author Apache Software Foundation\n- * @version $Revision: 1.6 $ $Date: 2004/05/23 00:52:32 $\n+ * @version $Revision: 1.7 $ $Date: 2004/06/01 13:47:17 $\n  */\n-public class ComplexFormat {\n-\n+public class ComplexFormat extends Format {\n+    \n     /** The default complex format. */ \n \tprivate static final ComplexFormat DEFAULT = new ComplexFormat();\n \n-\t/** The notation used to signify the imaginary part of the complex number. */\n-    private String imaginaryCharacter = \"i\";\n+    /** The default imaginary character. */\n+    private static final String DEFAULT_IMAGINARY_CHARACTER = \"i\";\n+    \n+    /** The notation used to signify the imaginary part of the complex number. */\n+    private String imaginaryCharacter;\n+    \n+    /** The format used for the imaginary part. */\n+    private NumberFormat imaginaryFormat;\n \n-    /** The maximum number of decimal digits in the formatted output. */ \n-    private int fractionDigits = 2;\n-\n+    /** The format used for the real part. */\n+    private NumberFormat realFormat;\n+    \n     /**\n-     * Create an instance with the default imaginary character 'i', and the default\n-     * number of decimal places - 2.\n+     * Create an instance with the default imaginary character, 'i', and the\n+     * default number format for both real and imaginary parts.\n      */\n-    public ComplexFormat() {}\n+    public ComplexFormat() {\n+        this(DEFAULT_IMAGINARY_CHARACTER, getDefaultNumberFormat());\n+    }\n \n     /**\n-     * Create an instance with a custom imaginary character, and the default number\n-     * of decimal places - 2.\n+     * Create an instance with a custom number format for both real and\n+     * imaginary parts.\n+     * @param format the custom format for both real and imaginary parts.\n+     */\n+    public ComplexFormat(NumberFormat format) {\n+        this(DEFAULT_IMAGINARY_CHARACTER, format);\n+    }\n+    \n+    /**\n+     * Create an instance with a custom number format for the real part and a\n+     * custom number format for the imaginary part.\n+     * @param realFormat the custom format for the real part.\n+     * @param imaginaryFormat the custom format for the imaginary part.\n+     */\n+    public ComplexFormat(NumberFormat realFormat,\n+            NumberFormat imaginaryFormat) {\n+        this(DEFAULT_IMAGINARY_CHARACTER, realFormat, imaginaryFormat);\n+    }\n+    \n+    /**\n+     * Create an instance with a custom imaginary character, and the default\n+     * number format for both real and imaginary parts.\n      * @param imaginaryCharacter The custom imaginary character.\n      */\n     public ComplexFormat(String imaginaryCharacter) {\n-        this.imaginaryCharacter = imaginaryCharacter;\n-    }\n-\n-    /**\n-     * Create an instance with a custom imaginary character, and a custom number of\n-     * decimal places.\n-     * @param imaginaryCharacter The custom imaginary character.\n-     * @param fractionDigits The custom number of decimal places.\n-     */\n-    public ComplexFormat(String imaginaryCharacter, int fractionDigits) {\n-        this.imaginaryCharacter = imaginaryCharacter;\n-        this.fractionDigits = fractionDigits;\n-    }\n-\n-    /**\n-     * Formats a Complex object and returns a String representing the \"cartesian\n-     * form\" of a complex number.\n-     *\n-     * @param c Complex object to format\n-     * @return A formatted number in the form \"Re(c) + Im(c)i\"\n-     */\n-    public String format(Complex c) {\n-\n-        NumberFormat format = NumberFormat.getInstance();\n-        format.setMaximumFractionDigits( fractionDigits );\n-\n-        StringBuffer buffer = new StringBuffer();\n-\n-\t\tif( Double.isNaN( c.getReal() ) || Double.isInfinite( c.getReal() ) ) {\n-\t\t\tbuffer.append( \"(\" + c.getReal() + \")\" );\n-\t\t} else {\n-\t\t\tbuffer.append( format.format( c.getReal() ) );\n-\t\t}\n-\n-        if( c.getImaginary() < 0 ) {\n-            buffer.append( \" - \" );\n-        } else if( c.getImaginary() > 0 || Double.isNaN( c.getImaginary() )) {\n-            buffer.append( \" + \" );\n-        }            \n-\n-\t\tif( c.getImaginary() != 0 ) {\n-\t\t\tif( Double.isNaN( c.getImaginary() ) || Double.isInfinite( c.getImaginary() ) ) {\n-\t\t\t\tbuffer.append( \"(\" + Math.abs( c.getImaginary() ) + \")\" );\n-\t\t\t} else {\n-\t\t\t\tbuffer.append( format.format( Math.abs(c.getImaginary()) ) );\n-\t\t\t}\n-\t\t\tbuffer.append( imaginaryCharacter );\n-\t\t}\n-        \n-        return( buffer.toString() );\n-\n+        this(imaginaryCharacter, getDefaultNumberFormat());\n     }\n     \n     /**\n+     * Create an instance with a custom imaginary character, and a custom number\n+     * format for both real and imaginary parts.\n+     * @param imaginaryCharacter The custom imaginary character.\n+     * @param format the custom format for both real and imaginary parts.\n+     */\n+    public ComplexFormat(String imaginaryCharacter, NumberFormat format) {\n+        this(imaginaryCharacter, format, (NumberFormat)format.clone());\n+    }\n+    \n+    /**\n+     * Create an instance with a custom imaginary character, a custom number\n+     * format for the real part, and a custom number format for the imaginary\n+     * part.\n+     * @param imaginaryCharacter The custom imaginary character.\n+     * @param realFormat the custom format for the real part.\n+     * @param imaginaryFormat the custom format for the imaginary part.\n+     */\n+    public ComplexFormat(String imaginaryCharacter, NumberFormat realFormat,\n+            NumberFormat imaginaryFormat) {\n+        super();\n+        setImaginaryCharacter(imaginaryCharacter);\n+        setImaginaryFormat(imaginaryFormat);\n+        setRealFormat(realFormat);\n+    }\n+\n+    /**\n      * This static method calls formatComplex() on a default instance of\n      * ComplexFormat.\n      *\n@@ -112,7 +120,382 @@\n     public static String formatComplex( Complex c ) {\n     \treturn DEFAULT.format( c );\n     }\n-}\n-\n-\n     \n+    /**\n+     * Create a default number format.  The default number format is based on\n+     * {@link NumberFormat#getInstance()} with the only customizing is the\n+     * maximum number of fraction digits, which is set to 2.  \n+     *\n+     * @return the default number format.\n+     */\n+    private static NumberFormat getDefaultNumberFormat() {\n+        NumberFormat nf = NumberFormat.getInstance();\n+        nf.setMaximumFractionDigits(2);\n+        return nf;\n+    }\n+    \n+    /**\n+     * Formats a {@link Complex} object to produce a string.\n+     *\n+     * @param complex the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     */\n+    public StringBuffer format(Complex complex, StringBuffer toAppendTo,\n+            FieldPosition pos) {\n+        \n+        pos.setBeginIndex(0);\n+        pos.setEndIndex(0);\n+\n+        // format real\n+        double re = complex.getReal();\n+        formatDouble(re, getRealFormat(), toAppendTo, pos);\n+        \n+        // format sign and imaginary\n+        double im = complex.getImaginary();\n+        if (im < 0.0) {\n+            toAppendTo.append(\" - \");\n+            formatDouble(-im, getImaginaryFormat(), toAppendTo, pos);\n+            toAppendTo.append(getImaginaryCharacter());\n+        } else if (im > 0.0 || Double.isNaN(im)) {\n+            toAppendTo.append(\" + \");\n+            formatDouble(im, getImaginaryFormat(), toAppendTo, pos);\n+            toAppendTo.append(getImaginaryCharacter());\n+        }\n+        \n+        return toAppendTo;\n+    }\n+    \n+    /**\n+     * Formats a object to produce a string.  <code>obj</code> must be either a \n+     * {@link Complex} object or a {@link Number} object.  Any other type of\n+     * object will result in an {@link IllegalArgumentException} being thrown.\n+     *\n+     * @param obj the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)\n+     * @throws IllegalArgumentException is <code>obj</code> is not a valid type.\n+     */\n+    public StringBuffer format(Object obj, StringBuffer toAppendTo,\n+            FieldPosition pos) {\n+        \n+        StringBuffer ret = null;\n+        \n+        if (obj instanceof Complex) {\n+            ret = format( (Complex)obj, toAppendTo, pos);\n+        } else if (obj instanceof Number) {\n+            ret = format( new Complex(((Number)obj).doubleValue(), 0.0),\n+                toAppendTo, pos);\n+        } else { \n+            throw new IllegalArgumentException(\n+                \"Cannot format given Object as a Date\");\n+        }\n+        \n+        return ret;\n+    }\n+\n+    /**\n+     * Formats a double value to produce a string.  In general, the value is\n+     * formatted using the formatting rules of <code>format</code>.  There are\n+     * three exceptions to this:\n+     * <ol>\n+     * <li>NaN is formatted as '(NaN)'</li>\n+     * <li>Positive infinity is formatted as '(Infinity)'</li>\n+     * <li>Negative infinity is formatted as '(-Infinity)'</li>\n+     * </ol>\n+     *\n+     * @param value the double to format.\n+     * @param format the format used.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     */\n+    private StringBuffer formatDouble(double value, NumberFormat format,\n+            StringBuffer toAppendTo, FieldPosition pos) {\n+        if( Double.isNaN(value) || Double.isInfinite(value) ) {\n+            toAppendTo.append('(');\n+            toAppendTo.append(value);\n+            toAppendTo.append(')');\n+        } else {\n+            getRealFormat().format(value, toAppendTo, pos);\n+        }\n+        return toAppendTo;\n+    }\n+    \n+    /**\n+     * Access the imaginaryCharacter.\n+     * @return the imaginaryCharacter.\n+     */\n+    public String getImaginaryCharacter() {\n+        return imaginaryCharacter;\n+    }\n+    \n+    /**\n+     * Access the imaginaryFormat.\n+     * @return the imaginaryFormat.\n+     */\n+    public NumberFormat getImaginaryFormat() {\n+        return imaginaryFormat;\n+    }\n+    \n+    /**\n+     * Access the realFormat.\n+     * @return the realFormat.\n+     */\n+    public NumberFormat getRealFormat() {\n+        return realFormat;\n+    }\n+\n+    /**\n+     * Parses a string to produce a {@link Complex} object.\n+     *\n+     * @param source the string to parse\n+     * @return the parsed {@link Complex} object.\n+     * @exception ParseException if the beginning of the specified string\n+     *            cannot be parsed.\n+     */\n+    public Complex parse(String source) throws ParseException {\n+        ParsePosition parsePosition = new ParsePosition(0);\n+        Complex result = parse(source, parsePosition);\n+        if (parsePosition.getIndex() == 0) {\n+            throw new ParseException(\"Unparseable complex number: \\\"\" + source +\n+                \"\\\"\", parsePosition.getErrorIndex());\n+        }\n+        return result;\n+    }\n+    \n+    /**\n+     * Parses a string to produce a {@link Complex} object.\n+     *\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed {@link Complex} object.\n+     */\n+    public Complex parse(String source, ParsePosition pos) {\n+        int initialIndex = pos.getIndex();\n+\n+        // parse whitespace\n+        parseAndIgnoreWhitespace(source, pos);\n+\n+        // parse real\n+        Number re = parseNumber(source, getRealFormat(), pos);\n+        if (re == null) {\n+            // invalid real number\n+            // set index back to initial, error index should already be set\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse sign\n+        int startIndex = pos.getIndex();\n+        char c = parseNextCharacter(source, pos);\n+        int sign = 0;\n+        switch (c) {\n+        case 0 :\n+            // no sign\n+            // return real only complex number\n+            return new Complex(re.doubleValue(), 0.0);\n+        case '-' :\n+            sign = -1;\n+            break;\n+        case '+' :\n+            sign = 1;\n+            break;\n+        default :\n+            // invalid sign\n+            // set index back to initial, error index should be the last\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            pos.setErrorIndex(startIndex);\n+            return null;\n+        }\n+\n+        // parse whitespace\n+        parseAndIgnoreWhitespace(source, pos);\n+\n+        // parse imaginary\n+        Number im = parseNumber(source, getRealFormat(), pos);\n+        if (im == null) {\n+            // invalid imaginary number\n+            // set index back to initial, error index should already be set\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse imaginary character\n+        int n = getImaginaryCharacter().length();\n+        startIndex = pos.getIndex();\n+        int endIndex = startIndex + n;\n+        if (source.substring(startIndex, endIndex).compareTo(\n+            getImaginaryCharacter()) != 0) {\n+            // set index back to initial, error index should be the start index\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            pos.setErrorIndex(startIndex);\n+            return null;\n+        }\n+        pos.setIndex(endIndex);\n+\n+        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n+    }\n+     \n+    /**\n+     * Parses <code>source</code> until a non-whitespace character is found.\n+     *\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.  On output, <code>pos</code>\n+     *        holds the index of the next non-whitespace character.\n+     */\n+    private void parseAndIgnoreWhitespace(String source, ParsePosition pos) {\n+        parseNextCharacter(source, pos);\n+        pos.setIndex(pos.getIndex() - 1);\n+    }\n+\n+    /**\n+     * Parses <code>source</code> until a non-whitespace character is found.\n+     *\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the first non-whitespace character.\n+     */\n+    private char parseNextCharacter(String source, ParsePosition pos) {\n+         int index = pos.getIndex();\n+         int n = source.length();\n+         char ret = 0;\n+\n+         if (index < n) {\n+             char c;\n+             do {\n+                 c = source.charAt(index++);\n+             } while (Character.isWhitespace(c) && index < n);\n+             pos.setIndex(index);\n+         \n+             if (index < n) {\n+                 ret = c;\n+             }\n+         }\n+         \n+         return ret;\n+    }\n+    \n+    /**\n+     * Parses <code>source</code> for a special double values.  These values\n+     * include Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY.\n+     *\n+     * @param source the string to parse\n+     * @param value the special value to parse.\n+     * @param pos input/ouput parsing parameter.\n+     * @return the special number.\n+     */\n+    private Number parseNumber(String source, double value, ParsePosition pos) {\n+        Number ret = null;\n+        \n+        StringBuffer sb = new StringBuffer();\n+        sb.append('(');\n+        sb.append(value);\n+        sb.append(')');\n+        \n+        int n = sb.length();\n+        int startIndex = pos.getIndex();\n+        int endIndex = startIndex + n;\n+        if (endIndex < source.length()) {\n+            if (source.substring(startIndex, endIndex).compareTo(sb.toString()) == 0) {\n+                ret = new Double(value);\n+                pos.setIndex(endIndex);\n+            }\n+        }\n+        \n+        return ret;\n+    }\n+    \n+    /**\n+     * Parses <code>source</code> for a number.  This method can parse normal,\n+     * numeric values as well as special values.  These special values include\n+     * Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY.\n+     *\n+     * @param source the string to parse\n+     * @param format the number format used to parse normal, numeric values.\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed number.\n+     */\n+    private Number parseNumber(String source, NumberFormat format, ParsePosition pos) {\n+        int startIndex = pos.getIndex();\n+        Number number = getRealFormat().parse(source, pos);\n+        int endIndex = pos.getIndex();\n+        \n+        // check for error parsing number\n+        if (startIndex == endIndex) {\n+            // try parsing special numbers\n+            double[] special = {Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY};\n+            for (int i = 0; i < special.length; ++i) {\n+                number = parseNumber(source, special[i], pos);\n+                if (number != null) {\n+                    break;\n+                }\n+            }\n+        }\n+        \n+        return number;\n+    }\n+\n+    /**\n+     * Parses a string to produce a object.\n+     *\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed object.\n+     * @see java.text.Format#parseObject(java.lang.String, java.text.ParsePosition)\n+     */\n+    public Object parseObject(String source, ParsePosition pos) {\n+        return parse(source, pos);\n+    }\n+    /**\n+     * Modify the imaginaryCharacter.\n+     * @param imaginaryCharacter The new imaginaryCharacter value.\n+     * @throws IllegalArgumentException if <code>imaginaryCharacter</code> is\n+     *         <code>null</code> or an empty string.\n+     */\n+    public void setImaginaryCharacter(String imaginaryCharacter) {\n+        if (imaginaryCharacter == null || imaginaryCharacter.length() == 0) {\n+            throw new IllegalArgumentException(\n+                \"imaginaryCharacter must be a non-empty string.\");\n+        }\n+        this.imaginaryCharacter = imaginaryCharacter;\n+    }\n+    \n+    /**\n+     * Modify the imaginaryFormat.\n+     * @param imaginaryFormat The new imaginaryFormat value.\n+     * @throws IllegalArgumentException if <code>imaginaryFormat</code> is\n+     *         <code>null</code>.\n+     */\n+    public void setImaginaryFormat(NumberFormat imaginaryFormat) {\n+        if (imaginaryFormat == null) {\n+            throw new IllegalArgumentException(\n+                \"imaginaryFormat can not be null.\");\n+        }\n+        this.imaginaryFormat = imaginaryFormat;\n+    }\n+    \n+    /**\n+     * Modify the realFormat.\n+     * @param realFormat The new realFormat value.\n+     * @throws IllegalArgumentException if <code>realFormat</code> is\n+     *         <code>null</code>.\n+     */\n+    public void setRealFormat(NumberFormat realFormat) {\n+        if (realFormat == null) {\n+            throw new IllegalArgumentException(\n+                \"realFormat can not be null.\");\n+        }\n+        this.realFormat = realFormat;\n+    }\n+}\n\n"
    },
    "Math-103": {
        "Buggy Function": "    public double cumulativeProbability(double x) throws MathException {\n            return 0.5 * (1.0 + Erf.erf((x - mean) /\n                    (standardDeviation * Math.sqrt(2.0))));\n    }",
        "Inducing Changes": "Add Whole Class File of buggy method"
    },
    "Math-104": {
        "Buggy Function": "",
        "Inducing Changes": ""
    },
    "Math-105": {
        "Buggy Function": "    public double getSumSquaredErrors() {\n        return sumYY - sumXY * sumXY / sumXX;\n    }",
        "Inducing Changes": "--- /mnt/Benchmark/data/changesInfo/Math_105/properties/modified_classes/original/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java        2025-03-27 05:15:03.181500666 -0700\n+++ /mnt/Benchmark/data/changesInfo/Math_105/properties/modified_classes/inducing/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java        2025-03-27 05:15:03.181500666 -0700\n@@ -246,7 +246,7 @@\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return getSumSquaredErrors(getSlope());\n+        return sumYY - sumXY * sumXY / sumXX;\n     }\n \n     /**\n@@ -319,7 +319,7 @@\n      */\n     public double getR() {\n         double b1 = getSlope();\n-        double result = Math.sqrt(getRSquare(b1));\n+        double result = Math.sqrt(getRSquare());\n         if (b1 < 0) {\n             result = -result;\n         }\n@@ -341,7 +341,8 @@\n      * @return r-square\n      */\n     public double getRSquare() {\n-        return getRSquare(getSlope());\n+        double ssto = getTotalSumSquares();\n+        return (ssto - getSumSquaredErrors()) / ssto;\n     }\n \n     /**\n@@ -482,32 +483,6 @@\n     }\n \n     /**\n-     * Returns the sum of squared errors associated with the regression \n-     * model, using the slope of the regression line. \n-     * <p> \n-     * Returns NaN if the slope is NaN.\n-     * \n-     * @param b1 current slope\n-     * @return sum of squared errors associated with the regression model\n-     */\n-    private double getSumSquaredErrors(double b1) {\n-        return sumYY - sumXY * sumXY / sumXX;\n-    }\n-\n-    /** \n-     * Computes r-square from the slope.\n-     * <p>\n-     * will return NaN if slope is Nan.\n-     *\n-     * @param b1 current slope\n-     * @return r-square\n-     */\n-    private double getRSquare(double b1) {\n-        double ssto = getTotalSumSquares();\n-        return (ssto - getSumSquaredErrors(b1)) / ssto;\n-    }\n-\n-    /**\n      * Computes SSR from b1.\n      * \n      * @param slope regression slope estimate"
    },
    "Math-106": {
        "Buggy Function": "    public Fraction parse(String source, ParsePosition pos) {\n        // try to parse improper fraction\n        Fraction ret = super.parse(source, pos);\n        if (ret != null) {\n            return ret;\n        }\n        \n        int initialIndex = pos.getIndex();\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse whole\n        Number whole = getWholeFormat().parse(source, pos);\n        if (whole == null) {\n            // invalid integer number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n        \n        // parse numerator\n        Number num = getNumeratorFormat().parse(source, pos);\n        if (num == null) {\n            // invalid integer number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n        \n            // minus signs should be leading, invalid expression\n\n        // parse '/'\n        int startIndex = pos.getIndex();\n        char c = parseNextCharacter(source, pos);\n        switch (c) {\n        case 0 :\n            // no '/'\n            // return num as a fraction\n            return new Fraction(num.intValue(), 1);\n        case '/' :\n            // found '/', continue parsing denominator\n            break;\n        default :\n            // invalid '/'\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse denominator\n        Number den = getDenominatorFormat().parse(source, pos);\n        if (den == null) {\n            // invalid integer number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n        \n            // minus signs must be leading, invalid\n\n        int w = whole.intValue();\n        int n = num.intValue();\n        int d = den.intValue();\n        return new Fraction(((Math.abs(w) * d) + n) * MathUtils.sign(w), d);\n    }",
        "Inducing Changes": "Add Whole Class File of buggy method"
    },
    "Math-17": {
        "Buggy Function": "    public Dfp multiply(final int x) {\n            return multiplyFast(x);\n    }",
        "Inducing Changes": "Add Whole Class File of buggy method"
    },
    "Math-25": {
        "Buggy Function": "        private void guessAOmega() {\n            // initialize the sums for the linear model between the two integrals\n            double sx2 = 0;\n            double sy2 = 0;\n            double sxy = 0;\n            double sxz = 0;\n            double syz = 0;\n\n            double currentX = observations[0].getX();\n            double currentY = observations[0].getY();\n            double f2Integral = 0;\n            double fPrime2Integral = 0;\n            final double startX = currentX;\n            for (int i = 1; i < observations.length; ++i) {\n                // one step forward\n                final double previousX = currentX;\n                final double previousY = currentY;\n                currentX = observations[i].getX();\n                currentY = observations[i].getY();\n\n                // update the integrals of f<sup>2</sup> and f'<sup>2</sup>\n                // considering a linear model for f (and therefore constant f')\n                final double dx = currentX - previousX;\n                final double dy = currentY - previousY;\n                final double f2StepIntegral =\n                    dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;\n                final double fPrime2StepIntegral = dy * dy / dx;\n\n                final double x = currentX - startX;\n                f2Integral += f2StepIntegral;\n                fPrime2Integral += fPrime2StepIntegral;\n\n                sx2 += x * x;\n                sy2 += f2Integral * f2Integral;\n                sxy += x * f2Integral;\n                sxz += x * fPrime2Integral;\n                syz += f2Integral * fPrime2Integral;\n            }\n\n            // compute the amplitude and pulsation coefficients\n            double c1 = sy2 * sxz - sxy * syz;\n            double c2 = sxy * sxz - sx2 * syz;\n            double c3 = sx2 * sy2 - sxy * sxy;\n            if ((c1 / c2 < 0) || (c2 / c3 < 0)) {\n                final int last = observations.length - 1;\n                // Range of the observations, assuming that the\n                // observations are sorted.\n                final double xRange = observations[last].getX() - observations[0].getX();\n                if (xRange == 0) {\n                    throw new ZeroException();\n                }\n                omega = 2 * Math.PI / xRange;\n\n                double yMin = Double.POSITIVE_INFINITY;\n                double yMax = Double.NEGATIVE_INFINITY;\n                for (int i = 1; i < observations.length; ++i) {\n                    final double y = observations[i].getY();\n                    if (y < yMin) {\n                        yMin = y;\n                    }\n                    if (y > yMax) {\n                        yMax = y;\n                    }\n                }\n                a = 0.5 * (yMax - yMin);\n            } else {\n                    // In some ill-conditioned cases (cf. MATH-844), the guesser\n                    // procedure cannot produce sensible results.\n\n                a = FastMath.sqrt(c1 / c2);\n                omega = FastMath.sqrt(c2 / c3);\n            }\n        }",
        "Inducing Changes": "diff --git a/src/main/java/org/apache/commons/math/optimization/fitting/HarmonicFitter.java b/src/main/java/org/apache/commons/math/optimization/fitting/HarmonicFitter.java\nindex 02dd08e..41261ac 100644\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/HarmonicFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/HarmonicFitter.java\n@@ -17,113 +17,327 @@\n \n package org.apache.commons.math.optimization.fitting;\n \n+import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n+import org.apache.commons.math.analysis.function.HarmonicOscillator;\n+import org.apache.commons.math.exception.ZeroException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n-import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n-import org.apache.commons.math.optimization.OptimizationException;\n-import org.apache.commons.math.analysis.ParametricUnivariateRealFunction;\n import org.apache.commons.math.util.FastMath;\n \n-/** This class implements a curve fitting specialized for sinusoids.\n- * \u003cp\u003eHarmonic fitting is a very simple case of curve fitting. The\n+/**\n+ * Class that implements a curve fitting specialized for sinusoids.\n+ *\n+ * Harmonic fitting is a very simple case of curve fitting. The\n  * estimated coefficients are the amplitude a, the pulsation \u0026omega; and\n  * the phase \u0026phi;: \u003ccode\u003ef (t) \u003d a cos (\u0026omega; t + \u0026phi;)\u003c/code\u003e. They are\n  * searched by a least square estimator initialized with a rough guess\n- * based on integrals.\u003c/p\u003e\n+ * based on integrals.\n+ *\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n-public class HarmonicFitter {\n-\n-    /** Fitter for the coefficients. */\n-    private final CurveFitter fitter;\n-\n-    /** Values for amplitude, pulsation \u0026omega; and phase \u0026phi;. */\n-    private double[] parameters;\n-\n-    /** Simple constructor.\n-     * @param optimizer optimizer to use for the fitting\n+public class HarmonicFitter extends CurveFitter {\n+    /**\n+     * Simple constructor.\n+     * @param optimizer Optimizer to use for the fitting.\n      */\n     public HarmonicFitter(final DifferentiableMultivariateVectorialOptimizer optimizer) {\n-        this.fitter \u003d new CurveFitter(optimizer);\n-        parameters  \u003d null;\n-    }\n-\n-    /** Simple constructor.\n-     * \u003cp\u003eThis constructor can be used when a first guess of the\n-     * coefficients is already known.\u003c/p\u003e\n-     * @param optimizer optimizer to use for the fitting\n-     * @param initialGuess guessed values for amplitude (index 0),\n-     * pulsation \u0026omega; (index 1) and phase \u0026phi; (index 2)\n-     */\n-    public HarmonicFitter(final DifferentiableMultivariateVectorialOptimizer optimizer,\n-                          final double[] initialGuess) {\n-        this.fitter     \u003d new CurveFitter(optimizer);\n-        this.parameters \u003d initialGuess.clone();\n-    }\n-\n-    /** Add an observed weighted (x,y) point to the sample.\n-     * @param weight weight of the observed point in the fit\n-     * @param x abscissa of the point\n-     * @param y observed value of the point at x, after fitting we should\n-     * have P(x) as close as possible to this value\n-     */\n-    public void addObservedPoint(double weight, double x, double y) {\n-        fitter.addObservedPoint(weight, x, y);\n+        super(optimizer);\n     }\n \n     /**\n      * Fit an harmonic function to the observed points.\n      *\n-     * @return harmonic Function that best fits the observed points.\n-     * @throws NumberIsTooSmallException if the sample is too short or if\n-     * the first guess cannot be computed.\n-     * @throws OptimizationException\n+     * @param initialGuess First guess values in the following order:\n+     * \u003cul\u003e\n+     *  \u003cli\u003eAmplitude\u003c/li\u003e\n+     *  \u003cli\u003eAngular frequency\u003c/li\u003e\n+     *  \u003cli\u003ePhase\u003c/li\u003e\n+     * \u003c/ul\u003e\n+     * @return the parameters of the harmonic function that best fits the\n+     * observed points (in the same order as above).\n      */\n-    public HarmonicFunction fit() throws OptimizationException {\n-        // shall we compute the first guess of the parameters ourselves ?\n-        if (parameters \u003d\u003d null) {\n-            final WeightedObservedPoint[] observations \u003d fitter.getObservations();\n+    public double[] fit(double[] initialGuess) {\n+        return fit(new HarmonicOscillator.Parametric(), initialGuess);\n+    }\n+\n+    /**\n+     * Fit an harmonic function to the observed points.\n+     * An initial guess will be automatically computed.\n+     *\n+     * @return the parameters of the harmonic function that best fits the\n+     * observed points (see the other {@link #fit(double[]) fit} method.\n+     * @throws NumberIsTooSmallException if the sample is too short for the\n+     * the first guess to be computed.\n+     * @throws ZeroException if the first guess cannot be computed because\n+     * the abscissa range is zero.\n+     */\n+    public double[] fit() {\n+        return fit((new ParameterGuesser(getObservations())).guess());\n+    }\n+\n+    /**\n+     * This class guesses harmonic coefficients from a sample.\n+     * \u003cp\u003eThe algorithm used to guess the coefficients is as follows:\u003c/p\u003e\n+     *\n+     * \u003cp\u003eWe know f (t) at some sampling points t\u003csub\u003ei\u003c/sub\u003e and want to find a,\n+     * \u0026omega; and \u0026phi; such that f (t) \u003d a cos (\u0026omega; t + \u0026phi;).\n+     * \u003c/p\u003e\n+     *\n+     * \u003cp\u003eFrom the analytical expression, we can compute two primitives :\n+     * \u003cpre\u003e\n+     *     If2  (t) \u003d \u0026int; f\u003csup\u003e2\u003c/sup\u003e  \u003d a\u003csup\u003e2\u003c/sup\u003e \u0026times; [t + S (t)] / 2\n+     *     If\u00272 (t) \u003d \u0026int; f\u0027\u003csup\u003e2\u003c/sup\u003e \u003d a\u003csup\u003e2\u003c/sup\u003e \u0026omega;\u003csup\u003e2\u003c/sup\u003e \u0026times; [t - S (t)] / 2\n+     *     where S (t) \u003d sin (2 (\u0026omega; t + \u0026phi;)) / (2 \u0026omega;)\n+     * \u003c/pre\u003e\n+     * \u003c/p\u003e\n+     *\n+     * \u003cp\u003eWe can remove S between these expressions :\n+     * \u003cpre\u003e\n+     *     If\u00272 (t) \u003d a\u003csup\u003e2\u003c/sup\u003e \u0026omega;\u003csup\u003e2\u003c/sup\u003e t - \u0026omega;\u003csup\u003e2\u003c/sup\u003e If2 (t)\n+     * \u003c/pre\u003e\n+     * \u003c/p\u003e\n+     *\n+     * \u003cp\u003eThe preceding expression shows that If\u00272 (t) is a linear\n+     * combination of both t and If2 (t): If\u00272 (t) \u003d A \u0026times; t + B \u0026times; If2 (t)\n+     * \u003c/p\u003e\n+     *\n+     * \u003cp\u003eFrom the primitive, we can deduce the same form for definite\n+     * integrals between t\u003csub\u003e1\u003c/sub\u003e and t\u003csub\u003ei\u003c/sub\u003e for each t\u003csub\u003ei\u003c/sub\u003e :\n+     * \u003cpre\u003e\n+     *   If2 (t\u003csub\u003ei\u003c/sub\u003e) - If2 (t\u003csub\u003e1\u003c/sub\u003e) \u003d A \u0026times; (t\u003csub\u003ei\u003c/sub\u003e - t\u003csub\u003e1\u003c/sub\u003e) + B \u0026times; (If2 (t\u003csub\u003ei\u003c/sub\u003e) - If2 (t\u003csub\u003e1\u003c/sub\u003e))\n+     * \u003c/pre\u003e\n+     * \u003c/p\u003e\n+     *\n+     * \u003cp\u003eWe can find the coefficients A and B that best fit the sample\n+     * to this linear expression by computing the definite integrals for\n+     * each sample points.\n+     * \u003c/p\u003e\n+     *\n+     * \u003cp\u003eFor a bilinear expression z (x\u003csub\u003ei\u003c/sub\u003e, y\u003csub\u003ei\u003c/sub\u003e) \u003d A \u0026times; x\u003csub\u003ei\u003c/sub\u003e + B \u0026times; y\u003csub\u003ei\u003c/sub\u003e, the\n+     * coefficients A and B that minimize a least square criterion\n+     * \u0026sum; (z\u003csub\u003ei\u003c/sub\u003e - z (x\u003csub\u003ei\u003c/sub\u003e, y\u003csub\u003ei\u003c/sub\u003e))\u003csup\u003e2\u003c/sup\u003e are given by these expressions:\u003c/p\u003e\n+     * \u003cpre\u003e\n+     *\n+     *         \u0026sum;y\u003csub\u003ei\u003c/sub\u003ey\u003csub\u003ei\u003c/sub\u003e \u0026sum;x\u003csub\u003ei\u003c/sub\u003ez\u003csub\u003ei\u003c/sub\u003e - \u0026sum;x\u003csub\u003ei\u003c/sub\u003ey\u003csub\u003ei\u003c/sub\u003e \u0026sum;y\u003csub\u003ei\u003c/sub\u003ez\u003csub\u003ei\u003c/sub\u003e\n+     *     A \u003d ------------------------\n+     *         \u0026sum;x\u003csub\u003ei\u003c/sub\u003ex\u003csub\u003ei\u003c/sub\u003e \u0026sum;y\u003csub\u003ei\u003c/sub\u003ey\u003csub\u003ei\u003c/sub\u003e - \u0026sum;x\u003csub\u003ei\u003c/sub\u003ey\u003csub\u003ei\u003c/sub\u003e \u0026sum;x\u003csub\u003ei\u003c/sub\u003ey\u003csub\u003ei\u003c/sub\u003e\n+     *\n+     *         \u0026sum;x\u003csub\u003ei\u003c/sub\u003ex\u003csub\u003ei\u003c/sub\u003e \u0026sum;y\u003csub\u003ei\u003c/sub\u003ez\u003csub\u003ei\u003c/sub\u003e - \u0026sum;x\u003csub\u003ei\u003c/sub\u003ey\u003csub\u003ei\u003c/sub\u003e \u0026sum;x\u003csub\u003ei\u003c/sub\u003ez\u003csub\u003ei\u003c/sub\u003e\n+     *     B \u003d ------------------------\n+     *         \u0026sum;x\u003csub\u003ei\u003c/sub\u003ex\u003csub\u003ei\u003c/sub\u003e \u0026sum;y\u003csub\u003ei\u003c/sub\u003ey\u003csub\u003ei\u003c/sub\u003e - \u0026sum;x\u003csub\u003ei\u003c/sub\u003ey\u003csub\u003ei\u003c/sub\u003e \u0026sum;x\u003csub\u003ei\u003c/sub\u003ey\u003csub\u003ei\u003c/sub\u003e\n+     * \u003c/pre\u003e\n+     * \u003c/p\u003e\n+     *\n+     *\n+     * \u003cp\u003eIn fact, we can assume both a and \u0026omega; are positive and\n+     * compute them directly, knowing that A \u003d a\u003csup\u003e2\u003c/sup\u003e \u0026omega;\u003csup\u003e2\u003c/sup\u003e and that\n+     * B \u003d - \u0026omega;\u003csup\u003e2\u003c/sup\u003e. The complete algorithm is therefore:\u003c/p\u003e\n+     * \u003cpre\u003e\n+     *\n+     * for each t\u003csub\u003ei\u003c/sub\u003e from t\u003csub\u003e1\u003c/sub\u003e to t\u003csub\u003en-1\u003c/sub\u003e, compute:\n+     *   f  (t\u003csub\u003ei\u003c/sub\u003e)\n+     *   f\u0027 (t\u003csub\u003ei\u003c/sub\u003e) \u003d (f (t\u003csub\u003ei+1\u003c/sub\u003e) - f(t\u003csub\u003ei-1\u003c/sub\u003e)) / (t\u003csub\u003ei+1\u003c/sub\u003e - t\u003csub\u003ei-1\u003c/sub\u003e)\n+     *   x\u003csub\u003ei\u003c/sub\u003e \u003d t\u003csub\u003ei\u003c/sub\u003e - t\u003csub\u003e1\u003c/sub\u003e\n+     *   y\u003csub\u003ei\u003c/sub\u003e \u003d \u0026int; f\u003csup\u003e2\u003c/sup\u003e from t\u003csub\u003e1\u003c/sub\u003e to t\u003csub\u003ei\u003c/sub\u003e\n+     *   z\u003csub\u003ei\u003c/sub\u003e \u003d \u0026int; f\u0027\u003csup\u003e2\u003c/sup\u003e from t\u003csub\u003e1\u003c/sub\u003e to t\u003csub\u003ei\u003c/sub\u003e\n+     *   update the sums \u0026sum;x\u003csub\u003ei\u003c/sub\u003ex\u003csub\u003ei\u003c/sub\u003e, \u0026sum;y\u003csub\u003ei\u003c/sub\u003ey\u003csub\u003ei\u003c/sub\u003e, \u0026sum;x\u003csub\u003ei\u003c/sub\u003ey\u003csub\u003ei\u003c/sub\u003e, \u0026sum;x\u003csub\u003ei\u003c/sub\u003ez\u003csub\u003ei\u003c/sub\u003e and \u0026sum;y\u003csub\u003ei\u003c/sub\u003ez\u003csub\u003ei\u003c/sub\u003e\n+     * end for\n+     *\n+     *            |--------------------------\n+     *         \\  | \u0026sum;y\u003csub\u003ei\u003c/sub\u003ey\u003csub\u003ei\u003c/sub\u003e \u0026sum;x\u003csub\u003ei\u003c/sub\u003ez\u003csub\u003ei\u003c/sub\u003e - \u0026sum;x\u003csub\u003ei\u003c/sub\u003ey\u003csub\u003ei\u003c/sub\u003e \u0026sum;y\u003csub\u003ei\u003c/sub\u003ez\u003csub\u003ei\u003c/sub\u003e\n+     * a     \u003d  \\ | ------------------------\n+     *           \\| \u0026sum;x\u003csub\u003ei\u003c/sub\u003ey\u003csub\u003ei\u003c/sub\u003e \u0026sum;x\u003csub\u003ei\u003c/sub\u003ez\u003csub\u003ei\u003c/sub\u003e - \u0026sum;x\u003csub\u003ei\u003c/sub\u003ex\u003csub\u003ei\u003c/sub\u003e \u0026sum;y\u003csub\u003ei\u003c/sub\u003ez\u003csub\u003ei\u003c/sub\u003e\n+     *\n+     *\n+     *            |--------------------------\n+     *         \\  | \u0026sum;x\u003csub\u003ei\u003c/sub\u003ey\u003csub\u003ei\u003c/sub\u003e \u0026sum;x\u003csub\u003ei\u003c/sub\u003ez\u003csub\u003ei\u003c/sub\u003e - \u0026sum;x\u003csub\u003ei\u003c/sub\u003ex\u003csub\u003ei\u003c/sub\u003e \u0026sum;y\u003csub\u003ei\u003c/sub\u003ez\u003csub\u003ei\u003c/sub\u003e\n+     * \u0026omega;     \u003d  \\ | ------------------------\n+     *           \\| \u0026sum;x\u003csub\u003ei\u003c/sub\u003ex\u003csub\u003ei\u003c/sub\u003e \u0026sum;y\u003csub\u003ei\u003c/sub\u003ey\u003csub\u003ei\u003c/sub\u003e - \u0026sum;x\u003csub\u003ei\u003c/sub\u003ey\u003csub\u003ei\u003c/sub\u003e \u0026sum;x\u003csub\u003ei\u003c/sub\u003ey\u003csub\u003ei\u003c/sub\u003e\n+     *\n+     * \u003c/pre\u003e\n+     * \u003c/p\u003e\n+     *\n+     * \u003cp\u003eOnce we know \u0026omega;, we can compute:\n+     * \u003cpre\u003e\n+     *    fc \u003d \u0026omega; f (t) cos (\u0026omega; t) - f\u0027 (t) sin (\u0026omega; t)\n+     *    fs \u003d \u0026omega; f (t) sin (\u0026omega; t) + f\u0027 (t) cos (\u0026omega; t)\n+     * \u003c/pre\u003e\n+     * \u003c/p\u003e\n+     *\n+     * \u003cp\u003eIt appears that \u003ccode\u003efc \u003d a \u0026omega; cos (\u0026phi;)\u003c/code\u003e and\n+     * \u003ccode\u003efs \u003d -a \u0026omega; sin (\u0026phi;)\u003c/code\u003e, so we can use these\n+     * expressions to compute \u0026phi;. The best estimate over the sample is\n+     * given by averaging these expressions.\n+     * \u003c/p\u003e\n+     *\n+     * \u003cp\u003eSince integrals and means are involved in the preceding\n+     * estimations, these operations run in O(n) time, where n is the\n+     * number of measurements.\u003c/p\u003e\n+     */\n+    public static class ParameterGuesser {\n+        /** Sampled observations. */\n+        private final WeightedObservedPoint[] observations;\n+        /** Amplitude. */\n+        private double a;\n+        /** Angular frequency. */\n+        private double omega;\n+        /** Phase. */\n+        private double phi;\n+\n+        /**\n+         * Simple constructor.\n+         * @param observations sampled observations\n+         * @throws NumberIsTooSmallException if the sample is too short or if\n+         * the first guess cannot be computed.\n+         */\n+        public ParameterGuesser(WeightedObservedPoint[] observations) {\n             if (observations.length \u003c 4) {\n                 throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE,\n                                                     observations.length, 4, true);\n             }\n \n-            HarmonicCoefficientsGuesser guesser \u003d new HarmonicCoefficientsGuesser(observations);\n-            guesser.guess();\n-            parameters \u003d new double[] {\n-                guesser.getGuessedAmplitude(),\n-                guesser.getGuessedPulsation(),\n-                guesser.getGuessedPhase()\n-            };\n+            this.observations \u003d observations.clone();\n         }\n \n-        double[] fitted \u003d fitter.fit(new ParametricHarmonicFunction(), parameters);\n-        return new HarmonicFunction(fitted[0], fitted[1], fitted[2]);\n+        /**\n+         * Estimate a first guess of the coefficients.\n+         *\n+         * @return the guessed coefficients, in the following order:\n+         * \u003cul\u003e\n+         *  \u003cli\u003eAmplitude\u003c/li\u003e\n+         *  \u003cli\u003eAngular frequency\u003c/li\u003e\n+         *  \u003cli\u003ePhase\u003c/li\u003e\n+         * \u003c/ul\u003e\n+         */\n+        public double[] guess() {\n+            sortObservations();\n+            guessAOmega();\n+            guessPhi();\n+            return new double[] { a, omega, phi };\n+        }\n+\n+        /**\n+         * Sort the observations with respect to the abscissa.\n+         */\n+        private void sortObservations() {\n+            // Since the samples are almost always already sorted, this\n+            // method is implemented as an insertion sort that reorders the\n+            // elements in place. Insertion sort is very efficient in this case.\n+            WeightedObservedPoint curr \u003d observations[0];\n+            for (int j \u003d 1; j \u003c observations.length; ++j) {\n+                WeightedObservedPoint prec \u003d curr;\n+                curr \u003d observations[j];\n+                if (curr.getX() \u003c prec.getX()) {\n+                    // the current element should be inserted closer to the beginning\n+                    int i \u003d j - 1;\n+                    WeightedObservedPoint mI \u003d observations[i];\n+                    while ((i \u003e\u003d 0) \u0026\u0026 (curr.getX() \u003c mI.getX())) {\n+                        observations[i + 1] \u003d mI;\n+                        if (i-- !\u003d 0) {\n+                            mI \u003d observations[i];\n+                        }\n+                    }\n+                    observations[i + 1] \u003d curr;\n+                    curr \u003d observations[j];\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Estimate a first guess of the amplitude and angular frequency.\n+         * This method assumes that the {@link #sortObservations()} method\n+         * has been called previously.\n+         *\n+         * @throws ZeroException if the abscissa range is zero.\n+         */\n+        private void guessAOmega() {\n+            // initialize the sums for the linear model between the two integrals\n+            double sx2 \u003d 0;\n+            double sy2 \u003d 0;\n+            double sxy \u003d 0;\n+            double sxz \u003d 0;\n+            double syz \u003d 0;\n+\n+            double currentX \u003d observations[0].getX();\n+            double currentY \u003d observations[0].getY();\n+            double f2Integral \u003d 0;\n+            double fPrime2Integral \u003d 0;\n+            final double startX \u003d currentX;\n+            for (int i \u003d 1; i \u003c observations.length; ++i) {\n+                // one step forward\n+                final double previousX \u003d currentX;\n+                final double previousY \u003d currentY;\n+                currentX \u003d observations[i].getX();\n+                currentY \u003d observations[i].getY();\n+\n+                // update the integrals of f\u003csup\u003e2\u003c/sup\u003e and f\u0027\u003csup\u003e2\u003c/sup\u003e\n+                // considering a linear model for f (and therefore constant f\u0027)\n+                final double dx \u003d currentX - previousX;\n+                final double dy \u003d currentY - previousY;\n+                final double f2StepIntegral \u003d\n+                    dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;\n+                final double fPrime2StepIntegral \u003d dy * dy / dx;\n+\n+                final double x \u003d currentX - startX;\n+                f2Integral +\u003d f2StepIntegral;\n+                fPrime2Integral +\u003d fPrime2StepIntegral;\n+\n+                sx2 +\u003d x * x;\n+                sy2 +\u003d f2Integral * f2Integral;\n+                sxy +\u003d x * f2Integral;\n+                sxz +\u003d x * fPrime2Integral;\n+                syz +\u003d f2Integral * fPrime2Integral;\n+            }\n+\n+            // compute the amplitude and pulsation coefficients\n+            double c1 \u003d sy2 * sxz - sxy * syz;\n+            double c2 \u003d sxy * sxz - sx2 * syz;\n+            double c3 \u003d sx2 * sy2 - sxy * sxy;\n+            if ((c1 / c2 \u003c 0) || (c2 / c3 \u003c 0)) {\n+                a \u003d 0;\n+\n+                // Range of the observations, assuming that the\n+                // observations are sorted.\n+                final double range \u003d observations[observations.length - 1].getX() -\n+                    observations[0].getX();\n+\n+                if (range \u003d\u003d 0) {\n+                    throw new ZeroException();\n+                }\n+                omega \u003d 2 * Math.PI / range;\n+            } else {\n+                a \u003d FastMath.sqrt(c1 / c2);\n+                omega \u003d FastMath.sqrt(c2 / c3);\n+            }\n+        }\n+\n+        /**\n+         * Estimate a first guess of the phase.\n+         */\n+        private void guessPhi() {\n+            // initialize the means\n+            double fcMean \u003d 0;\n+            double fsMean \u003d 0;\n+\n+            double currentX \u003d observations[0].getX();\n+            double currentY \u003d observations[0].getY();\n+            for (int i \u003d 1; i \u003c observations.length; ++i) {\n+                // one step forward\n+                final double previousX \u003d currentX;\n+                final double previousY \u003d currentY;\n+                currentX \u003d observations[i].getX();\n+                currentY \u003d observations[i].getY();\n+                final double currentYPrime \u003d (currentY - previousY) / (currentX - previousX);\n+\n+                double omegaX \u003d omega * currentX;\n+                double cosine \u003d FastMath.cos(omegaX);\n+                double sine \u003d FastMath.sin(omegaX);\n+                fcMean +\u003d omega * currentY * cosine - currentYPrime * sine;\n+                fsMean +\u003d omega * currentY * sine + currentYPrime * cosine;\n+            }\n+\n+            phi \u003d FastMath.atan2(-fsMean, fcMean);\n+        }\n     }\n-\n-    /** Parametric harmonic function. */\n-    private static class ParametricHarmonicFunction implements ParametricUnivariateRealFunction {\n-\n-        /** {@inheritDoc} */\n-        public double value(double x, double[] parameters) {\n-            final double a     \u003d parameters[0];\n-            final double omega \u003d parameters[1];\n-            final double phi   \u003d parameters[2];\n-            return a * FastMath.cos(omega * x + phi);\n-        }\n-\n-        /** {@inheritDoc} */\n-        public double[] gradient(double x, double[] parameters) {\n-            final double a     \u003d parameters[0];\n-            final double omega \u003d parameters[1];\n-            final double phi   \u003d parameters[2];\n-            final double alpha \u003d omega * x + phi;\n-            final double cosAlpha \u003d FastMath.cos(alpha);\n-            final double sinAlpha \u003d FastMath.sin(alpha);\n-            return new double[] { cosAlpha, -a * x * sinAlpha, -a * sinAlpha };\n-        }\n-\n-    }\n-\n }\n"
    },
    "Math-3": {
        "Buggy Function": "    public static double linearCombination(final double[] a, final double[] b)\n        throws DimensionMismatchException {\n        final int len = a.length;\n        if (len != b.length) {\n            throw new DimensionMismatchException(len, b.length);\n        }\n\n            // Revert to scalar multiplication.\n\n        final double[] prodHigh = new double[len];\n        double prodLowSum = 0;\n\n        for (int i = 0; i < len; i++) {\n            final double ai = a[i];\n            final double ca = SPLIT_FACTOR * ai;\n            final double aHigh = ca - (ca - ai);\n            final double aLow = ai - aHigh;\n\n            final double bi = b[i];\n            final double cb = SPLIT_FACTOR * bi;\n            final double bHigh = cb - (cb - bi);\n            final double bLow = bi - bHigh;\n            prodHigh[i] = ai * bi;\n            final double prodLow = aLow * bLow - (((prodHigh[i] -\n                                                    aHigh * bHigh) -\n                                                   aLow * bHigh) -\n                                                  aHigh * bLow);\n            prodLowSum += prodLow;\n        }\n\n\n        final double prodHighCur = prodHigh[0];\n        double prodHighNext = prodHigh[1];\n        double sHighPrev = prodHighCur + prodHighNext;\n        double sPrime = sHighPrev - prodHighNext;\n        double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n\n        final int lenMinusOne = len - 1;\n        for (int i = 1; i < lenMinusOne; i++) {\n            prodHighNext = prodHigh[i + 1];\n            final double sHighCur = sHighPrev + prodHighNext;\n            sPrime = sHighCur - prodHighNext;\n            sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n            sHighPrev = sHighCur;\n        }\n\n        double result = sHighPrev + (prodLowSum + sLowSum);\n\n        if (Double.isNaN(result)) {\n            // either we have split infinite numbers or some coefficients were NaNs,\n            // just rely on the naive implementation and let IEEE754 handle this\n            result = 0;\n            for (int i = 0; i < len; ++i) {\n                result += a[i] * b[i];\n            }\n        }\n\n        return result;\n    }",
        "Inducing Changes": "Add Whole Class File of buggy method"
    },
    "Math-35": {
        "Buggy Function": "public ElitisticListPopulation(final List<Chromosome> chromosomes,\n                               final int populationLimit,\n                               final double elitismRate) {\n    super(chromosomes, populationLimit);\n    this.elitismRate = elitismRate;\n}\npublic ElitisticListPopulation(final int populationLimit, final double elitismRate) {\n    super(populationLimit);\n    this.elitismRate = elitismRate;\n}",
        "Inducing Changes": "Add Whole Class File of buggy method"
    },
    "Math-54": {
        "Buggy Function": "protected Dfp(final DfpField field, double x) {\n\n    // initialize as if 0\n    mant = new int[field.getRadixDigits()];\n    sign = 1;\n    exp = 0;\n    nans = FINITE;\n    this.field = field;\n\n    long bits = Double.doubleToLongBits(x);\n    long mantissa = bits & 0x000fffffffffffffL;\n    int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n\n    if (exponent == -1023) {\n        // Zero or sub-normal\n        if (x == 0) {\n            return;\n        }\n\n        exponent++;\n\n        // Normalize the subnormal number\n        while ( (mantissa & 0x0010000000000000L) == 0) {\n            exponent--;\n            mantissa <<= 1;\n        }\n        mantissa &= 0x000fffffffffffffL;\n    }\n\n    if (exponent == 1024) {\n        // infinity or NAN\n        if (x != x) {\n            sign = (byte) 1;\n            nans = QNAN;\n        } else if (x < 0) {\n            sign = (byte) -1;\n            nans = INFINITE;\n        } else {\n            sign = (byte) 1;\n            nans = INFINITE;\n        }\n        return;\n    }\n\n    Dfp xdfp = new Dfp(field, mantissa);\n    xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n    xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n    if ((bits & 0x8000000000000000L) != 0) {\n        xdfp = xdfp.negate();\n    }\n\n    System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n    sign = xdfp.sign;\n    exp  = xdfp.exp;\n    nans = xdfp.nans;\n\n}\npublic double toDouble() {\n\n    if (isInfinite()) {\n        if (lessThan(getZero())) {\n            return Double.NEGATIVE_INFINITY;\n        } else {\n            return Double.POSITIVE_INFINITY;\n        }\n    }\n\n    if (isNaN()) {\n        return Double.NaN;\n    }\n\n    Dfp y = this;\n    boolean negate = false;\n    if (lessThan(getZero())) {\n        y = negate();\n        negate = true;\n    }\n\n    /* Find the exponent, first estimate by integer log10, then adjust.\n     Should be faster than doing a natural logarithm.  */\n    int exponent = (int)(y.log10() * 3.32);\n    if (exponent < 0) {\n        exponent--;\n    }\n\n    Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n    while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n        tempDfp = tempDfp.multiply(2);\n        exponent++;\n    }\n    exponent--;\n\n    /* We have the exponent, now work on the mantissa */\n\n    y = y.divide(DfpMath.pow(getTwo(), exponent));\n    if (exponent > -1023) {\n        y = y.subtract(getOne());\n    }\n\n    if (exponent < -1074) {\n        return 0;\n    }\n\n    if (exponent > 1023) {\n        return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n    }\n\n\n    y = y.multiply(newInstance(4503599627370496l)).rint();\n    String str = y.toString();\n    str = str.substring(0, str.length()-1);\n    long mantissa = Long.parseLong(str);\n\n    if (mantissa == 4503599627370496L) {\n        // Handle special case where we round up to next power of two\n        mantissa = 0;\n        exponent++;\n    }\n\n    /* Its going to be subnormal, so make adjustments */\n    if (exponent <= -1023) {\n        exponent--;\n    }\n\n    while (exponent < -1023) {\n        exponent++;\n        mantissa >>>= 1;\n    }\n\n    long bits = mantissa | ((exponent + 1023L) << 52);\n    double x = Double.longBitsToDouble(bits);\n\n    if (negate) {\n        x = -x;\n    }\n\n    return x;\n\n}",
        "Inducing Changes": "Add Whole Class File of buggy method"
    },
    "Math-55": {
        "Buggy Function": "  public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n\n\n      // rescale both vectors without losing precision,\n      // to ensure their norm are the same order of magnitude\n\n      // we reduce cancellation errors by preconditioning,\n      // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute\n      // v3 without loss of precision. See Kahan lecture\n      // \"Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces\"\n      // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf\n\n      // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n\n\n      // compute cross product from v3 and v2 instead of v1 and v2\n      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n\n  }",
        "Inducing Changes": "Add Whole Class File of buggy method"
    },
    "Math-63": {
        "Buggy Function": "    public static boolean equals(double x, double y) {\n        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n    }",
        "Inducing Changes": "diff --git a/src/java/org/apache/commons/math/util/MathUtils.java b/src/java/org/apache/commons/math/util/MathUtils.java\nindex 09bbd4f..d354b87 100644\n--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n@@ -276,6 +276,30 @@\n     }\n \n     /**\n+     * Returns true iff both arguments aren null or have same dimensions\n+     * and all their elements are {@link #equals(double,double) equals}\n+     * \n+     * @param x first array\n+     * @param y second array\n+     * @return true if the values are both null or have same dimension\n+     * and equal elements\n+     */\n+    public static boolean equals(double[] x, double[] y) {\n+        if ((x \u003d\u003d null) || (y \u003d\u003d null)) {\n+            return !((x \u003d\u003d null) ^ (y \u003d\u003d null));\n+        }\n+        if (x.length !\u003d y.length) {\n+            return false;\n+        }\n+        for (int i \u003d 0; i \u003c x.length; ++i) {\n+            if (!equals(x[i], y[i])) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n      * Returns n!. Shorthand for \u003ccode\u003en\u003c/code\u003e \u003ca\n      * href\u003d\"http://mathworld.wolfram.com/Factorial.html\"\u003e Factorial\u003c/a\u003e, the\n      * product of the numbers \u003ccode\u003e1,...,n\u003c/code\u003e.\n@@ -433,6 +457,23 @@\n     }\n \n     /**\n+     * Returns an integer hash code representing the given double array value.\n+     * \n+     * @param value the value to be hashed (may be null)\n+     * @return the hash code\n+     */\n+    public static int hash(double[] value) {\n+        if (value \u003d\u003d null) {\n+            return 0;\n+        }\n+        int result \u003d value.length;\n+        for (int i \u003d 0; i \u003c value.length; ++i) {\n+            result \u003d result * 31 + hash(value[i]);\n+        }\n+        return result;\n+    }\n+\n+    /**\n      * For a byte value x, this method returns (byte)(+1) if x \u003e\u003d 0 and\n      * (byte)(-1) if x \u003c 0.\n      * \n"
    },
    "Math-70": {
        "Buggy Function": "    public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(min, max);\n    }",
        "Inducing Changes": "diff --git a/src/java/org/apache/commons/math/analysis/BisectionSolver.java b/src/java/org/apache/commons/math/analysis/BisectionSolver.java\nindex 3488b55..6f3f1e8 100644\n--- a/src/java/org/apache/commons/math/analysis/BisectionSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BisectionSolver.java\n@@ -30,49 +30,54 @@\n public class BisectionSolver extends UnivariateRealSolverImpl {\n     \n     /** Serializable version identifier */\n-    private static final long serialVersionUID \u003d 4963578633786538912L;\n+    private static final long serialVersionUID \u003d 5227509383222989438L;\n \n     /**\n      * Construct a solver for the given function.\n      * \n      * @param f function to solve.\n+     * @deprecated as of 2.0 the function to solve is passed as an argument\n+     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n+     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n+     * method.\n      */\n+    @Deprecated\n     public BisectionSolver(UnivariateRealFunction f) {\n         super(f, 100, 1E-6);\n     }\n \n     /**\n-     * Find a zero in the given interval.\n+     * Construct a solver.\n      * \n-     * @param min the lower bound for the interval.\n-     * @param max the upper bound for the interval.\n-     * @param initial the start value to use (ignored).\n-     * @return the value where the function is zero\n-     * @throws MaxIterationsExceededException the maximum iteration count is exceeded \n-     * @throws FunctionEvaluationException if an error occurs evaluating\n-     *  the function\n-     * @throws IllegalArgumentException if min is not less than max\n      */\n+    public BisectionSolver() {\n+        super(100, 1E-6);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n     public double solve(double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-          \n-        return solve(min, max);\n+        return solve(f, min, max);\n     }\n     \n-    /**\n-     * Find a zero root in the given interval.\n-     * \n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @return the value where the function is zero\n-     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded.\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n-     * @throws IllegalArgumentException if min is not less than max\n-     */\n-    public double solve(double min, double max) throws MaxIterationsExceededException,\n-        FunctionEvaluationException {\n-        \n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(double min, double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        return solve(f, min, max);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        return solve(min, max);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double solve(final UnivariateRealFunction f, double min, double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+            \n         clearResult();\n         verifyInterval(min,max);\n         double m;\n"
    },
    "Math-79": {
        "Buggy Function": "    public static double distance(int[] p1, int[] p2) {\n      int sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          final int dp = p1[i] - p2[i];\n          sum += dp * dp;\n      }\n      return Math.sqrt(sum);\n    }",
        "Inducing Changes": "diff --git a/src/java/org/apache/commons/math/util/MathUtils.java b/src/java/org/apache/commons/math/util/MathUtils.java\nindex abb5e91..68f005b 100644\n--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n@@ -1483,4 +1483,97 @@\n \n     }\n \n+    /**\n+     * Calculates the L\u003csub\u003e1\u003c/sub\u003e (sum of abs) distance between two points.\n+     *\n+     * @param p1 the first point\n+     * @param p2 the second point\n+     * @return the L\u003csub\u003e1\u003c/sub\u003e distance between the two points\n+     */\n+    public static final double distance1(double[] p1, double[] p2) {\n+        double sum \u003d 0;\n+        for (int i \u003d 0; i \u003c p1.length; i++) {\n+            sum +\u003d Math.abs(p1[i] - p2[i]);\n+        }\n+        return sum;\n+    }\n+    \n+    /**\n+     * Calculates the L\u003csub\u003e1\u003c/sub\u003e (sum of abs) distance between two points.\n+     *\n+     * @param p1 the first point\n+     * @param p2 the second point\n+     * @return the L\u003csub\u003e1\u003c/sub\u003e distance between the two points\n+     */\n+    public static final int distance1(int[] p1, int[] p2) {\n+      int sum \u003d 0;\n+      for (int i \u003d 0; i \u003c p1.length; i++) {\n+          sum +\u003d Math.abs(p1[i] - p2[i]);\n+      }\n+      return sum;\n+    }\n+\n+    /**\n+     * Calculates the L\u003csub\u003e2\u003c/sub\u003e (Euclidean) distance between two points.\n+     *\n+     * @param p1 the first point\n+     * @param p2 the second point\n+     * @return the L\u003csub\u003e2\u003c/sub\u003e distance between the two points\n+     */\n+    public static final double distance(double[] p1, double[] p2) {\n+        double sum \u003d 0;\n+        for (int i \u003d 0; i \u003c p1.length; i++) {\n+            final double dp \u003d p1[i] - p2[i];\n+            sum +\u003d dp * dp;\n+        }\n+        return Math.sqrt(sum);\n+    }\n+    \n+    /**\n+     * Calculates the L\u003csub\u003e2\u003c/sub\u003e (Euclidean) distance between two points.\n+     *\n+     * @param p1 the first point\n+     * @param p2 the second point\n+     * @return the L\u003csub\u003e2\u003c/sub\u003e distance between the two points\n+     */\n+    public static final double distance(int[] p1, int[] p2) {\n+      int sum \u003d 0;\n+      for (int i \u003d 0; i \u003c p1.length; i++) {\n+          final int dp \u003d p1[i] - p2[i];\n+          sum +\u003d dp * dp;\n+      }\n+      return Math.sqrt(sum);\n+    }\n+    \n+    /**\n+     * Calculates the L\u003csub\u003e\u0026infin;\u003c/sub\u003e (max of abs) distance between two points.\n+     *\n+     * @param p1 the first point\n+     * @param p2 the second point\n+     * @return the L\u003csub\u003e\u0026infin;\u003c/sub\u003e distance between the two points\n+     */\n+    public static final double distanceInf(double[] p1, double[] p2) {\n+        double max \u003d 0;\n+        for (int i \u003d 0; i \u003c p1.length; i++) {\n+            max \u003d Math.max(max, Math.abs(p1[i] - p2[i]));\n+        }\n+        return max;\n+    }\n+    \n+    /**\n+     * Calculates the L\u003csub\u003e\u0026infin;\u003c/sub\u003e (max of abs) distance between two points.\n+     *\n+     * @param p1 the first point\n+     * @param p2 the second point\n+     * @return the L\u003csub\u003e\u0026infin;\u003c/sub\u003e distance between the two points\n+     */\n+    public static final int distanceInf(int[] p1, int[] p2) {\n+        int max \u003d 0;\n+        for (int i \u003d 0; i \u003c p1.length; i++) {\n+            max \u003d Math.max(max, Math.abs(p1[i] - p2[i]));\n+        }\n+        return max;\n+    }\n+\n+    \n }\n"
    },
    "Math-92": {
        "Buggy Function": "public static long binomialCoefficient(final int n, final int k) {\n    if (n < k) {\n        throw new IllegalArgumentException(\n            \"must have n >= k for binomial coefficient (n,k)\");\n    }\n    if (n < 0) {\n        throw new IllegalArgumentException(\n            \"must have n >= 0 for binomial coefficient (n,k)\");\n    }\n    if ((n == k) || (k == 0)) {\n        return 1;\n    }\n    if ((k == 1) || (k == n - 1)) {\n        return n;\n    }\n\n    long result = Math.round(binomialCoefficientDouble(n, k));\n    if (result == Long.MAX_VALUE) {\n        throw new ArithmeticException(\n            \"result too large to represent in a long integer\");\n    }\n    return result;\n}\npublic static double binomialCoefficientDouble(final int n, final int k) {\n    return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);\n}\npublic static double binomialCoefficientLog(final int n, final int k) {\n    if (n < k) {\n        throw new IllegalArgumentException(\n            \"must have n >= k for binomial coefficient (n,k)\");\n    }\n    if (n < 0) {\n        throw new IllegalArgumentException(\n            \"must have n >= 0 for binomial coefficient (n,k)\");\n    }\n    if ((n == k) || (k == 0)) {\n        return 0;\n    }\n    if ((k == 1) || (k == n - 1)) {\n        return Math.log((double)n);\n    }\n    double logSum = 0;\n\n    // n!/k!\n    for (int i = k + 1; i <= n; i++) {\n        logSum += Math.log((double)i);\n    }\n\n    // divide by (n-k)!\n    for (int i = 2; i <= n - k; i++) {\n        logSum -= Math.log((double)i);\n    }\n\n    return logSum;\n}",
        "Inducing Changes": "Add Whole Class File of buggy method"
    },
    "Math-93": {
        "Buggy Function": "public static long factorial(final int n) {\n    long result = Math.round(factorialDouble(n));\n    if (result == Long.MAX_VALUE) {\n        throw new ArithmeticException(\n            \"result too large to represent in a long integer\");\n    }\n    return result;\n}\npublic static double factorialDouble(final int n) {\n    if (n < 0) {\n        throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n    }\n    return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n}\npublic static double factorialLog(final int n) {\n    if (n < 0) {\n        throw new IllegalArgumentException(\"must have n > 0 for n!\");\n    }\n    double logSum = 0;\n    for (int i = 2; i <= n; i++) {\n        logSum += Math.log((double)i);\n    }\n    return logSum;\n}",
        "Inducing Changes": "Add Whole Class File of buggy method"
    },
    "Math-96": {
        "Buggy Function": "    public boolean equals(Object other) {\n        boolean ret;\n        \n        if (this == other) { \n            ret = true;\n        } else if (other == null) {\n            ret = false;\n        } else  {\n            try {\n                Complex rhs = (Complex)other;\n                if (rhs.isNaN()) {\n                    ret = this.isNaN();\n                } else {\n                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n                }\n            } catch (ClassCastException ex) {\n                // ignore exception\n                ret = false;\n            }\n        }\n      \n        return ret;\n    }",
        "Inducing Changes": "Add Whole Class File of buggy method"
    },
    "Math-97": {
        "Buggy Function": "    public double solve(double min, double max) throws MaxIterationsExceededException, \n        FunctionEvaluationException {\n        \n        clearResult();\n        verifyInterval(min, max);\n        \n        double ret = Double.NaN;\n        \n        double yMin = f.value(min);\n        double yMax = f.value(max);\n        \n        // Verify bracketing\n        double sign = yMin * yMax;\n        if (sign >= 0) {\n            // check if either value is close to a zero\n                // neither value is close to zero and min and max do not bracket root.\n                throw new IllegalArgumentException\n                (\"Function values at endpoints do not have different signs.\" +\n                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n        } else {\n            // solve using only the first endpoint as initial guess\n            ret = solve(min, yMin, max, yMax, min, yMin);\n            // either min or max is a root\n        }\n\n        return ret;\n    }",
        "Inducing Changes": "diff --git a/src/java/org/apache/commons/math/analysis/BrentSolver.java b/src/java/org/apache/commons/math/analysis/BrentSolver.java\nindex ef2a985..80a48f0 100644\n--- a/src/java/org/apache/commons/math/analysis/BrentSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BrentSolver.java\n@@ -17,23 +17,25 @@\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.MathException;\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n \n /**\n- * Implements the <a href=\"http://mathworld.wolfram.com/BrentsMethod.html\">Brent algorithm</a>\n- * for  finding zeros of real univariate\n- * functions. This algorithm will find only one zero in the given interval. \n+ * Implements the <a href=\"http://mathworld.wolfram.com/BrentsMethod.html\">\n+ * Brent algorithm</a> for  finding zeros of real univariate functions.\n+ * <p>\n  * The function should be continuous but not necessarily smooth.\n  *  \n- * @version $Revision: 1.16 $ $Date: 2004/06/23 16:26:14 $\n+ * @version $Revision: 1.17 $ $Date: 2004/07/17 21:19:39 $\n  */\n-public class BrentSolver extends UnivariateRealSolverImpl implements Serializable {\n+public class BrentSolver extends UnivariateRealSolverImpl {\n     \n     /** Serializable version identifier */\n     static final long serialVersionUID = 3350616277306882875L;\n \n     /**\n      * Construct a solver for the given function.\n+     * \n      * @param f function to solve.\n      */\n     public BrentSolver(UnivariateRealFunction f) {\n@@ -42,39 +44,57 @@\n \n     /**\n      * Find a zero in the given interval.\n+     * <p>\n+     * Throws <code>ConvergenceException</code> if the values of the function\n+     * at the endpoints of the interval have the same sign.\n+     * \n      * @param min the lower bound for the interval.\n      * @param max the upper bound for the interval.\n      * @param initial the start value to use (ignored).\n      * @return the value where the function is zero\n-     * @throws MathException if the iteration count was exceeded or the\n-     *  solver detects convergence problems otherwise.\n+     * @throws ConvergenceException the maximum iteration count is exceeded \n+     * @throws FunctionEvaluationException if an error occurs evaluating\n+     *  the function\n+     * @throws IllegalArgumentException if initial is not between min and max\n      */\n     public double solve(double min, double max, double initial)\n-        throws MathException {\n+        throws ConvergenceException, FunctionEvaluationException {\n             \n         return solve(min, max);\n     }\n     \n     /**\n      * Find a zero in the given interval.\n+     * <p>\n+     * Requires that the values of the function at the endpoints have opposite\n+     * signs. An <code>IllegalArgumentException</code> is thrown if this is not\n+     * the case.\n+     * \n      * @param min the lower bound for the interval.\n      * @param max the upper bound for the interval.\n      * @return the value where the function is zero\n-     * @throws MathException if the iteration count was exceeded or the\n-     *  solver detects convergence problems otherwise.\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if min is not less than max or the\n+     * signs of the values of the function at the endpoints are not opposites\n      */\n-    public double solve(double min, double max) throws MathException {\n+    public double solve(double min, double max) throws ConvergenceException, \n+        FunctionEvaluationException {\n+        \n         clearResult();\n+        verifyBracketing(min, max, f);\n+        \n         // Index 0 is the old approximation for the root.\n         // Index 1 is the last calculated approximation  for the root.\n         // Index 2 is a bracket for the root with respect to x1.\n         double x0 = min;\n         double x1 = max;\n-        double y0 = f.value(x0);\n-        double y1 = f.value(x1);\n-        if ((y0 > 0) == (y1 > 0)) {\n-            throw new MathException(\"Interval doesn't bracket a zero.\");\n-        }\n+        double y0;\n+        double y1;\n+        y0 = f.value(x0);\n+        y1 = f.value(x1);\n+   \n         double x2 = x0;\n         double y2 = y0;\n         double delta = x1 - x0;\n@@ -161,6 +181,6 @@\n             }\n             i++;\n         }\n-        throw new MathException(\"Maximum number of iterations exceeded.\");\n+        throw new ConvergenceException(\"Maximum number of iterations exceeded.\");\n     }\n }\n\n"
    }
}