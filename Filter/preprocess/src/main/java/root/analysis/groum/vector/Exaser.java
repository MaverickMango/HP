package root.analysis.groum.vector;

import root.analysis.groum.entity.AbstractNode;
import root.analysis.groum.entity.IntraGroum;

import java.util.*;
import java.util.stream.Collectors;

public class Exaser {

    LinkedHashMap<Feature, Integer> featureCounts;

    public Exaser() {
        this.featureCounts = new LinkedHashMap<>();
    }

    public LinkedHashMap<Feature, Integer> getFeatureCounts() {
        return featureCounts;
    }

    public Set<AbstractNode> getFeaturesNode() {
        Set<Feature> collect = featureCounts.keySet().stream().filter(f -> f.isNode).collect(Collectors.toSet());
        return collect.stream().map(Feature::getRoot).collect(Collectors.toSet());
    }

    public List<Integer> getVector() {
        List<Integer> vector = new ArrayList<>();
        for (Map.Entry<Feature, Integer> entries :featureCounts.entrySet()) {
            vector.add(entries.getValue());
        }
        return vector;
    }

    /**
     * g = f + e, where g is a new fragment which build from f by extending f with an edge e.
     * e = (u, v):
     *            1. u is a new node: new features are created from the 1-path u, 2-path u-v, the new (0,1)-node at u.
     *                                The (x,y)-node at v is replaced by (x+1,y)-node.
     *                                All new n-paths are generated by adding u to the first of all (n-1)-paths starting from v(deep search within g from v to the depth of n-2).
     *            2. v is a new node: similar to the above, but n-paths are generated from (n-1)-paths ending at u.
     *                                (x,y)-node at v is replaced by a new (x,y+1)-node.(backward dfs)
     *            3. no new node: The (x,y)-node at u is replaced by (x+1,y)-node. (x,y)-node at v is replaced by a new (x,y+1)-node.
     *                            new n-paths are generated by combination of any i-path ending at u(backward dfs) and a j-path starting from v(forward dfs) for all i+j=n.
     * 复杂度达到和路径长度N有关，假设N中节点的最大度为d，复杂度为O(m.N.d^(N-2)), m为边的数量…反正不能比一整个函数就是了
     * 该方法应该在tail<-head边加进g之前执行！！！
     * 只新增节点，不增加边也可以
     **/
    public void incrVector(IntraGroum g, AbstractNode head, AbstractNode tail) {
        List<AbstractNode> nodes = g.getNodes();
        //case 3
        if (nodes.contains(head) && nodes.contains(tail)) {
            //replace node
            String newComponent = String.valueOf(head.getOutgoingEdges().size() + 1);
            replaceFeature(head, newComponent, 2);
            newComponent = String.valueOf(tail.getIncomingEdges().size() + 1);
            replaceFeature(tail, newComponent, 1);
            //add n-paths
            List<Feature> headEndPaths = featureCounts.keySet().stream().filter(feature ->
                    feature.endNodeIs(head.getLabel())).collect(Collectors.toList());
            List<Feature> tailStartPaths = featureCounts.keySet().stream().filter(feature ->
                    feature.startNodeIs(tail.getLabel())).collect(Collectors.toList());
            if (!headEndPaths.isEmpty() && !tailStartPaths.isEmpty()) {
                List<List<Object>> iPaths = headEndPaths.stream().map(Feature::getPathNode)
                        .collect(Collectors.toList());
                List<List<Object>> jPaths = tailStartPaths.stream().map(Feature::getPathNode)
                        .collect(Collectors.toList());
                iPaths.forEach(iPath -> {
                    jPaths.forEach(jPath -> {
                        addFeature(iPath, jPath);
                    });
                });//combine
            }
        }
        //case 2
        if (tail != null && !nodes.contains(tail)) {
            //new node
            //new 1-path head
            boolean isIn4Node = head != null;
            newNode(tail, isIn4Node, false);
            if (isIn4Node) {
                //replace node
                String newComponent = String.valueOf(head.getOutgoingEdges().size() + 1);
                replaceFeature(head, newComponent, 2);
                //new 2-path head-tail
                addFeature(head, tail);
                //add n-paths from (n-1)-path
                List<Feature> headEndPaths = featureCounts.keySet().stream().filter(feature ->
                        feature.endNodeIs(head.getLabel()) && feature.getLength() > 1).collect(Collectors.toList());
                if (!headEndPaths.isEmpty()) {
                    List<List<Object>> path2Add = headEndPaths.stream().map(Feature::getPathNode)
                            .collect(Collectors.toList());
                    path2Add.forEach(p -> addFeature(tail, false, p));
                }
            }
        }
        //case 1
        if (head != null && !nodes.contains(head)) {
            //new node
            //new 1-path head
            boolean isOut4Node = tail != null;
            newNode(head, false, isOut4Node);
            if (isOut4Node) {
                //replace node
                String newComponent = String.valueOf(tail.getIncomingEdges().size() + 1);
                replaceFeature(tail, newComponent, 1);
                //new 2-path head-tail
                addFeature(head, tail);
                //add n-paths from (n-1)-path
                List<Feature> tailStartPaths = featureCounts.keySet().stream().filter(feature ->
                        feature.startNodeIs(tail.getLabel()) && feature.getLength() > 1).collect(Collectors.toList());
                if (!tailStartPaths.isEmpty()) {
                    List<List<Object>> path2Add = tailStartPaths.stream().map(Feature::getPathNode)
                            .collect(Collectors.toList());
                    path2Add.forEach(p -> addFeature(head, true, p));
                }
            }
        }
    }

    public void newNode(AbstractNode node, boolean isIn4Node, boolean isOut4Node) {
        if (getFeaturesNode().contains(node))
            return;
        //new node
        addFeature(node, isIn4Node, isOut4Node);
        //1-path
        addFeature(node);
    }

    private void addFeature(List<Object> iPath, List<Object> jPath) {//combine n-path
        AbstractNode root = (AbstractNode) iPath.get(0);
        Feature feature = new Feature(root);
        List<Object> tmp = new ArrayList<>();
        tmp.addAll(iPath.subList(1, iPath.size()));
        tmp.addAll(jPath);
        feature.addComponents(tmp);
        int count = 1;
        if (featureCounts.containsKey(feature)) {
            count += featureCounts.get(feature);
        }
        featureCounts.put(feature, count);
    }

    private void addFeature(AbstractNode node, boolean isStart, List<Object> components) {//n-paths,n>2
        Feature feature;
        if (isStart) {
            feature = new Feature(node);
            feature.addComponents(components);
        } else {
            AbstractNode root = (AbstractNode) components.get(0);
            feature = new Feature(root);
            List<Object> tmp = new ArrayList<>();
            tmp.addAll(components.subList(1, components.size()));
            tmp.add(node);
            feature.addComponents(tmp);
        }
        int count = 1;
        if (featureCounts.containsKey(feature)) {
            count += featureCounts.get(feature);
        }
        featureCounts.put(feature, count);
    }

    private void addFeature(AbstractNode... nodes) {//path
        Feature feature = new Feature(nodes[0]);
        for (int i = 1; i < nodes.length; i ++) {
            feature.addComponent(nodes[i]);
        }
        int count = 1;
        if (featureCounts.containsKey(feature)) {
            count += featureCounts.get(feature) ;
        }
        featureCounts.put(feature, count);
    }

    private void addFeature(AbstractNode node, boolean isIn4Node, boolean isOut4Node) {//node
        int incomingSize = isIn4Node ? node.getIncomingEdges().size() + 1 : node.getIncomingEdges().size();
        int outgoingSize = isOut4Node ? node.getOutgoingEdges().size() + 1 : node.getOutgoingEdges().size();
        Feature feature = new Feature(node, incomingSize, outgoingSize);
        int count = 1;
        if (featureCounts.containsKey(feature)) {
            count += featureCounts.get(feature);
        }
        featureCounts.put(feature, count);
    }

    private void replaceFeature(AbstractNode node, String newComponent, int idx) {
        List<Feature> collect = featureCounts.keySet().stream().filter(f -> f.isNode() && f.getRoot().equals(node)).collect(Collectors.toList());
        Integer oldCount = 1;
        Feature feature;
        if (!collect.isEmpty()) {
            feature = collect.get(0);
        } else {
            //should never be accessed
            feature = new Feature(node, node.getIncomingEdges().size(), node.getOutgoingEdges().size());
        }
        featureCounts.remove(feature);
        feature.replaceLabel(newComponent, idx);
        featureCounts.put(feature, oldCount);
    }
}
