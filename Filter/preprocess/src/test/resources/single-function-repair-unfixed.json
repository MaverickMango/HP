{
  "Time-1": {
    "buggy": "/** \n * Always returns zero.\n * @return zero always\n */\npublic long getUnitMillis(){\n  return 0;\n}\n\n/** \n * Constructs a Partial with the specified fields and values. The fields must be specified in the order largest to smallest. \u003cp\u003e The constructor uses the specified chronology.\n * @param types  the types to create the partial from, not null\n * @param values  the values to store, not null\n * @param chronology  the chronology, null means ISO\n * @throws IllegalArgumentException if the types or values are invalid\n */\npublic Partial(DateTimeFieldType[] types,int[] values,Chronology chronology){\n  super();\n  chronology\u003dDateTimeUtils.getChronology(chronology).withUTC();\n  iChronology\u003dchronology;\n  if (types \u003d\u003d null) {\n    throw new IllegalArgumentException(\"Types array must not be null\");\n  }\n  if (values \u003d\u003d null) {\n    throw new IllegalArgumentException(\"Values array must not be null\");\n  }\n  if (values.length !\u003d types.length) {\n    throw new IllegalArgumentException(\"Values array must be the same length as the types array\");\n  }\n  if (types.length \u003d\u003d 0) {\n    iTypes\u003dtypes;\n    iValues\u003dvalues;\n    return;\n  }\n  for (int i\u003d0; i \u003c types.length; i++) {\n    if (types[i] \u003d\u003d null) {\n      throw new IllegalArgumentException(\"Types array must not contain null: index \" + i);\n    }\n  }\n  DurationField lastUnitField\u003dnull;\n  for (int i\u003d0; i \u003c types.length; i++) {\n    DateTimeFieldType loopType\u003dtypes[i];\n    DurationField loopUnitField\u003dloopType.getDurationType().getField(iChronology);\n    if (i \u003e 0) {\n      int compare\u003dlastUnitField.compareTo(loopUnitField);\n      if (compare \u003c 0) {\n        throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" + types[i - 1].getName() + \" \u003c \"+ loopType.getName());\n      }\n else       if (compare \u003d\u003d 0) {\n        if (types[i - 1].getRangeDurationType() \u003d\u003d null) {\n          if (loopType.getRangeDurationType() \u003d\u003d null) {\n            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" + types[i - 1].getName() + \" and \"+ loopType.getName());\n          }\n        }\n else {\n          if (loopType.getRangeDurationType() \u003d\u003d null) {\n            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" + types[i - 1].getName() + \" \u003c \"+ loopType.getName());\n          }\n          DurationField lastRangeField\u003dtypes[i - 1].getRangeDurationType().getField(iChronology);\n          DurationField loopRangeField\u003dloopType.getRangeDurationType().getField(iChronology);\n          if (lastRangeField.compareTo(loopRangeField) \u003c 0) {\n            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" + types[i - 1].getName() + \" \u003c \"+ loopType.getName());\n          }\n          if (lastRangeField.compareTo(loopRangeField) \u003d\u003d 0) {\n            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" + types[i - 1].getName() + \" and \"+ loopType.getName());\n          }\n        }\n      }\n    }\n    lastUnitField\u003dloopUnitField;\n  }\n  iTypes\u003d(DateTimeFieldType[])types.clone();\n  chronology.validate(this,values);\n  iValues\u003d(int[])values.clone();\n}\n\n",
    "fix": "/** \n * Always returns zero.\n * @return zero always\n */\npublic long getUnitMillis(){\n  return 0;\n}\n\n/** \n * Constructs a Partial with the specified fields and values. The fields must be specified in the order largest to smallest. \u003cp\u003e The constructor uses the specified chronology.\n * @param types  the types to create the partial from, not null\n * @param values  the values to store, not null\n * @param chronology  the chronology, null means ISO\n * @throws IllegalArgumentException if the types or values are invalid\n */\npublic Partial(DateTimeFieldType[] types,int[] values,Chronology chronology){\n  super();\n  chronology\u003dDateTimeUtils.getChronology(chronology).withUTC();\n  iChronology\u003dchronology;\n  if (types \u003d\u003d null) {\n    throw new IllegalArgumentException(\"Types array must not be null\");\n  }\n  if (values \u003d\u003d null) {\n    throw new IllegalArgumentException(\"Values array must not be null\");\n  }\n  if (values.length !\u003d types.length) {\n    throw new IllegalArgumentException(\"Values array must be the same length as the types array\");\n  }\n  if (types.length \u003d\u003d 0) {\n    iTypes\u003dtypes;\n    iValues\u003dvalues;\n    return;\n  }\n  for (int i\u003d0; i \u003c types.length; i++) {\n    if (types[i] \u003d\u003d null) {\n      throw new IllegalArgumentException(\"Types array must not contain null: index \" + i);\n    }\n  }\n  DurationField lastUnitField\u003dnull;\n  for (int i\u003d0; i \u003c types.length; i++) {\n    DateTimeFieldType loopType\u003dtypes[i];\n    DurationField loopUnitField\u003dloopType.getDurationType().getField(iChronology);\n    if (i \u003e 0) {\n      int compare\u003dlastUnitField.compareTo(loopUnitField);\n      if (compare \u003c 0 || (compare !\u003d 0 \u0026\u0026 loopUnitField.isSupported() \u003d\u003d false)) {\n        throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" + types[i - 1].getName() + \" \u003c \"+ loopType.getName());\n      }\n else       if (compare \u003d\u003d 0) {\n        if (types[i - 1].getRangeDurationType() \u003d\u003d null) {\n          if (loopType.getRangeDurationType() \u003d\u003d null) {\n            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" + types[i - 1].getName() + \" and \"+ loopType.getName());\n          }\n        }\n else {\n          if (loopType.getRangeDurationType() \u003d\u003d null) {\n            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" + types[i - 1].getName() + \" \u003c \"+ loopType.getName());\n          }\n          DurationField lastRangeField\u003dtypes[i - 1].getRangeDurationType().getField(iChronology);\n          DurationField loopRangeField\u003dloopType.getRangeDurationType().getField(iChronology);\n          if (lastRangeField.compareTo(loopRangeField) \u003c 0) {\n            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" + types[i - 1].getName() + \" \u003c \"+ loopType.getName());\n          }\n          if (lastRangeField.compareTo(loopRangeField) \u003d\u003d 0) {\n            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" + types[i - 1].getName() + \" and \"+ loopType.getName());\n          }\n        }\n      }\n    }\n    lastUnitField\u003dloopUnitField;\n  }\n  iTypes\u003d(DateTimeFieldType[])types.clone();\n  chronology.validate(this,values);\n  iValues\u003d(int[])values.clone();\n}\n\n",
    "original": "/** \n * Constructs a Partial with the specified fields and values. The fields must be specified in the order largest to smallest. \u003cp\u003e The constructor uses the specified chronology.\n * @param types  the types to create the partial from, not null\n * @param values  the values to store, not null\n * @param chronology  the chronology, null means ISO\n * @throws IllegalArgumentException if the types or values are invalid\n */\npublic Partial(DateTimeFieldType[] types,int[] values,Chronology chronology){\n  super();\n  chronology\u003dDateTimeUtils.getChronology(chronology).withUTC();\n  iChronology\u003dchronology;\n  if (types \u003d\u003d null) {\n    throw new IllegalArgumentException(\"Types array must not be null\");\n  }\n  if (values \u003d\u003d null) {\n    throw new IllegalArgumentException(\"Values array must not be null\");\n  }\n  if (values.length !\u003d types.length) {\n    throw new IllegalArgumentException(\"Values array must be the same length as the types array\");\n  }\n  if (types.length \u003d\u003d 0) {\n    iTypes\u003dtypes;\n    iValues\u003dvalues;\n    return;\n  }\n  for (int i\u003d0; i \u003c types.length; i++) {\n    if (types[i] \u003d\u003d null) {\n      throw new IllegalArgumentException(\"Types array must not contain null: index \" + i);\n    }\n  }\n  DurationField lastUnitField\u003dnull;\n  for (int i\u003d0; i \u003c types.length; i++) {\n    DateTimeFieldType loopType\u003dtypes[i];\n    DurationField loopUnitField\u003dloopType.getDurationType().getField(iChronology);\n    if (i \u003e 0) {\n      int compare\u003dlastUnitField.compareTo(loopUnitField);\n      if (compare \u003c 0 || (compare !\u003d 0 \u0026\u0026 loopUnitField.isSupported() \u003d\u003d false)) {\n        throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" + types[i - 1].getName() + \" \u003c \"+ loopType.getName());\n      }\n else       if (compare \u003d\u003d 0) {\n        if (types[i - 1].getRangeDurationType() \u003d\u003d null) {\n          if (loopType.getRangeDurationType() \u003d\u003d null) {\n            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" + loopType.getName());\n          }\n        }\n else {\n          if (loopType.getRangeDurationType() \u003d\u003d null) {\n            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" + types[i - 1].getName() + \" \u003c \"+ loopType.getName());\n          }\n          DurationField lastRangeField\u003dtypes[i - 1].getRangeDurationType().getField(iChronology);\n          DurationField loopRangeField\u003dloopType.getRangeDurationType().getField(iChronology);\n          if (lastRangeField.compareTo(loopRangeField) \u003c 0) {\n            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" + types[i - 1].getName() + \" \u003c \"+ loopType.getName());\n          }\n          if (lastRangeField.compareTo(loopRangeField) \u003d\u003d 0) {\n            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" + loopType.getName());\n          }\n        }\n      }\n    }\n    lastUnitField\u003dloopUnitField;\n  }\n  iTypes\u003d(DateTimeFieldType[])types.clone();\n  chronology.validate(this,values);\n  iValues\u003d(int[])values.clone();\n}\n\n/** \n * Always returns zero.\n * @return zero always\n */\npublic long getUnitMillis(){\n  return 0;\n}\n\n"
  },
  "Mockito-12": {
    "buggy": "",
    "fix": "/** \n * Finds the generic type (parametrized type) of the field. If the field is not generic it returns Object.class. \n * @param field\n * @return\n */\npublic Class getGenericType(Field field){\n  Type generic\u003dfield.getGenericType();\n  if (generic !\u003d null \u0026\u0026 generic instanceof ParameterizedType) {\n    Type actual\u003d((ParameterizedType)generic).getActualTypeArguments()[0];\n    if (actual instanceof Class) {\n      return (Class)actual;\n    }\n else     if (actual instanceof ParameterizedType) {\n      return (Class)((ParameterizedType)actual).getRawType();\n    }\n  }\n  return Object.class;\n}\n\n",
    "original": ""
  },
  "Jsoup-26": {
    "buggy": "",
    "fix": "/** \n * Creates a new, clean document, from the original dirty document, containing only elements allowed by the whitelist. The original document is not modified. Only elements from the dirt document\u0027s \u003ccode\u003ebody\u003c/code\u003e are used.\n * @param dirtyDocument Untrusted base document to clean.\n * @return cleaned document.\n */\npublic Document clean(Document dirtyDocument){\n  Validate.notNull(dirtyDocument);\n  Document clean\u003dDocument.createShell(dirtyDocument.baseUri());\n  if (dirtyDocument.body() !\u003d null)   copySafeNodes(dirtyDocument.body(),clean.body());\n  return clean;\n}\n\n",
    "original": ""
  },
  "Time-2": {
    "buggy": "",
    "fix": "/** \n * Always returns zero, indicating that sort order is not relevent.\n * @return zero always\n */\npublic int compareTo(DurationField durationField){\n  if (durationField.isSupported()) {\n    return 1;\n  }\n  return 0;\n}\n\n/** \n * Constructs a Partial with the specified fields and values. The fields must be specified in the order largest to smallest. \u003cp\u003e The constructor uses the specified chronology.\n * @param types  the types to create the partial from, not null\n * @param values  the values to store, not null\n * @param chronology  the chronology, null means ISO\n * @throws IllegalArgumentException if the types or values are invalid\n */\npublic Partial(DateTimeFieldType[] types,int[] values,Chronology chronology){\n  super();\n  chronology\u003dDateTimeUtils.getChronology(chronology).withUTC();\n  iChronology\u003dchronology;\n  if (types \u003d\u003d null) {\n    throw new IllegalArgumentException(\"Types array must not be null\");\n  }\n  if (values \u003d\u003d null) {\n    throw new IllegalArgumentException(\"Values array must not be null\");\n  }\n  if (values.length !\u003d types.length) {\n    throw new IllegalArgumentException(\"Values array must be the same length as the types array\");\n  }\n  if (types.length \u003d\u003d 0) {\n    iTypes\u003dtypes;\n    iValues\u003dvalues;\n    return;\n  }\n  for (int i\u003d0; i \u003c types.length; i++) {\n    if (types[i] \u003d\u003d null) {\n      throw new IllegalArgumentException(\"Types array must not contain null: index \" + i);\n    }\n  }\n  DurationField lastUnitField\u003dnull;\n  for (int i\u003d0; i \u003c types.length; i++) {\n    DateTimeFieldType loopType\u003dtypes[i];\n    DurationField loopUnitField\u003dloopType.getDurationType().getField(iChronology);\n    if (i \u003e 0) {\n      int compare\u003dlastUnitField.compareTo(loopUnitField);\n      if (compare \u003c 0 || (compare !\u003d 0 \u0026\u0026 loopUnitField.isSupported() \u003d\u003d false)) {\n        throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" + types[i - 1].getName() + \" \u003c \"+ loopType.getName());\n      }\n else       if (compare \u003d\u003d 0) {\n        if (types[i - 1].getRangeDurationType() \u003d\u003d null) {\n          if (loopType.getRangeDurationType() \u003d\u003d null) {\n            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" + loopType.getName());\n          }\n        }\n else {\n          if (loopType.getRangeDurationType() \u003d\u003d null) {\n            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" + types[i - 1].getName() + \" \u003c \"+ loopType.getName());\n          }\n          DurationField lastRangeField\u003dtypes[i - 1].getRangeDurationType().getField(iChronology);\n          DurationField loopRangeField\u003dloopType.getRangeDurationType().getField(iChronology);\n          if (lastRangeField.compareTo(loopRangeField) \u003c 0) {\n            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" + types[i - 1].getName() + \" \u003c \"+ loopType.getName());\n          }\n          if (lastRangeField.compareTo(loopRangeField) \u003d\u003d 0) {\n            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" + loopType.getName());\n          }\n        }\n      }\n    }\n    lastUnitField\u003dloopUnitField;\n  }\n  iTypes\u003d(DateTimeFieldType[])types.clone();\n  chronology.validate(this,values);\n  iValues\u003d(int[])values.clone();\n}\n\n",
    "original": ""
  },
  "Codec-6": {
    "buggy": "",
    "fix": "/** \n * Attempts to read \u003ccode\u003elen\u003c/code\u003e bytes into the specified \u003ccode\u003eb\u003c/code\u003e array starting at \u003ccode\u003eoffset\u003c/code\u003e from this InputStream.\n * @throws IOException if an I/O error occurs.\n */\npublic int read(byte b[],int offset,int len) throws IOException {\n  if (b \u003d\u003d null) {\n    throw new NullPointerException();\n  }\n else   if (offset \u003c 0 || len \u003c 0) {\n    throw new IndexOutOfBoundsException();\n  }\n else   if (offset \u003e b.length || offset + len \u003e b.length) {\n    throw new IndexOutOfBoundsException();\n  }\n else   if (len \u003d\u003d 0) {\n    return 0;\n  }\n else {\n    int readLen\u003d0;\n    while (readLen \u003d\u003d 0) {\n      if (!base64.hasData()) {\n        byte[] buf\u003dnew byte[doEncode ? 4096 : 8192];\n        int c\u003din.read(buf);\n        if (c \u003e 0 \u0026\u0026 b.length \u003d\u003d len) {\n          base64.setInitialBuffer(b,offset,len);\n        }\n        if (doEncode) {\n          base64.encode(buf,0,c);\n        }\n else {\n          base64.decode(buf,0,c);\n        }\n      }\n      readLen\u003dbase64.readResults(b,offset,len);\n    }\n    return readLen;\n  }\n}\n\n",
    "original": ""
  },
  "Time-5": {
    "buggy": "/** \n * Normalizes this period using standard rules, assuming a 12 month year, 7 day week, 24 hour day, 60 minute hour and 60 second minute, providing control over how the result is split into fields. \u003cp\u003e This method allows you to normalize a period. However to achieve this it makes the assumption that all years are 12 months, all weeks are 7 days, all days are 24 hours, all hours are 60 minutes and all minutes are 60 seconds. This is not true when daylight savings time is considered, and may also not be true for some chronologies. However, it is included as it is a useful operation for many applications and business rules. \u003cp\u003e If the period contains years or months, then the months will be normalized to be between 0 and 11. The days field and below will be normalized as necessary, however this will not overflow into the months field. Thus a period of 1 year 15 months will normalize to 2 years 3 months. But a period of 1 month 40 days will remain as 1 month 40 days. \u003cp\u003e The PeriodType parameter controls how the result is created. It allows you to omit certain fields from the result if desired. For example, you may not want the result to include weeks, in which case you pass in \u003ccode\u003ePeriodType.yearMonthDayTime()\u003c/code\u003e.\n * @param type  the period type of the new period, null means standard type\n * @return a normalized period equivalent to this period\n * @throws ArithmeticException if any field is too large to be represented\n * @throws UnsupportedOperationException if this period contains non-zeroyears or months but the specified period type does not support them\n * @since 1.5\n */\npublic Period normalizedStandard(PeriodType type){\n  long millis\u003dgetMillis();\n  millis+\u003d(((long)getSeconds()) * ((long)DateTimeConstants.MILLIS_PER_SECOND));\n  millis+\u003d(((long)getMinutes()) * ((long)DateTimeConstants.MILLIS_PER_MINUTE));\n  millis+\u003d(((long)getHours()) * ((long)DateTimeConstants.MILLIS_PER_HOUR));\n  millis+\u003d(((long)getDays()) * ((long)DateTimeConstants.MILLIS_PER_DAY));\n  millis+\u003d(((long)getWeeks()) * ((long)DateTimeConstants.MILLIS_PER_WEEK));\n  Period result\u003dnew Period(millis,DateTimeUtils.getPeriodType(type),ISOChronology.getInstanceUTC());\n  int years\u003dgetYears();\n  int months\u003dgetMonths();\n  if (years !\u003d 0 || months !\u003d 0) {\n    years\u003dFieldUtils.safeAdd(years,months / 12);\n    months\u003dmonths % 12;\n    if (years !\u003d 0) {\n      result\u003dresult.withYears(years);\n    }\n    if (months !\u003d 0) {\n      result\u003dresult.withMonths(months);\n    }\n  }\n  return result;\n}\n\n",
    "fix": "/** \n * Normalizes this period using standard rules, assuming a 12 month year, 7 day week, 24 hour day, 60 minute hour and 60 second minute, providing control over how the result is split into fields. \u003cp\u003e This method allows you to normalize a period. However to achieve this it makes the assumption that all years are 12 months, all weeks are 7 days, all days are 24 hours, all hours are 60 minutes and all minutes are 60 seconds. This is not true when daylight savings time is considered, and may also not be true for some chronologies. However, it is included as it is a useful operation for many applications and business rules. \u003cp\u003e If the period contains years or months, then the months will be normalized to be between 0 and 11. The days field and below will be normalized as necessary, however this will not overflow into the months field. Thus a period of 1 year 15 months will normalize to 2 years 3 months. But a period of 1 month 40 days will remain as 1 month 40 days. \u003cp\u003e The PeriodType parameter controls how the result is created. It allows you to omit certain fields from the result if desired. For example, you may not want the result to include weeks, in which case you pass in \u003ccode\u003ePeriodType.yearMonthDayTime()\u003c/code\u003e.\n * @param type  the period type of the new period, null means standard type\n * @return a normalized period equivalent to this period\n * @throws ArithmeticException if any field is too large to be represented\n * @throws UnsupportedOperationException if this period contains non-zeroyears or months but the specified period type does not support them\n * @since 1.5\n */\npublic Period normalizedStandard(PeriodType type){\n  type\u003dDateTimeUtils.getPeriodType(type);\n  long millis\u003dgetMillis();\n  millis+\u003d(((long)getSeconds()) * ((long)DateTimeConstants.MILLIS_PER_SECOND));\n  millis+\u003d(((long)getMinutes()) * ((long)DateTimeConstants.MILLIS_PER_MINUTE));\n  millis+\u003d(((long)getHours()) * ((long)DateTimeConstants.MILLIS_PER_HOUR));\n  millis+\u003d(((long)getDays()) * ((long)DateTimeConstants.MILLIS_PER_DAY));\n  millis+\u003d(((long)getWeeks()) * ((long)DateTimeConstants.MILLIS_PER_WEEK));\n  Period result\u003dnew Period(millis,type,ISOChronology.getInstanceUTC());\n  int years\u003dgetYears();\n  int months\u003dgetMonths();\n  if (years !\u003d 0 || months !\u003d 0) {\n    long totalMonths\u003dyears * 12L + months;\n    if (type.isSupported(DurationFieldType.YEARS_TYPE)) {\n      int normalizedYears\u003dFieldUtils.safeToInt(totalMonths / 12);\n      result\u003dresult.withYears(normalizedYears);\n      totalMonths\u003dtotalMonths - (normalizedYears * 12);\n    }\n    if (type.isSupported(DurationFieldType.MONTHS_TYPE)) {\n      int normalizedMonths\u003dFieldUtils.safeToInt(totalMonths);\n      result\u003dresult.withYears(normalizedMonths);\n      totalMonths\u003dtotalMonths - normalizedMonths;\n    }\n    if (totalMonths !\u003d 0) {\n      throw new UnsupportedOperationException(\"Unable to normalize as PeriodType is missing either years or months but period has a month/year amount: \" + toString());\n    }\n  }\n  return result;\n}\n\n",
    "original": ""
  },
  "Mockito-11": {
    "buggy": "@Override public boolean equals(Object obj){\n  return method.equals(obj);\n}\n\n",
    "fix": "@Override public boolean equals(Object obj){\n  if (this \u003d\u003d obj) {\n    return true;\n  }\n  if (obj instanceof DelegatingMethod) {\n    DelegatingMethod that\u003d(DelegatingMethod)obj;\n    return method.equals(that.method);\n  }\n  return method.equals(obj);\n}\n\n",
    "original": ""
  },
  "Closure-91": {
    "buggy": "/** \n * Since this pass reports errors only when a global  {@code this} keywordis encountered, there is no reason to traverse non global contexts.\n */\npublic boolean shouldTraverse(NodeTraversal t,Node n,Node parent){\n  if (n.getType() \u003d\u003d Token.FUNCTION) {\n    JSDocInfo jsDoc\u003dgetFunctionJsDocInfo(n);\n    if (jsDoc !\u003d null \u0026\u0026 (jsDoc.isConstructor() || jsDoc.isInterface() || jsDoc.hasThisType()|| jsDoc.isOverride())) {\n      return false;\n    }\n    int pType\u003dparent.getType();\n    if (!(pType \u003d\u003d Token.BLOCK || pType \u003d\u003d Token.SCRIPT || pType \u003d\u003d Token.NAME || pType \u003d\u003d Token.ASSIGN || pType \u003d\u003d Token.OBJECTLIT)) {\n      return false;\n    }\n  }\n  if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.ASSIGN) {\n    Node lhs\u003dparent.getFirstChild();\n    Node rhs\u003dlhs.getNext();\n    if (n \u003d\u003d lhs) {\n      if (assignLhsChild \u003d\u003d null) {\n        assignLhsChild\u003dlhs;\n      }\n    }\n else {\n      if (NodeUtil.isGet(lhs)) {\n        if (lhs.getType() \u003d\u003d Token.GETPROP \u0026\u0026 lhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n        Node llhs\u003dlhs.getFirstChild();\n        if (llhs.getType() \u003d\u003d Token.GETPROP \u0026\u0026 llhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n",
    "fix": "/** \n * Since this pass reports errors only when a global  {@code this} keywordis encountered, there is no reason to traverse non global contexts.\n */\npublic boolean shouldTraverse(NodeTraversal t,Node n,Node parent){\n  if (n.getType() \u003d\u003d Token.FUNCTION) {\n    JSDocInfo jsDoc\u003dgetFunctionJsDocInfo(n);\n    if (jsDoc !\u003d null \u0026\u0026 (jsDoc.isConstructor() || jsDoc.isInterface() || jsDoc.hasThisType()|| jsDoc.isOverride())) {\n      return false;\n    }\n    int pType\u003dparent.getType();\n    if (!(pType \u003d\u003d Token.BLOCK || pType \u003d\u003d Token.SCRIPT || pType \u003d\u003d Token.NAME || pType \u003d\u003d Token.ASSIGN || pType \u003d\u003d Token.STRING || pType \u003d\u003d Token.NUMBER)) {\n      return false;\n    }\n    Node gramps\u003dparent.getParent();\n    if (NodeUtil.isObjectLitKey(parent,gramps)) {\n      if (gramps.getType() \u003d\u003d Token.GETPROP \u0026\u0026 gramps.getLastChild().getString().equals(\"prototype\")) {\n        return false;\n      }\n    }\n  }\n  if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.ASSIGN) {\n    Node lhs\u003dparent.getFirstChild();\n    Node rhs\u003dlhs.getNext();\n    if (n \u003d\u003d lhs) {\n      if (assignLhsChild \u003d\u003d null) {\n        assignLhsChild\u003dlhs;\n      }\n    }\n else {\n      if (NodeUtil.isGet(lhs)) {\n        if (lhs.getType() \u003d\u003d Token.GETPROP \u0026\u0026 lhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n        Node llhs\u003dlhs.getFirstChild();\n        if (llhs.getType() \u003d\u003d Token.GETPROP \u0026\u0026 llhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n",
    "original": "/** \n * Since this pass reports errors only when a global  {@code this} keywordis encountered, there is no reason to traverse non global contexts.\n */\npublic boolean shouldTraverse(NodeTraversal t,Node n,Node parent){\n  if (n.getType() \u003d\u003d Token.FUNCTION) {\n    JSDocInfo jsDoc\u003dgetFunctionJsDocInfo(n);\n    if (jsDoc !\u003d null \u0026\u0026 (jsDoc.isConstructor() || jsDoc.isInterface() || jsDoc.hasThisType()|| jsDoc.isOverride())) {\n      return false;\n    }\n    int pType\u003dparent.getType();\n    if (!(pType \u003d\u003d Token.BLOCK || pType \u003d\u003d Token.SCRIPT || pType \u003d\u003d Token.NAME || pType \u003d\u003d Token.ASSIGN)) {\n      return false;\n    }\n  }\n  if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.ASSIGN) {\n    Node lhs\u003dparent.getFirstChild();\n    Node rhs\u003dlhs.getNext();\n    if (n \u003d\u003d lhs) {\n      if (assignLhsChild \u003d\u003d null) {\n        assignLhsChild\u003dlhs;\n      }\n    }\n else {\n      if (NodeUtil.isGet(lhs)) {\n        if (lhs.getType() \u003d\u003d Token.GETPROP \u0026\u0026 lhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n        Node llhs\u003dlhs.getFirstChild();\n        if (llhs.getType() \u003d\u003d Token.GETPROP \u0026\u0026 llhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n"
  },
  "Closure-12": {
    "buggy": "",
    "fix": "@Override ReachingUses flowThrough(Node n,ReachingUses input){\n  ReachingUses output\u003dnew ReachingUses(input);\n  boolean conditional\u003dfalse;\n  List\u003cDiGraphEdge\u003cNode,Branch\u003e\u003e branchEdges\u003dgetCfg().getOutEdges(n);\n  for (  DiGraphEdge\u003cNode,Branch\u003e edge : branchEdges) {\n    if (edge.getValue() \u003d\u003d Branch.ON_EX) {\n      conditional\u003dtrue;\n    }\n  }\n  computeMayUse(n,n,output,conditional);\n  return output;\n}\n\n",
    "original": ""
  },
  "Math-26": {
    "buggy": "/** \n * Create a fraction given the double value and either the maximum error allowed or the maximum number of denominator digits. \u003cp\u003e NOTE: This constructor is called with EITHER - a valid epsilon value and the maxDenominator set to Integer.MAX_VALUE (that way the maxDenominator has no effect). OR - a valid maxDenominator value and the epsilon value set to zero (that way epsilon only has effect if there is an exact match before the maxDenominator value is reached). \u003cp\u003e It has been done this way so that the same code can be (re)used for both scenarios. However this could be confusing to users if it were part of the public API and this constructor should therefore remain PRIVATE. \u003c/p\u003e See JIRA issue ticket MATH-181 for more details: https://issues.apache.org/jira/browse/MATH-181\n * @param value the double value to convert to a fraction.\n * @param epsilon maximum error allowed.  The resulting fraction is within\u003ccode\u003eepsilon\u003c/code\u003e of \u003ccode\u003evalue\u003c/code\u003e, in absolute terms.\n * @param maxDenominator maximum denominator value allowed.\n * @param maxIterations maximum number of convergents\n * @throws FractionConversionException if the continued fraction failed toconverge.\n */\nprivate Fraction(double value,double epsilon,int maxDenominator,int maxIterations) throws FractionConversionException {\n  long overflow\u003dInteger.MAX_VALUE;\n  double r0\u003dvalue;\n  long a0\u003d(long)Math.floor(r0);\n  if (a0 \u003e overflow) {\n    throw new FractionConversionException(value,a0,1l);\n  }\n  if (Math.abs(a0 - value) \u003c epsilon) {\n    this.numerator\u003d(int)a0;\n    this.denominator\u003d1;\n    return;\n  }\n  long p0\u003d1;\n  long q0\u003d0;\n  long p1\u003da0;\n  long q1\u003d1;\n  long p2\u003d0;\n  long q2\u003d1;\n  int n\u003d0;\n  boolean stop\u003dfalse;\n  do {\n    ++n;\n    double r1\u003d1.0 / (r0 - a0);\n    long a1\u003d(long)Math.floor(r1);\n    p2\u003d(a1 * p1) + p0;\n    q2\u003d(a1 * q1) + q0;\n    if ((p2 \u003e overflow) || (q2 \u003e overflow)) {\n      throw new FractionConversionException(value,p2,q2);\n    }\n    double convergent\u003d(double)p2 / (double)q2;\n    if (n \u003c maxIterations \u0026\u0026 Math.abs(convergent - value) \u003e epsilon \u0026\u0026 q2 \u003c maxDenominator) {\n      p0\u003dp1;\n      p1\u003dp2;\n      q0\u003dq1;\n      q1\u003dq2;\n      a0\u003da1;\n      r0\u003dr1;\n    }\n else {\n      stop\u003dtrue;\n    }\n  }\n while (!stop);\n  if (n \u003e\u003d maxIterations) {\n    throw new FractionConversionException(value,maxIterations);\n  }\n  if (q2 \u003c maxDenominator) {\n    this.numerator\u003d(int)p2;\n    this.denominator\u003d(int)q2;\n  }\n else {\n    this.numerator\u003d(int)p1;\n    this.denominator\u003d(int)q1;\n  }\n}\n\n",
    "fix": "/** \n * Create a fraction given the double value and either the maximum error allowed or the maximum number of denominator digits. \u003cp\u003e NOTE: This constructor is called with EITHER - a valid epsilon value and the maxDenominator set to Integer.MAX_VALUE (that way the maxDenominator has no effect). OR - a valid maxDenominator value and the epsilon value set to zero (that way epsilon only has effect if there is an exact match before the maxDenominator value is reached). \u003cp\u003e It has been done this way so that the same code can be (re)used for both scenarios. However this could be confusing to users if it were part of the public API and this constructor should therefore remain PRIVATE. \u003c/p\u003e See JIRA issue ticket MATH-181 for more details: https://issues.apache.org/jira/browse/MATH-181\n * @param value the double value to convert to a fraction.\n * @param epsilon maximum error allowed.  The resulting fraction is within\u003ccode\u003eepsilon\u003c/code\u003e of \u003ccode\u003evalue\u003c/code\u003e, in absolute terms.\n * @param maxDenominator maximum denominator value allowed.\n * @param maxIterations maximum number of convergents\n * @throws FractionConversionException if the continued fraction failed toconverge.\n */\nprivate Fraction(double value,double epsilon,int maxDenominator,int maxIterations) throws FractionConversionException {\n  double r0\u003dvalue;\n  int a0\u003d(int)Math.floor(r0);\n  if (Math.abs(a0) \u003e Integer.MAX_VALUE) {\n    throw new FractionConversionException(value,a0);\n  }\n  if (Math.abs(a0 - value) \u003c epsilon) {\n    this.numerator\u003da0;\n    this.denominator\u003d1;\n    return;\n  }\n  int p0\u003d1;\n  int q0\u003d0;\n  int p1\u003da0;\n  int q1\u003d1;\n  int p2\u003d0;\n  int q2\u003d1;\n  int n\u003d0;\n  boolean stop\u003dfalse;\n  do {\n    ++n;\n    double r1\u003d1.0 / (r0 - a0);\n    int a1\u003d(int)Math.floor(r1);\n    p2\u003d(a1 * p1) + p0;\n    q2\u003d(a1 * q1) + q0;\n    if ((Math.abs(p2) \u003e Integer.MAX_VALUE) || (Math.abs(q2) \u003e Integer.MAX_VALUE)) {\n      throw new FractionConversionException(p2,q2);\n    }\n    double convergent\u003d(double)p2 / (double)q2;\n    if (n \u003c maxIterations \u0026\u0026 Math.abs(convergent - value) \u003e epsilon \u0026\u0026 q2 \u003c maxDenominator) {\n      p0\u003dp1;\n      p1\u003dp2;\n      q0\u003dq1;\n      q1\u003dq2;\n      a0\u003da1;\n      r0\u003dr1;\n    }\n else {\n      stop\u003dtrue;\n    }\n  }\n while (!stop);\n  if (n \u003e\u003d maxIterations) {\n    throw new FractionConversionException(value,maxIterations);\n  }\n  if (q2 \u003c maxDenominator) {\n    this.numerator\u003dp2;\n    this.denominator\u003dq2;\n  }\n else {\n    this.numerator\u003dp1;\n    this.denominator\u003dq1;\n  }\n  reduce();\n}\n\n",
    "original": "/** \n * Create a fraction given the double value. \u003cp\u003e References: \u003cul\u003e \u003cli\u003e\u003ca href\u003d\"http://mathworld.wolfram.com/ContinuedFraction.html\"\u003e Continued Fraction\u003c/a\u003e equations (11) and (22)-(26)\u003c/li\u003e \u003c/ul\u003e \u003c/p\u003e\n * @param value the double value to convert to a fraction.\n * @param epsilon maximum error allowed.  The resulting fraction is within\u003ccode\u003eepsilon\u003c/code\u003e of \u003ccode\u003evalue\u003c/code\u003e, in absolute terms.\n * @param maxIterations maximum number of convergents\n * @throws FractionConversionException if the continued fraction failed toconverge.\n */\npublic Fraction(double value,double epsilon,int maxIterations) throws FractionConversionException {\n  double r0\u003dvalue;\n  int a0\u003d(int)Math.floor(r0);\n  if (Math.abs(a0 - value) \u003c epsilon) {\n    this.numerator\u003da0;\n    this.denominator\u003d1;\n    return;\n  }\n  int p0\u003d1;\n  int q0\u003d0;\n  int p1\u003da0;\n  int q1\u003d1;\n  int p2\u003d0;\n  int q2\u003d1;\n  int n\u003d0;\n  boolean stop\u003dfalse;\n  do {\n    ++n;\n    double r1\u003d1.0 / (r0 - a0);\n    int a1\u003d(int)Math.floor(r1);\n    p2\u003d(a1 * p1) + p0;\n    q2\u003d(a1 * q1) + q0;\n    double convergent\u003d(double)p2 / (double)q2;\n    if (n \u003c maxIterations \u0026\u0026 Math.abs(convergent - value) \u003e epsilon) {\n      p0\u003dp1;\n      p1\u003dp2;\n      q0\u003dq1;\n      q1\u003dq2;\n      a0\u003da1;\n      r0\u003dr1;\n    }\n else {\n      stop\u003dtrue;\n    }\n  }\n while (!stop);\n  if (n \u003e\u003d maxIterations) {\n    throw new FractionConversionException(value,maxIterations);\n  }\n  this.numerator\u003dp2;\n  this.denominator\u003dq2;\n  reduce();\n}\n\n/** \n * Create a fraction given the numerator and denominator.  The fraction is reduced to lowest terms.\n * @param num the numerator.\n * @param den the denominator.\n * @throws ArithmeticException if the denomiator is \u003ccode\u003ezero\u003c/code\u003e\n */\npublic Fraction(int num,int den){\n  super();\n  if (den \u003d\u003d 0) {\n    throw new ArithmeticException(\"The denominator must not be zero\");\n  }\n  if (den \u003c 0) {\n    if (num \u003d\u003d Integer.MIN_VALUE || den \u003d\u003d Integer.MIN_VALUE) {\n      throw new ArithmeticException(\"overflow: can\u0027t negate\");\n    }\n    num\u003d-num;\n    den\u003d-den;\n  }\n  this.numerator\u003dnum;\n  this.denominator\u003dden;\n  reduce();\n}\n\n"
  },
  "Closure-75": {
    "buggy": "",
    "fix": "/** \n * Gets the value of a node as a Number, or null if it cannot be converted. When it returns a non-null Double, this method effectively emulates the \u003ccode\u003eNumber()\u003c/code\u003e JavaScript cast function.\n */\nstatic Double getNumberValue(Node n){\nswitch (n.getType()) {\ncase Token.TRUE:\n    return 1.0;\ncase Token.FALSE:\ncase Token.NULL:\n  return 0.0;\ncase Token.NUMBER:\nreturn n.getDouble();\ncase Token.VOID:\nif (mayHaveSideEffects(n.getFirstChild())) {\nreturn null;\n}\n else {\nreturn Double.NaN;\n}\ncase Token.NAME:\nString name\u003dn.getString();\nif (name.equals(\"undefined\")) {\nreturn Double.NaN;\n}\nif (name.equals(\"NaN\")) {\nreturn Double.NaN;\n}\nif (name.equals(\"Infinity\")) {\nreturn Double.POSITIVE_INFINITY;\n}\nreturn null;\ncase Token.NEG:\nif (n.getChildCount() \u003d\u003d 1 \u0026\u0026 n.getFirstChild().getType() \u003d\u003d Token.NAME \u0026\u0026 n.getFirstChild().getString().equals(\"Infinity\")) {\nreturn Double.NEGATIVE_INFINITY;\n}\nreturn null;\ncase Token.STRING:\nif (n.getString().contains(\"\\u000b\")) {\nreturn null;\n}\nString s\u003dtrimJsWhiteSpace(n.getString());\nif (s.length() \u003d\u003d 0) {\nreturn 0.0;\n}\nif (s.length() \u003e 2 \u0026\u0026 s.charAt(0) \u003d\u003d \u00270\u0027 \u0026\u0026 (s.charAt(1) \u003d\u003d \u0027x\u0027 || s.charAt(1) \u003d\u003d \u0027X\u0027)) {\ntry {\nreturn Double.valueOf(Integer.parseInt(s.substring(2),16));\n}\n catch (NumberFormatException e) {\nreturn Double.NaN;\n}\n}\nif (s.length() \u003e 3 \u0026\u0026 (s.charAt(0) \u003d\u003d \u0027-\u0027 || s.charAt(0) \u003d\u003d \u0027+\u0027) \u0026\u0026 s.charAt(1) \u003d\u003d \u00270\u0027 \u0026\u0026 (s.charAt(2) \u003d\u003d \u0027x\u0027 || s.charAt(2) \u003d\u003d \u0027X\u0027)) {\nreturn null;\n}\nif (s.equals(\"infinity\") || s.equals(\"-infinity\") || s.equals(\"+infinity\")) {\nreturn null;\n}\ntry {\nreturn Double.parseDouble(s);\n}\n catch (NumberFormatException e) {\nreturn Double.NaN;\n}\n}\nreturn null;\n}\n\n",
    "original": ""
  },
  "Closure-153": {
    "buggy": "@Override public void visit(NodeTraversal t,Node n,Node parent){\n  if (n.getType() \u003d\u003d Token.NAME) {\n    String name\u003dn.getString();\n    if (n.getString().isEmpty()) {\n      return;\n    }\n    boolean isConst\u003dn.getBooleanProp(Node.IS_CONSTANT_NAME);\n    if (checkUserDeclarations) {\n      boolean expectedConst\u003dfalse;\n      CodingConvention convention\u003dcompiler.getCodingConvention();\n      if (NodeUtil.isConstantName(n) || NodeUtil.isConstantByConvention(convention,n,parent)) {\n        expectedConst\u003dtrue;\n      }\n else {\n        expectedConst\u003dfalse;\n        JSDocInfo info\u003dnull;\n        Var var\u003dt.getScope().getVar(n.getString());\n        if (var !\u003d null) {\n          info\u003dvar.getJSDocInfo();\n        }\n        if (info !\u003d null \u0026\u0026 info.isConstant()) {\n          expectedConst\u003dtrue;\n        }\n else {\n          expectedConst\u003dfalse;\n        }\n      }\n      if (expectedConst) {\n        Preconditions.checkState(expectedConst \u003d\u003d isConst,\"The name \" + name + \" is not annotated as constant.\");\n      }\n else {\n        Preconditions.checkState(expectedConst \u003d\u003d isConst,\"The name \" + name + \" should not be annotated as constant.\");\n      }\n    }\n    Boolean value\u003dconstantMap.get(name);\n    if (value \u003d\u003d null) {\n      constantMap.put(name,isConst);\n    }\n else {\n      Preconditions.checkState(value.booleanValue() \u003d\u003d isConst,\"The name \" + name + \" is not consistently annotated as \"+ \"constant.\");\n    }\n  }\n}\n\n@Override public void process(Node externs,Node root){\n  NodeTraversal.traverse(compiler,root,new NormalizeStatements(compiler,assertOnChange));\n  if (MAKE_LOCAL_NAMES_UNIQUE) {\n    MakeDeclaredNamesUnique renamer\u003dnew MakeDeclaredNamesUnique();\n    NodeTraversal t\u003dnew NodeTraversal(compiler,renamer);\n    t.traverseRoots(externs,root);\n  }\n  removeDuplicateDeclarations(externs,root);\n  new PropogateConstantAnnotations(compiler,assertOnChange).process(externs,root);\n  compiler.setNormalized();\n}\n\n@Override public void visit(NodeTraversal t,Node n,Node parent){\n  if (n.getType() \u003d\u003d Token.NAME) {\n    if (n.getString().isEmpty()) {\n      return;\n    }\n    JSDocInfo info\u003dnull;\n    Var var\u003dt.getScope().getVar(n.getString());\n    if (var !\u003d null) {\n      info\u003dvar.getJSDocInfo();\n    }\n    if ((info !\u003d null \u0026\u0026 info.isConstant()) \u0026\u0026 !n.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n      n.putBooleanProp(Node.IS_CONSTANT_NAME,true);\n      if (assertOnChange) {\n        String name\u003dn.getString();\n        throw new IllegalStateException(\"Unexpected const change.\\n\" + \"  name: \" + name + \"\\n\"+ \"  gramps:\"+ n.getParent().getParent().toStringTree());\n      }\n    }\n  }\n}\n\nprivate void reportCodeChange(String changeDescription){\n  if (assertOnChange) {\n    throw new IllegalStateException(\"Normalize constraints violated:\\n\" + changeDescription);\n  }\n  compiler.reportCodeChange();\n}\n\n",
    "fix": "private void scanRoot(Node n,Scope parent){\n  if (n.getType() \u003d\u003d Token.FUNCTION) {\n    sourceName\u003d(String)n.getProp(Node.SOURCENAME_PROP);\n    final Node fnNameNode\u003dn.getFirstChild();\n    final Node args\u003dfnNameNode.getNext();\n    final Node body\u003dargs.getNext();\n    String fnName\u003dfnNameNode.getString();\n    if (!fnName.isEmpty() \u0026\u0026 NodeUtil.isFunctionExpression(n)) {\n      declareVar(fnNameNode);\n    }\n    Preconditions.checkState(args.getType() \u003d\u003d Token.LP);\n    for (Node a\u003dargs.getFirstChild(); a !\u003d null; a\u003da.getNext()) {\n      Preconditions.checkState(a.getType() \u003d\u003d Token.NAME);\n      declareVar(a);\n    }\n    scanVars(body,n);\n  }\n else {\n    Preconditions.checkState(scope.getParent() \u003d\u003d null);\n    scanVars(n,null);\n  }\n}\n\n@Override public void visit(NodeTraversal t,Node n,Node parent){\n  if (n.getType() \u003d\u003d Token.NAME) {\n    if (n.getString().isEmpty()) {\n      return;\n    }\n    JSDocInfo info\u003dnull;\n    Var var\u003dt.getScope().getVar(n.getString());\n    if (var !\u003d null) {\n      info\u003dvar.getJSDocInfo();\n    }\n    if ((info !\u003d null \u0026\u0026 info.isConstant()) \u0026\u0026 !n.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n      n.putBooleanProp(Node.IS_CONSTANT_NAME,true);\n      if (assertOnChange) {\n        String name\u003dn.getString();\n        throw new IllegalStateException(\"Unexpected const change.\\n\" + \"  name: \" + name + \"\\n\"+ \"  gramps:\"+ n.getParent().getParent().toStringTree());\n      }\n    }\n  }\n}\n\nvoid onRedeclaration(Scope s,String name,Node n,CompilerInput input);\n\n/** \n * Declares a variable.\n * @param name The variable name\n * @param n The node corresponding to the variable name (usually a NAME node)\n * @param parent The parent node of {@code n}\n * @param gramps The parent node of {@code parent}\n * @param declaredType The variable\u0027s type, according to JSDoc\n * @param nodeWithLineNumber The node to use to access the line number ofthe variable declaration, if needed\n */\nprivate void declareVar(Node n){\n  Preconditions.checkState(n.getType() \u003d\u003d Token.NAME);\n  CompilerInput input\u003dcompiler.getInput(sourceName);\n  String name\u003dn.getString();\n  if (scope.isDeclared(name,false) || (scope.isLocal() \u0026\u0026 name.equals(ARGUMENTS))) {\n    redeclarationHandler.onRedeclaration(scope,name,n,input);\n  }\n else {\n    scope.declare(name,n,null,input);\n  }\n}\n\nprivate void reportCodeChange(String changeDescription){\n  if (assertOnChange) {\n    throw new IllegalStateException(\"Normalize constraints violated:\\n\" + changeDescription);\n  }\n  compiler.reportCodeChange();\n}\n\n@Override public void visit(NodeTraversal t,Node n,Node parent){\n  if (n.getType() \u003d\u003d Token.NAME) {\n    String name\u003dn.getString();\n    if (n.getString().isEmpty()) {\n      return;\n    }\n    boolean isConst\u003dn.getBooleanProp(Node.IS_CONSTANT_NAME);\n    if (checkUserDeclarations) {\n      boolean expectedConst\u003dfalse;\n      CodingConvention convention\u003dcompiler.getCodingConvention();\n      if (NodeUtil.isConstantName(n) || NodeUtil.isConstantByConvention(convention,n,parent)) {\n        expectedConst\u003dtrue;\n      }\n else {\n        expectedConst\u003dfalse;\n        JSDocInfo info\u003dnull;\n        Var var\u003dt.getScope().getVar(n.getString());\n        if (var !\u003d null) {\n          info\u003dvar.getJSDocInfo();\n        }\n        if (info !\u003d null \u0026\u0026 info.isConstant()) {\n          expectedConst\u003dtrue;\n        }\n else {\n          expectedConst\u003dfalse;\n        }\n      }\n      if (expectedConst) {\n        Preconditions.checkState(expectedConst \u003d\u003d isConst,\"The name \" + name + \" is not annotated as constant.\");\n      }\n else {\n        Preconditions.checkState(expectedConst \u003d\u003d isConst,\"The name \" + name + \" should not be annotated as constant.\");\n      }\n    }\n    Boolean value\u003dconstantMap.get(name);\n    if (value \u003d\u003d null) {\n      constantMap.put(name,isConst);\n    }\n else {\n      Preconditions.checkState(value.booleanValue() \u003d\u003d isConst,\"The name \" + name + \" is not consistently annotated as \"+ \"constant.\");\n    }\n  }\n}\n\npublic void onRedeclaration(Scope s,String name,Node n,CompilerInput input){\n  Node parent\u003dn.getParent();\n  if (scope.isGlobal()) {\n    Scope.Var origVar\u003dscope.getVar(name);\n    Node origParent\u003dorigVar.getParentNode();\n    if (origParent.getType() \u003d\u003d Token.CATCH \u0026\u0026 parent.getType() \u003d\u003d Token.CATCH) {\n      return;\n    }\n    boolean allowDupe\u003dfalse;\n    JSDocInfo info\u003dn.getJSDocInfo();\n    if (info \u003d\u003d null) {\n      info\u003dparent.getJSDocInfo();\n    }\n    allowDupe\u003dinfo !\u003d null \u0026\u0026 info.getSuppressions().contains(\"duplicate\");\n    if (!allowDupe) {\n      compiler.report(JSError.make(sourceName,n,VAR_MULTIPLY_DECLARED_ERROR,name,(origVar.input !\u003d null ? origVar.input.getName() : \"??\")));\n    }\n  }\n else   if (name.equals(ARGUMENTS) \u0026\u0026 !NodeUtil.isVarDeclaration(n)) {\n    compiler.report(JSError.make(sourceName,n,VAR_ARGUMENTS_SHADOWED_ERROR));\n  }\n}\n\n/** \n * Remove duplicate VAR declarations encountered discovered during scope creation.\n */\n@Override public void onRedeclaration(Scope s,String name,Node n,CompilerInput input){\n  Preconditions.checkState(n.getType() \u003d\u003d Token.NAME);\n  Var v\u003ds.getVar(name);\n  Node parent\u003dn.getParent();\n  if (v !\u003d null \u0026\u0026 s.isGlobal()) {\n    if (v.isExtern() \u0026\u0026 !input.isExtern()) {\n      if (hasOkDuplicateDeclaration.add(v)) {\n        return;\n      }\n    }\n  }\n  if (v !\u003d null \u0026\u0026 v.getParentNode().getType() \u003d\u003d Token.CATCH) {\n    name\u003dMakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n    compiler.report(JSError.make(input.getName(),n,CATCH_BLOCK_VAR_ERROR,name));\n  }\n else   if (v !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION) {\n    if (v.getParentNode().getType() \u003d\u003d Token.VAR) {\n      s.undeclare(v);\n      s.declare(name,n,n.getJSType(),v.input);\n      replaceVarWithAssignment(v.getNameNode(),v.getParentNode(),v.getParentNode().getParent());\n    }\n  }\n else   if (parent.getType() \u003d\u003d Token.VAR) {\n    Preconditions.checkState(parent.hasOneChild());\n    replaceVarWithAssignment(n,parent,parent.getParent());\n  }\n}\n\n/** \n * Scans and gather variables declarations under a Node\n */\nprivate void scanVars(Node n,Node parent){\nswitch (n.getType()) {\ncase Token.VAR:\n    for (Node child\u003dn.getFirstChild(); child !\u003d null; ) {\n      Node next\u003dchild.getNext();\n      declareVar(child);\n      child\u003dnext;\n    }\n  return;\ncase Token.FUNCTION:\nif (NodeUtil.isFunctionExpression(n)) {\n  return;\n}\nString fnName\u003dn.getFirstChild().getString();\nif (fnName.isEmpty()) {\nreturn;\n}\ndeclareVar(n.getFirstChild());\nreturn;\ncase Token.CATCH:\nPreconditions.checkState(n.getChildCount() \u003d\u003d 3);\nPreconditions.checkState(n.getFirstChild().getType() \u003d\u003d Token.NAME);\nfinal Node var\u003dn.getFirstChild();\nfinal Node block\u003dvar.getNext().getNext();\ndeclareVar(var);\nscanVars(block,n);\nreturn;\ncase Token.SCRIPT:\nsourceName\u003d(String)n.getProp(Node.SOURCENAME_PROP);\nbreak;\n}\nif (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\nfor (Node child\u003dn.getFirstChild(); child !\u003d null; ) {\nNode next\u003dchild.getNext();\nscanVars(child,n);\nchild\u003dnext;\n}\n}\n}\n\nstatic Node parseAndNormalizeSyntheticCode(AbstractCompiler compiler,String code,String prefix){\n  Node js\u003dcompiler.parseSyntheticCode(code);\n  NodeTraversal.traverse(compiler,js,new Normalize.NormalizeStatements(compiler,false));\n  NodeTraversal.traverse(compiler,js,new MakeDeclaredNamesUnique(new BoilerplateRenamer(compiler.getUniqueNameIdSupplier(),prefix)));\n  return js;\n}\n\n@Override public void process(Node externs,Node root){\n  NodeTraversal.traverse(compiler,root,new NormalizeStatements(compiler,assertOnChange));\n  if (MAKE_LOCAL_NAMES_UNIQUE) {\n    MakeDeclaredNamesUnique renamer\u003dnew MakeDeclaredNamesUnique();\n    NodeTraversal t\u003dnew NodeTraversal(compiler,renamer);\n    t.traverseRoots(externs,root);\n  }\n  removeDuplicateDeclarations(externs,root);\n  new PropogateConstantAnnotations(compiler,assertOnChange).process(externs,root);\n  compiler.setNormalized();\n}\n\n",
    "original": "@Override public void visit(NodeTraversal t,Node n,Node parent){\n  if (n.getType() \u003d\u003d Token.NAME) {\n    String name\u003dn.getString();\n    if (n.getString().isEmpty()) {\n      return;\n    }\n    boolean isConst\u003dn.getBooleanProp(Node.IS_CONSTANT_NAME);\n    if (checkUserDeclarations) {\n      boolean expectedConst\u003dfalse;\n      CodingConvention convention\u003dcompiler.getCodingConvention();\n      if (NodeUtil.isConstantName(n) || NodeUtil.isConstantByConvention(convention,n,parent)) {\n        expectedConst\u003dtrue;\n      }\n else {\n        expectedConst\u003dfalse;\n        JSDocInfo info\u003dnull;\n        Var var\u003dt.getScope().getVar(n.getString());\n        if (var !\u003d null) {\n          info\u003dvar.getJSDocInfo();\n        }\n        if (info !\u003d null \u0026\u0026 info.isConstant()) {\n          expectedConst\u003dtrue;\n        }\n else {\n          expectedConst\u003dfalse;\n        }\n      }\n      if (expectedConst) {\n        Preconditions.checkState(expectedConst \u003d\u003d isConst,\"The name \" + name + \" is not annotated as constant.\");\n      }\n else {\n        Preconditions.checkState(expectedConst \u003d\u003d isConst,\"The name \" + name + \" should not be annotated as constant.\");\n      }\n    }\n    Boolean value\u003dconstantMap.get(name);\n    if (value \u003d\u003d null) {\n      constantMap.put(name,isConst);\n    }\n else {\n      Preconditions.checkState(value.booleanValue() \u003d\u003d isConst,\"The name \" + name + \" is not consistently annotated as \"+ \"constant.\");\n    }\n  }\n}\n\n@Override public void visit(NodeTraversal t,Node n,Node parent){\n  if (n.getType() !\u003d Token.NAME) {\n    return;\n  }\n  String varName\u003dn.getString();\n  if (varName.isEmpty()) {\n    Preconditions.checkState(NodeUtil.isFunction(parent));\n    if (!NodeUtil.isFunctionExpression(parent)) {\n      t.report(n,INVALID_FUNCTION_DECL);\n    }\n    return;\n  }\n  if ((parent.getType() \u003d\u003d Token.VAR || NodeUtil.isFunctionDeclaration(parent)) \u0026\u0026 varsToDeclareInExterns.contains(varName)) {\n    createSynthesizedExternVar(varName);\n    parent.addSuppression(\"duplicate\");\n  }\n  Scope scope\u003dt.getScope();\n  Scope.Var var\u003dscope.getVar(varName);\n  if (var \u003d\u003d null) {\n    if (NodeUtil.isFunctionExpression(parent)) {\n    }\n else {\n      if (!strictExternCheck || !t.getInput().isExtern()) {\n        t.report(n,UNDEFINED_VAR_ERROR,varName);\n      }\n      if (sanityCheck) {\n        throw new IllegalStateException(\"Unexpected variable \" + varName);\n      }\n else {\n        createSynthesizedExternVar(varName);\n        scope.getGlobalScope().declare(varName,n,null,getSynthesizedExternsInput());\n      }\n    }\n    return;\n  }\n  CompilerInput currInput\u003dt.getInput();\n  CompilerInput varInput\u003dvar.input;\n  if (currInput \u003d\u003d varInput || currInput \u003d\u003d null || varInput \u003d\u003d null) {\n    return;\n  }\n  JSModule currModule\u003dcurrInput.getModule();\n  JSModule varModule\u003dvarInput.getModule();\n  JSModuleGraph moduleGraph\u003dcompiler.getModuleGraph();\n  if (varModule !\u003d currModule \u0026\u0026 varModule !\u003d null \u0026\u0026 currModule !\u003d null) {\n    if (moduleGraph.dependsOn(currModule,varModule)) {\n    }\n else {\n      if (!sanityCheck \u0026\u0026 scope.isGlobal()) {\n        if (moduleGraph.dependsOn(varModule,currModule)) {\n          t.report(n,VIOLATED_MODULE_DEP_ERROR,currModule.getName(),varModule.getName(),varName);\n        }\n else {\n          t.report(n,MISSING_MODULE_DEP_ERROR,currModule.getName(),varModule.getName(),varName);\n        }\n      }\n else {\n        t.report(n,STRICT_MODULE_DEP_ERROR,currModule.getName(),varModule.getName(),varName);\n      }\n    }\n  }\n}\n\nprivate void reportCodeChange(String changeDescription){\n  if (assertOnChange) {\n    throw new IllegalStateException(\"Normalize constraints violated:\\n\" + changeDescription);\n  }\n  compiler.reportCodeChange();\n}\n\n!org.eclipse.jdt.core.dom.MethodDeclaration@478e9acb\n@Override public void process(Node externs,Node root){\n  NodeTraversal.traverse(compiler,root,new NormalizeStatements(compiler,assertOnChange));\n  if (MAKE_LOCAL_NAMES_UNIQUE) {\n    MakeDeclaredNamesUnique renamer\u003dnew MakeDeclaredNamesUnique();\n    NodeTraversal t\u003dnew NodeTraversal(compiler,renamer);\n    t.traverseRoots(externs,root);\n  }\n  removeDuplicateDeclarations(root);\n  new PropogateConstantAnnotations(compiler,assertOnChange).process(externs,root);\n  compiler.setNormalized();\n}\n\n@Override public void process(Node externs,Node root){\n  NodeTraversal.traverse(compiler,externs,new NameRefInExternsCheck());\n  NodeTraversal.traverseRoots(compiler,Lists.newArrayList(externs,root),this);\n  for (  String varName : varsToDeclareInExterns) {\n    createSynthesizedExternVar(varName);\n  }\n}\n\n"
  },
  "Math-28": {
    "buggy": "/** \n * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n * @param tableau simple tableau for the problem\n * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n * @return row with the minimum ratio\n */\nprivate Integer getPivotRow(SimplexTableau tableau,final int col){\n  List\u003cInteger\u003e minRatioPositions\u003dnew ArrayList\u003cInteger\u003e();\n  double minRatio\u003dDouble.MAX_VALUE;\n  for (int i\u003dtableau.getNumObjectiveFunctions(); i \u003c tableau.getHeight(); i++) {\n    final double rhs\u003dtableau.getEntry(i,tableau.getWidth() - 1);\n    final double entry\u003dtableau.getEntry(i,col);\n    if (Precision.compareTo(entry,0d,maxUlps) \u003e 0) {\n      final double ratio\u003drhs / entry;\n      final int cmp\u003dDouble.compare(ratio,minRatio);\n      if (cmp \u003d\u003d 0) {\n        minRatioPositions.add(i);\n      }\n else       if (cmp \u003c 0) {\n        minRatio\u003dratio;\n        minRatioPositions\u003dnew ArrayList\u003cInteger\u003e();\n        minRatioPositions.add(i);\n      }\n    }\n  }\n  if (minRatioPositions.size() \u003d\u003d 0) {\n    return null;\n  }\n else   if (minRatioPositions.size() \u003e 1) {\n    for (    Integer row : minRatioPositions) {\n      for (int i\u003d0; i \u003c tableau.getNumArtificialVariables(); i++) {\n        int column\u003di + tableau.getArtificialVariableOffset();\n        final double entry\u003dtableau.getEntry(row,column);\n        if (Precision.equals(entry,1d,maxUlps) \u0026\u0026 row.equals(tableau.getBasicRow(column))) {\n          return row;\n        }\n      }\n    }\n    Integer minRow\u003dnull;\n    int minIndex\u003dtableau.getWidth();\n    for (    Integer row : minRatioPositions) {\n      for (int i\u003dtableau.getNumObjectiveFunctions(); i \u003c tableau.getWidth() - 1 \u0026\u0026 minRow !\u003d row; i++) {\n        if (row \u003d\u003d tableau.getBasicRow(i)) {\n          if (i \u003c minIndex) {\n            minIndex\u003di;\n            minRow\u003drow;\n          }\n        }\n      }\n    }\n    return minRow;\n  }\n  return minRatioPositions.get(0);\n}\n\n/** \n * Build a tableau for a linear problem.\n * @param f linear objective function\n * @param constraints linear constraints\n * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}or  {@link GoalType#MINIMIZE}\n * @param restrictToNonNegative whether to restrict the variables to non-negative values\n * @param epsilon amount of error to accept when checking for optimality\n */\nSimplexTableau(final LinearObjectiveFunction f,final Collection\u003cLinearConstraint\u003e constraints,final GoalType goalType,final boolean restrictToNonNegative,final double epsilon){\n  this(f,constraints,goalType,restrictToNonNegative,epsilon,DEFAULT_ULPS);\n}\n\n/** \n * Build a tableau for a linear problem.\n * @param f linear objective function\n * @param constraints linear constraints\n * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}or  {@link GoalType#MINIMIZE}\n * @param restrictToNonNegative whether to restrict the variables to non-negative values\n * @param epsilon amount of error to accept when checking for optimality\n * @param maxUlps amount of error to accept in floating point comparisons\n */\nSimplexTableau(final LinearObjectiveFunction f,final Collection\u003cLinearConstraint\u003e constraints,final GoalType goalType,final boolean restrictToNonNegative,final double epsilon,final int maxUlps){\n  this.f\u003df;\n  this.constraints\u003dnormalizeConstraints(constraints);\n  this.restrictToNonNegative\u003drestrictToNonNegative;\n  this.epsilon\u003depsilon;\n  this.maxUlps\u003dmaxUlps;\n  this.numDecisionVariables\u003df.getCoefficients().getDimension() + (restrictToNonNegative ? 0 : 1);\n  this.numSlackVariables\u003dgetConstraintTypeCounts(Relationship.LEQ) + getConstraintTypeCounts(Relationship.GEQ);\n  this.numArtificialVariables\u003dgetConstraintTypeCounts(Relationship.EQ) + getConstraintTypeCounts(Relationship.GEQ);\n  this.tableau\u003dcreateTableau(goalType \u003d\u003d GoalType.MAXIMIZE);\n  initializeColumnLabels();\n}\n\n",
    "fix": "/** \n * Build a tableau for a linear problem.\n * @param f linear objective function\n * @param constraints linear constraints\n * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}or  {@link GoalType#MINIMIZE}\n * @param restrictToNonNegative whether to restrict the variables to non-negative values\n * @param epsilon amount of error to accept when checking for optimality\n * @param maxUlps amount of error to accept in floating point comparisons\n */\nSimplexTableau(final LinearObjectiveFunction f,final Collection\u003cLinearConstraint\u003e constraints,final GoalType goalType,final boolean restrictToNonNegative,final double epsilon,final int maxUlps){\n  this.f\u003df;\n  this.constraints\u003dnormalizeConstraints(constraints);\n  this.restrictToNonNegative\u003drestrictToNonNegative;\n  this.epsilon\u003depsilon;\n  this.maxUlps\u003dmaxUlps;\n  this.numDecisionVariables\u003df.getCoefficients().getDimension() + (restrictToNonNegative ? 0 : 1);\n  this.numSlackVariables\u003dgetConstraintTypeCounts(Relationship.LEQ) + getConstraintTypeCounts(Relationship.GEQ);\n  this.numArtificialVariables\u003dgetConstraintTypeCounts(Relationship.EQ) + getConstraintTypeCounts(Relationship.GEQ);\n  this.tableau\u003dcreateTableau(goalType \u003d\u003d GoalType.MAXIMIZE);\n  initializeColumnLabels();\n}\n\n/** \n * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n * @param tableau simple tableau for the problem\n * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n * @return row with the minimum ratio\n */\nprivate Integer getPivotRow(SimplexTableau tableau,final int col){\n  List\u003cInteger\u003e minRatioPositions\u003dnew ArrayList\u003cInteger\u003e();\n  double minRatio\u003dDouble.MAX_VALUE;\n  for (int i\u003dtableau.getNumObjectiveFunctions(); i \u003c tableau.getHeight(); i++) {\n    final double rhs\u003dtableau.getEntry(i,tableau.getWidth() - 1);\n    final double entry\u003dtableau.getEntry(i,col);\n    if (Precision.compareTo(entry,0d,maxUlps) \u003e 0) {\n      final double ratio\u003drhs / entry;\n      final int cmp\u003dDouble.compare(ratio,minRatio);\n      if (cmp \u003d\u003d 0) {\n        minRatioPositions.add(i);\n      }\n else       if (cmp \u003c 0) {\n        minRatio\u003dratio;\n        minRatioPositions\u003dnew ArrayList\u003cInteger\u003e();\n        minRatioPositions.add(i);\n      }\n    }\n  }\n  if (minRatioPositions.size() \u003d\u003d 0) {\n    return null;\n  }\n else   if (minRatioPositions.size() \u003e 1) {\n    for (    Integer row : minRatioPositions) {\n      for (int i\u003d0; i \u003c tableau.getNumArtificialVariables(); i++) {\n        int column\u003di + tableau.getArtificialVariableOffset();\n        final double entry\u003dtableau.getEntry(row,column);\n        if (Precision.equals(entry,1d,maxUlps) \u0026\u0026 row.equals(tableau.getBasicRow(column))) {\n          return row;\n        }\n      }\n    }\n    if (getIterations() \u003c getMaxIterations() / 2) {\n      Integer minRow\u003dnull;\n      int minIndex\u003dtableau.getWidth();\n      for (      Integer row : minRatioPositions) {\n        for (int i\u003dtableau.getNumObjectiveFunctions(); i \u003c tableau.getWidth() - 1 \u0026\u0026 minRow !\u003d row; i++) {\n          if (row \u003d\u003d tableau.getBasicRow(i)) {\n            if (i \u003c minIndex) {\n              minIndex\u003di;\n              minRow\u003drow;\n            }\n          }\n        }\n      }\n      return minRow;\n    }\n  }\n  return minRatioPositions.get(0);\n}\n\n/** \n * Build a tableau for a linear problem.\n * @param f linear objective function\n * @param constraints linear constraints\n * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}or  {@link GoalType#MINIMIZE}\n * @param restrictToNonNegative whether to restrict the variables to non-negative values\n * @param epsilon amount of error to accept when checking for optimality\n */\nSimplexTableau(final LinearObjectiveFunction f,final Collection\u003cLinearConstraint\u003e constraints,final GoalType goalType,final boolean restrictToNonNegative,final double epsilon){\n  this(f,constraints,goalType,restrictToNonNegative,epsilon,DEFAULT_ULPS);\n}\n\n",
    "original": "/** \n * Build a tableau for a linear problem.\n * @param f linear objective function\n * @param constraints linear constraints\n * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}or  {@link GoalType#MINIMIZE}\n * @param restrictToNonNegative whether to restrict the variables to non-negative values\n * @param epsilon amount of error to accept when checking for optimality\n * @param maxUlps amount of error to accept in floating point comparisons\n */\nSimplexTableau(final LinearObjectiveFunction f,final Collection\u003cLinearConstraint\u003e constraints,final GoalType goalType,final boolean restrictToNonNegative,final double epsilon,final int maxUlps){\n  this.f\u003df;\n  this.constraints\u003dnormalizeConstraints(constraints);\n  this.restrictToNonNegative\u003drestrictToNonNegative;\n  this.epsilon\u003depsilon;\n  this.maxUlps\u003dmaxUlps;\n  this.numDecisionVariables\u003df.getCoefficients().getDimension() + (restrictToNonNegative ? 0 : 1);\n  this.numSlackVariables\u003dgetConstraintTypeCounts(Relationship.LEQ) + getConstraintTypeCounts(Relationship.GEQ);\n  this.numArtificialVariables\u003dgetConstraintTypeCounts(Relationship.EQ) + getConstraintTypeCounts(Relationship.GEQ);\n  this.tableau\u003dcreateTableau(goalType \u003d\u003d GoalType.MAXIMIZE);\n  initializeColumnLabels();\n}\n\n/** \n * Build a tableau for a linear problem.\n * @param f linear objective function\n * @param constraints linear constraints\n * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}or  {@link GoalType#MINIMIZE}\n * @param restrictToNonNegative whether to restrict the variables to non-negative values\n * @param epsilon amount of error to accept when checking for optimality\n */\nSimplexTableau(final LinearObjectiveFunction f,final Collection\u003cLinearConstraint\u003e constraints,final GoalType goalType,final boolean restrictToNonNegative,final double epsilon){\n  this(f,constraints,goalType,restrictToNonNegative,epsilon,DEFAULT_ULPS);\n}\n\n/** \n * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n * @param tableau simple tableau for the problem\n * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n * @return row with the minimum ratio\n */\nprivate Integer getPivotRow(SimplexTableau tableau,final int col){\n  List\u003cInteger\u003e minRatioPositions\u003dnew ArrayList\u003cInteger\u003e();\n  double minRatio\u003dDouble.MAX_VALUE;\n  for (int i\u003dtableau.getNumObjectiveFunctions(); i \u003c tableau.getHeight(); i++) {\n    final double rhs\u003dtableau.getEntry(i,tableau.getWidth() - 1);\n    final double entry\u003dtableau.getEntry(i,col);\n    if (Precision.compareTo(entry,0d,maxUlps) \u003e 0) {\n      final double ratio\u003drhs / entry;\n      final int cmp\u003dPrecision.compareTo(ratio,minRatio,maxUlps);\n      if (cmp \u003d\u003d 0) {\n        minRatioPositions.add(i);\n      }\n else       if (cmp \u003c 0) {\n        minRatio\u003dratio;\n        minRatioPositions\u003dnew ArrayList\u003cInteger\u003e();\n        minRatioPositions.add(i);\n      }\n    }\n  }\n  if (minRatioPositions.size() \u003d\u003d 0) {\n    return null;\n  }\n else   if (minRatioPositions.size() \u003e 1) {\n    for (    Integer row : minRatioPositions) {\n      for (int i\u003d0; i \u003c tableau.getNumArtificialVariables(); i++) {\n        int column\u003di + tableau.getArtificialVariableOffset();\n        final double entry\u003dtableau.getEntry(row,column);\n        if (Precision.equals(entry,1d,maxUlps) \u0026\u0026 row.equals(tableau.getBasicRow(column))) {\n          return row;\n        }\n      }\n    }\n  }\n  return minRatioPositions.get(0);\n}\n\n"
  },
  "Closure-170": {
    "buggy": "/** \n * Computes the number of uses of the variable varName and store it in numUseWithinUseCfgNode.\n */\nprivate void getNumUseInUseCfgNode(Node n,Node parant){\n  AbstractCfgNodeTraversalCallback gatherCb\u003dnew AbstractCfgNodeTraversalCallback(){\n    @Override public void visit(    NodeTraversal t,    Node n,    Node parent){\n      if (NodeUtil.isName(n) \u0026\u0026 n.getString().equals(varName) \u0026\u0026 !(NodeUtil.isAssign(parent) \u0026\u0026 (parent.getFirstChild() \u003d\u003d n))) {\n        numUseWithinUseCfgNode++;\n      }\n    }\n  }\n;\n  NodeTraversal.traverse(compiler,n,gatherCb);\n}\n\n",
    "fix": "/** \n * Computes the number of uses of the variable varName and store it in numUseWithinUseCfgNode.\n */\nprivate void getNumUseInUseCfgNode(Node n,Node parant){\n  final Node cfgNode\u003dn;\n  numUseWithinUseCfgNode\u003d0;\n  AbstractCfgNodeTraversalCallback gatherCb\u003dnew AbstractCfgNodeTraversalCallback(){\n    @Override public void visit(    NodeTraversal t,    Node n,    Node parent){\n      if (NodeUtil.isName(n) \u0026\u0026 n.getString().equals(varName) \u0026\u0026 !(NodeUtil.isAssign(parent) \u0026\u0026 (parent.getFirstChild() \u003d\u003d n) \u0026\u0026 isAssignChain(parent,cfgNode))) {\n        numUseWithinUseCfgNode++;\n      }\n    }\n    private boolean isAssignChain(    Node child,    Node ancestor){\n      for (Node n\u003dchild; n !\u003d ancestor; n\u003dn.getParent()) {\n        if (!NodeUtil.isAssign(n)) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n;\n  NodeTraversal.traverse(compiler,cfgNode,gatherCb);\n}\n\n",
    "original": "/** \n * Computes the number of uses of the variable varName and store it in numUseWithinUseCfgNode.\n */\nprivate void getNumUseInUseCfgNode(Node n,Node parant){\n  AbstractCfgNodeTraversalCallback gatherCb\u003dnew AbstractCfgNodeTraversalCallback(){\n    @Override public void visit(    NodeTraversal t,    Node n,    Node parent){\n      if (NodeUtil.isName(n) \u0026\u0026 n.getString().equals(varName)) {\n        numUseWithinUseCfgNode++;\n      }\n    }\n  }\n;\n  NodeTraversal.traverse(compiler,n,gatherCb);\n}\n\n"
  },
  "Closure-8": {
    "buggy": "",
    "fix": "",
    "original": ""
  },
  "Closure-17": {
    "buggy": "/** \n * Look for a type declaration on a property assignment (in an ASSIGN or an object literal key).\n * @param info The doc info for this property.\n * @param lValue The l-value node.\n * @param rValue The node that {@code n} is being initialized to,or  {@code null} if this is a stub declaration.\n */\nprivate JSType getDeclaredType(String sourceName,JSDocInfo info,Node lValue,@Nullable Node rValue){\n  if (info !\u003d null \u0026\u0026 info.hasType()) {\n    return getDeclaredTypeInAnnotation(sourceName,lValue,info);\n  }\n else   if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 shouldUseFunctionLiteralType((FunctionType)rValue.getJSType(),info,lValue)) {\n    return rValue.getJSType();\n  }\n else   if (info !\u003d null) {\n    if (info.hasEnumParameterType()) {\n      if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n        return rValue.getJSType();\n      }\n else {\n        return createEnumTypeFromNodes(rValue,lValue.getQualifiedName(),info,lValue);\n      }\n    }\n else     if (info.isConstructor() || info.isInterface()) {\n      return createFunctionTypeFromNodes(rValue,lValue.getQualifiedName(),info,lValue);\n    }\n else     if (info.isConstant() \u0026\u0026 rValue !\u003d null \u0026\u0026 rValue.getJSType() !\u003d null \u0026\u0026 !rValue.getJSType().isUnknownType()) {\n      return rValue.getJSType();\n    }\n  }\n  return getDeclaredTypeInAnnotation(sourceName,lValue,info);\n}\n\n",
    "fix": "/** \n * Look for a type declaration on a property assignment (in an ASSIGN or an object literal key).\n * @param info The doc info for this property.\n * @param lValue The l-value node.\n * @param rValue The node that {@code n} is being initialized to,or  {@code null} if this is a stub declaration.\n */\nprivate JSType getDeclaredType(String sourceName,JSDocInfo info,Node lValue,@Nullable Node rValue){\n  if (info !\u003d null \u0026\u0026 info.hasType()) {\n    return getDeclaredTypeInAnnotation(sourceName,lValue,info);\n  }\n else   if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 shouldUseFunctionLiteralType((FunctionType)rValue.getJSType(),info,lValue)) {\n    return rValue.getJSType();\n  }\n else   if (info !\u003d null) {\n    if (info.hasEnumParameterType()) {\n      if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n        return rValue.getJSType();\n      }\n else {\n        return createEnumTypeFromNodes(rValue,lValue.getQualifiedName(),info,lValue);\n      }\n    }\n else     if (info.isConstructor() || info.isInterface()) {\n      return createFunctionTypeFromNodes(rValue,lValue.getQualifiedName(),info,lValue);\n    }\n else     if (info.isConstant() \u0026\u0026 rValue !\u003d null) {\n      if (rValue.getJSDocInfo() !\u003d null \u0026\u0026 rValue.getJSDocInfo().hasType()) {\n        return getDeclaredTypeInAnnotation(sourceName,rValue,rValue.getJSDocInfo());\n      }\n else       if (rValue.getJSType() !\u003d null \u0026\u0026 !rValue.getJSType().isUnknownType()) {\n        return rValue.getJSType();\n      }\n    }\n  }\n  return getDeclaredTypeInAnnotation(sourceName,lValue,info);\n}\n\n",
    "original": "/** \n * Look for a type declaration on a property assignment (in an ASSIGN or an object literal key).\n * @param info The doc info for this property.\n * @param lValue The l-value node.\n * @param rValue The node that {@code n} is being initialized to,or  {@code null} if this is a stub declaration.\n */\nprivate JSType getDeclaredType(String sourceName,JSDocInfo info,Node lValue,@Nullable Node rValue){\n  if (info !\u003d null \u0026\u0026 info.hasType()) {\n    return getDeclaredTypeInAnnotation(sourceName,lValue,info);\n  }\n else   if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 shouldUseFunctionLiteralType((FunctionType)rValue.getJSType(),info,lValue)) {\n    return rValue.getJSType();\n  }\n else   if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n    if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n      return rValue.getJSType();\n    }\n else {\n      return createEnumTypeFromNodes(rValue,lValue.getQualifiedName(),info,lValue);\n    }\n  }\n else   if (info !\u003d null \u0026\u0026 (info.isConstructor() || info.isInterface())) {\n    return createFunctionTypeFromNodes(rValue,lValue.getQualifiedName(),info,lValue);\n  }\n else {\n    return getDeclaredTypeInAnnotation(sourceName,lValue,info);\n  }\n}\n\n"
  },
  "Math-42": {
    "buggy": "/** \n * Get the current solution.\n * @return current solution\n */\nprotected RealPointValuePair getSolution(){\n  double[] coefficients\u003dnew double[getOriginalNumDecisionVariables()];\n  Integer negativeVarBasicRow\u003dgetBasicRowForSolution(getNegativeDecisionVariableOffset());\n  double mostNegative\u003dnegativeVarBasicRow \u003d\u003d null ? 0 : getEntry(negativeVarBasicRow,getRhsOffset());\n  Set\u003cInteger\u003e basicRows\u003dnew HashSet\u003cInteger\u003e();\n  for (int i\u003d0; i \u003c coefficients.length; i++) {\n    Integer basicRow\u003dgetBasicRowForSolution(getNumObjectiveFunctions() + i);\n    if (basicRows.contains(basicRow)) {\n      coefficients[i]\u003d0;\n    }\n else {\n      basicRows.add(basicRow);\n      coefficients[i]\u003d(basicRow \u003d\u003d null ? 0 : getEntry(basicRow,getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative);\n    }\n  }\n  return new RealPointValuePair(coefficients,f.getValue(coefficients));\n}\n\n",
    "fix": "/** \n * Get the current solution.\n * @return current solution\n */\nprotected RealPointValuePair getSolution(){\n  double[] coefficients\u003dnew double[getOriginalNumDecisionVariables()];\n  Integer negativeVarBasicRow\u003dgetBasicRowForSolution(getNegativeDecisionVariableOffset());\n  double mostNegative\u003dnegativeVarBasicRow \u003d\u003d null ? 0 : getEntry(negativeVarBasicRow,getRhsOffset());\n  Set\u003cInteger\u003e basicRows\u003dnew HashSet\u003cInteger\u003e();\n  for (int i\u003d0; i \u003c coefficients.length; i++) {\n    Integer basicRow\u003dgetBasicRowForSolution(getNumObjectiveFunctions() + i);\n    if (basicRow !\u003d null \u0026\u0026 basicRow \u003d\u003d 0) {\n      coefficients[i]\u003d0;\n    }\n else     if (basicRows.contains(basicRow)) {\n      coefficients[i]\u003d0 - (restrictToNonNegative ? 0 : mostNegative);\n    }\n else {\n      basicRows.add(basicRow);\n      coefficients[i]\u003d(basicRow \u003d\u003d null ? 0 : getEntry(basicRow,getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative);\n    }\n  }\n  return new RealPointValuePair(coefficients,f.getValue(coefficients));\n}\n\n",
    "original": "/** \n * Get the current solution.\n * @return current solution\n */\nprotected RealPointValuePair getSolution(){\n  double[] coefficients\u003dnew double[getOriginalNumDecisionVariables()];\n  Integer basicRow\u003dgetBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n  double mostNegative\u003dbasicRow \u003d\u003d null ? 0 : getEntry(basicRow,getRhsOffset());\n  Set\u003cInteger\u003e basicRows\u003dnew HashSet\u003cInteger\u003e();\n  for (int i\u003d0; i \u003c coefficients.length; i++) {\n    basicRow\u003dgetBasicRow(getNumObjectiveFunctions() + i);\n    if (basicRows.contains(basicRow)) {\n      coefficients[i]\u003d0;\n    }\n else {\n      basicRows.add(basicRow);\n      coefficients[i]\u003d(basicRow \u003d\u003d null ? 0 : getEntry(basicRow,getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative);\n    }\n  }\n  return new RealPointValuePair(coefficients,f.getValue(coefficients));\n}\n\n"
  },
  "Lang-13": {
    "buggy": "/** \n * Overriden version that uses the parametrized \u003ccode\u003eClassLoader\u003c/code\u003e or the \u003ccode\u003eClassLoader\u003c/code\u003e of the current \u003ccode\u003eThread\u003c/code\u003e to resolve the class.\n * @param desc An instance of class \u003ccode\u003eObjectStreamClass\u003c/code\u003e.\n * @return A \u003ccode\u003eClass\u003c/code\u003e object corresponding to \u003ccode\u003edesc\u003c/code\u003e.\n * @throws IOException Any of the usual Input/Output exceptions.\n * @throws ClassNotFoundException If class of a serialized object cannot be found.\n */\n@Override protected Class\u003c?\u003e resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n  String name\u003ddesc.getName();\n  try {\n    return Class.forName(name,false,classLoader);\n  }\n catch (  ClassNotFoundException ex) {\n    return Class.forName(name,false,Thread.currentThread().getContextClassLoader());\n  }\n}\n\n",
    "fix": "/** \n * Overriden version that uses the parametrized \u003ccode\u003eClassLoader\u003c/code\u003e or the \u003ccode\u003eClassLoader\u003c/code\u003e of the current \u003ccode\u003eThread\u003c/code\u003e to resolve the class.\n * @param desc An instance of class \u003ccode\u003eObjectStreamClass\u003c/code\u003e.\n * @return A \u003ccode\u003eClass\u003c/code\u003e object corresponding to \u003ccode\u003edesc\u003c/code\u003e.\n * @throws IOException Any of the usual Input/Output exceptions.\n * @throws ClassNotFoundException If class of a serialized object cannot be found.\n */\n@Override protected Class\u003c?\u003e resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n  String name\u003ddesc.getName();\n  try {\n    return Class.forName(name,false,classLoader);\n  }\n catch (  ClassNotFoundException ex) {\n    try {\n      return Class.forName(name,false,Thread.currentThread().getContextClassLoader());\n    }\n catch (    ClassNotFoundException cnfe) {\n      Class\u003c?\u003e cls\u003dprimitiveTypes.get(name);\n      if (cls !\u003d null)       return cls;\n else       throw cnfe;\n    }\n  }\n}\n\n/** \n * Constructor.\n * @param in The \u003ccode\u003eInputStream\u003c/code\u003e.\n * @param classLoader classloader to use\n * @throws IOException if an I/O error occurs while reading stream header.\n * @see java.io.ObjectInputStream\n */\npublic ClassLoaderAwareObjectInputStream(InputStream in,ClassLoader classLoader) throws IOException {\n  super(in);\n  this.classLoader\u003dclassLoader;\n  primitiveTypes.put(\"byte\",byte.class);\n  primitiveTypes.put(\"short\",short.class);\n  primitiveTypes.put(\"int\",int.class);\n  primitiveTypes.put(\"long\",long.class);\n  primitiveTypes.put(\"float\",float.class);\n  primitiveTypes.put(\"double\",double.class);\n  primitiveTypes.put(\"boolean\",boolean.class);\n  primitiveTypes.put(\"char\",char.class);\n  primitiveTypes.put(\"void\",void.class);\n}\n\n",
    "original": ""
  },
  "Jsoup-88": {
    "buggy": "private int indexOfKeyIgnoreCase(String key){\n  Validate.notNull(key);\n  for (int i\u003d0; i \u003c size; i++) {\n    if (key.equalsIgnoreCase(keys[i]))     return i;\n  }\n  return NotFound;\n}\n\n/** \n * Get the attribute value.\n * @return the attribute value\n */\npublic String getValue(){\n  return val;\n}\n\n",
    "fix": "/** \n * Get the attribute value.\n * @return the attribute value\n */\npublic String getValue(){\n  return Attributes.checkNotNull(val);\n}\n\n",
    "original": "/** \n * Get the attribute value.\n * @return the attribute value\n */\npublic String getValue(){\n  return value;\n}\n\n"
  },
  "Math-23": {
    "buggy": "",
    "fix": "/** \n * Selects the best of two points.\n * @param a Point and value.\n * @param b Point and value.\n * @param isMinim {@code true} if the selected point must be the one withthe lowest value.\n * @return the best point, or {@code null} if {@code a} and {@code b} areboth  {@code null}. When  {@code a} and {@code b} have the same functionvalue,  {@code a} is returned.\n */\nprivate UnivariatePointValuePair best(UnivariatePointValuePair a,UnivariatePointValuePair b,boolean isMinim){\n  if (a \u003d\u003d null) {\n    return b;\n  }\n  if (b \u003d\u003d null) {\n    return a;\n  }\n  if (isMinim) {\n    return a.getValue() \u003c\u003d b.getValue() ? a : b;\n  }\n else {\n    return a.getValue() \u003e\u003d b.getValue() ? a : b;\n  }\n}\n\n/** \n * {@inheritDoc} \n */\n@Override protected UnivariatePointValuePair doOptimize(){\n  final boolean isMinim\u003dgetGoalType() \u003d\u003d GoalType.MINIMIZE;\n  final double lo\u003dgetMin();\n  final double mid\u003dgetStartValue();\n  final double hi\u003dgetMax();\n  final ConvergenceChecker\u003cUnivariatePointValuePair\u003e checker\u003dgetConvergenceChecker();\n  double a;\n  double b;\n  if (lo \u003c hi) {\n    a\u003dlo;\n    b\u003dhi;\n  }\n else {\n    a\u003dhi;\n    b\u003dlo;\n  }\n  double x\u003dmid;\n  double v\u003dx;\n  double w\u003dx;\n  double d\u003d0;\n  double e\u003d0;\n  double fx\u003dcomputeObjectiveValue(x);\n  if (!isMinim) {\n    fx\u003d-fx;\n  }\n  double fv\u003dfx;\n  double fw\u003dfx;\n  UnivariatePointValuePair previous\u003dnull;\n  UnivariatePointValuePair current\u003dnew UnivariatePointValuePair(x,isMinim ? fx : -fx);\n  UnivariatePointValuePair best\u003dcurrent;\n  int iter\u003d0;\n  while (true) {\n    final double m\u003d0.5 * (a + b);\n    final double tol1\u003drelativeThreshold * FastMath.abs(x) + absoluteThreshold;\n    final double tol2\u003d2 * tol1;\n    final boolean stop\u003dFastMath.abs(x - m) \u003c\u003d tol2 - 0.5 * (b - a);\n    if (!stop) {\n      double p\u003d0;\n      double q\u003d0;\n      double r\u003d0;\n      double u\u003d0;\n      if (FastMath.abs(e) \u003e tol1) {\n        r\u003d(x - w) * (fx - fv);\n        q\u003d(x - v) * (fx - fw);\n        p\u003d(x - v) * q - (x - w) * r;\n        q\u003d2 * (q - r);\n        if (q \u003e 0) {\n          p\u003d-p;\n        }\n else {\n          q\u003d-q;\n        }\n        r\u003de;\n        e\u003dd;\n        if (p \u003e q * (a - x) \u0026\u0026 p \u003c q * (b - x) \u0026\u0026 FastMath.abs(p) \u003c FastMath.abs(0.5 * q * r)) {\n          d\u003dp / q;\n          u\u003dx + d;\n          if (u - a \u003c tol2 || b - u \u003c tol2) {\n            if (x \u003c\u003d m) {\n              d\u003dtol1;\n            }\n else {\n              d\u003d-tol1;\n            }\n          }\n        }\n else {\n          if (x \u003c m) {\n            e\u003db - x;\n          }\n else {\n            e\u003da - x;\n          }\n          d\u003dGOLDEN_SECTION * e;\n        }\n      }\n else {\n        if (x \u003c m) {\n          e\u003db - x;\n        }\n else {\n          e\u003da - x;\n        }\n        d\u003dGOLDEN_SECTION * e;\n      }\n      if (FastMath.abs(d) \u003c tol1) {\n        if (d \u003e\u003d 0) {\n          u\u003dx + tol1;\n        }\n else {\n          u\u003dx - tol1;\n        }\n      }\n else {\n        u\u003dx + d;\n      }\n      double fu\u003dcomputeObjectiveValue(u);\n      if (!isMinim) {\n        fu\u003d-fu;\n      }\n      previous\u003dcurrent;\n      current\u003dnew UnivariatePointValuePair(u,isMinim ? fu : -fu);\n      best\u003dbest(best,best(current,previous,isMinim),isMinim);\n      if (checker !\u003d null) {\n        if (checker.converged(iter,previous,current)) {\n          return best;\n        }\n      }\n      if (fu \u003c\u003d fx) {\n        if (u \u003c x) {\n          b\u003dx;\n        }\n else {\n          a\u003dx;\n        }\n        v\u003dw;\n        fv\u003dfw;\n        w\u003dx;\n        fw\u003dfx;\n        x\u003du;\n        fx\u003dfu;\n      }\n else {\n        if (u \u003c x) {\n          a\u003du;\n        }\n else {\n          b\u003du;\n        }\n        if (fu \u003c\u003d fw || Precision.equals(w,x)) {\n          v\u003dw;\n          fv\u003dfw;\n          w\u003du;\n          fw\u003dfu;\n        }\n else         if (fu \u003c\u003d fv || Precision.equals(v,x) || Precision.equals(v,w)) {\n          v\u003du;\n          fv\u003dfu;\n        }\n      }\n    }\n else {\n      return best\u003dbest(best,best(current,previous,isMinim),isMinim);\n    }\n    ++iter;\n  }\n}\n\n",
    "original": ""
  },
  "Lang-53": {
    "buggy": "/** \n * \u003cp\u003eInternal calculation method.\u003c/p\u003e\n * @param val  the calendar\n * @param field  the field constant\n * @param round  true to round, false to truncate\n * @throws ArithmeticException if the year is over 280 million\n */\nprivate static void modify(Calendar val,int field,boolean round){\n  if (val.get(Calendar.YEAR) \u003e 280000000) {\n    throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n  }\n  if (field \u003d\u003d Calendar.MILLISECOND) {\n    return;\n  }\n  Date date\u003dval.getTime();\n  long time\u003ddate.getTime();\n  boolean done\u003dfalse;\n  int millisecs\u003dval.get(Calendar.MILLISECOND);\n  if (!round || millisecs \u003c 500) {\n    time\u003dtime - millisecs;\n    if (field \u003d\u003d Calendar.SECOND) {\n      done\u003dtrue;\n    }\n  }\n  int seconds\u003dval.get(Calendar.SECOND);\n  if (!done \u0026\u0026 (!round || seconds \u003c 30)) {\n    time\u003dtime - (seconds * 1000L);\n    if (field \u003d\u003d Calendar.MINUTE) {\n      done\u003dtrue;\n    }\n  }\n  int minutes\u003dval.get(Calendar.MINUTE);\n  if (!done \u0026\u0026 (!round || minutes \u003c 30)) {\n    time\u003dtime - (minutes * 60000L);\n  }\n  if (date.getTime() !\u003d time) {\n    date.setTime(time);\n    val.setTime(date);\n  }\n  boolean roundUp\u003dfalse;\n  for (int i\u003d0; i \u003c fields.length; i++) {\n    for (int j\u003d0; j \u003c fields[i].length; j++) {\n      if (fields[i][j] \u003d\u003d field) {\n        if (round \u0026\u0026 roundUp) {\n          if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n            if (val.get(Calendar.DATE) \u003d\u003d 1) {\n              val.add(Calendar.DATE,15);\n            }\n else {\n              val.add(Calendar.DATE,-15);\n              val.add(Calendar.MONTH,1);\n            }\n          }\n else {\n            val.add(fields[i][0],1);\n          }\n        }\n        return;\n      }\n    }\n    int offset\u003d0;\n    boolean offsetSet\u003dfalse;\nswitch (field) {\ncase DateUtils.SEMI_MONTH:\n      if (fields[i][0] \u003d\u003d Calendar.DATE) {\n        offset\u003dval.get(Calendar.DATE) - 1;\n        if (offset \u003e\u003d 15) {\n          offset-\u003d15;\n        }\n        roundUp\u003doffset \u003e 7;\n        offsetSet\u003dtrue;\n      }\n    break;\ncase Calendar.AM_PM:\n  if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n    offset\u003dval.get(Calendar.HOUR_OF_DAY);\n    if (offset \u003e\u003d 12) {\n      offset-\u003d12;\n    }\n    roundUp\u003doffset \u003e 6;\n    offsetSet\u003dtrue;\n  }\nbreak;\n}\nif (!offsetSet) {\nint min\u003dval.getActualMinimum(fields[i][0]);\nint max\u003dval.getActualMaximum(fields[i][0]);\noffset\u003dval.get(fields[i][0]) - min;\nroundUp\u003doffset \u003e ((max - min) / 2);\n}\nif (offset !\u003d 0) {\nval.set(fields[i][0],val.get(fields[i][0]) - offset);\n}\n}\nthrow new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}\n\n",
    "fix": "/** \n * \u003cp\u003eInternal calculation method.\u003c/p\u003e\n * @param val  the calendar\n * @param field  the field constant\n * @param round  true to round, false to truncate\n * @throws ArithmeticException if the year is over 280 million\n */\nprivate static void modify(Calendar val,int field,boolean round){\n  if (val.get(Calendar.YEAR) \u003e 280000000) {\n    throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n  }\n  if (field \u003d\u003d Calendar.MILLISECOND) {\n    return;\n  }\n  Date date\u003dval.getTime();\n  long time\u003ddate.getTime();\n  boolean done\u003dfalse;\n  int millisecs\u003dval.get(Calendar.MILLISECOND);\n  if (!round || millisecs \u003c 500) {\n    time\u003dtime - millisecs;\n  }\n  if (field \u003d\u003d Calendar.SECOND) {\n    done\u003dtrue;\n  }\n  int seconds\u003dval.get(Calendar.SECOND);\n  if (!done \u0026\u0026 (!round || seconds \u003c 30)) {\n    time\u003dtime - (seconds * 1000L);\n  }\n  if (field \u003d\u003d Calendar.MINUTE) {\n    done\u003dtrue;\n  }\n  int minutes\u003dval.get(Calendar.MINUTE);\n  if (!done \u0026\u0026 (!round || minutes \u003c 30)) {\n    time\u003dtime - (minutes * 60000L);\n  }\n  if (date.getTime() !\u003d time) {\n    date.setTime(time);\n    val.setTime(date);\n  }\n  boolean roundUp\u003dfalse;\n  for (int i\u003d0; i \u003c fields.length; i++) {\n    for (int j\u003d0; j \u003c fields[i].length; j++) {\n      if (fields[i][j] \u003d\u003d field) {\n        if (round \u0026\u0026 roundUp) {\n          if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n            if (val.get(Calendar.DATE) \u003d\u003d 1) {\n              val.add(Calendar.DATE,15);\n            }\n else {\n              val.add(Calendar.DATE,-15);\n              val.add(Calendar.MONTH,1);\n            }\n          }\n else {\n            val.add(fields[i][0],1);\n          }\n        }\n        return;\n      }\n    }\n    int offset\u003d0;\n    boolean offsetSet\u003dfalse;\nswitch (field) {\ncase DateUtils.SEMI_MONTH:\n      if (fields[i][0] \u003d\u003d Calendar.DATE) {\n        offset\u003dval.get(Calendar.DATE) - 1;\n        if (offset \u003e\u003d 15) {\n          offset-\u003d15;\n        }\n        roundUp\u003doffset \u003e 7;\n        offsetSet\u003dtrue;\n      }\n    break;\ncase Calendar.AM_PM:\n  if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n    offset\u003dval.get(Calendar.HOUR_OF_DAY);\n    if (offset \u003e\u003d 12) {\n      offset-\u003d12;\n    }\n    roundUp\u003doffset \u003e 6;\n    offsetSet\u003dtrue;\n  }\nbreak;\n}\nif (!offsetSet) {\nint min\u003dval.getActualMinimum(fields[i][0]);\nint max\u003dval.getActualMaximum(fields[i][0]);\noffset\u003dval.get(fields[i][0]) - min;\nroundUp\u003doffset \u003e ((max - min) / 2);\n}\nif (offset !\u003d 0) {\nval.set(fields[i][0],val.get(fields[i][0]) - offset);\n}\n}\nthrow new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}\n\n",
    "original": "/** \n * \u003cp\u003eInternal calculation method.\u003c/p\u003e\n * @param val  the calendar\n * @param field  the field constant\n * @param round  true to round, false to truncate\n * @throws ArithmeticException if the year is over 280 million\n */\nprivate static void modify(Calendar val,int field,boolean round){\n  if (val.get(Calendar.YEAR) \u003e 280000000) {\n    throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n  }\n  boolean roundUp\u003dfalse;\n  for (int i\u003d0; i \u003c fields.length; i++) {\n    for (int j\u003d0; j \u003c fields[i].length; j++) {\n      if (fields[i][j] \u003d\u003d field) {\n        if (round \u0026\u0026 roundUp) {\n          if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n            if (val.get(Calendar.DATE) \u003d\u003d 1) {\n              val.add(Calendar.DATE,15);\n            }\n else {\n              val.add(Calendar.DATE,-15);\n              val.add(Calendar.MONTH,1);\n            }\n          }\n else {\n            val.add(fields[i][0],1);\n          }\n        }\n        return;\n      }\n    }\n    int offset\u003d0;\n    boolean offsetSet\u003dfalse;\nswitch (field) {\ncase DateUtils.SEMI_MONTH:\n      if (fields[i][0] \u003d\u003d Calendar.DATE) {\n        offset\u003dval.get(Calendar.DATE) - 1;\n        if (offset \u003e\u003d 15) {\n          offset-\u003d15;\n        }\n        roundUp\u003doffset \u003e 7;\n        offsetSet\u003dtrue;\n      }\n    break;\ncase Calendar.AM_PM:\n  if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n    offset\u003dval.get(Calendar.HOUR_OF_DAY);\n    if (offset \u003e\u003d 12) {\n      offset-\u003d12;\n    }\n    roundUp\u003doffset \u003e 6;\n    offsetSet\u003dtrue;\n  }\nbreak;\n}\nif (!offsetSet) {\nint min\u003dval.getActualMinimum(fields[i][0]);\nint max\u003dval.getActualMaximum(fields[i][0]);\noffset\u003dval.get(fields[i][0]) - min;\nroundUp\u003doffset \u003e ((max - min) / 2);\n}\nval.set(fields[i][0],val.get(fields[i][0]) - offset);\n}\nthrow new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}\n\n"
  },
  "Time-16": {
    "buggy": "/** \n * Parses a datetime from the given text, at the given position, saving the result into the fields of the given ReadWritableInstant. If the parse succeeds, the return value is the new text position. Note that the parse may succeed without fully reading the text and in this case those fields that were read will be set. \u003cp\u003e Only those fields present in the string will be changed in the specified instant. All other fields will remain unaltered. Thus if the string only contains a year and a month, then the day and time will be retained from the input instant. If this is not the behaviour you want, then reset the fields before calling this method, or use  {@link #parseDateTime(String)}or  {@link #parseMutableDateTime(String)}. \u003cp\u003e If it fails, the return value is negative, but the instant may still be modified. To determine the position where the parse failed, apply the one\u0027s complement operator (~) on the return value. \u003cp\u003e The parse will use the chronology of the instant.\n * @param instant  an instant that will be modified, not null\n * @param text  the text to parse\n * @param position  position to start parsing from\n * @return new position, negative value means parse failed -apply complement operator (~) to get position of failure\n * @throws UnsupportedOperationException if parsing is not supported\n * @throws IllegalArgumentException if the instant is null\n * @throws IllegalArgumentException if any field is out of range\n */\npublic int parseInto(ReadWritableInstant instant,String text,int position){\n  DateTimeParser parser\u003drequireParser();\n  if (instant \u003d\u003d null) {\n    throw new IllegalArgumentException(\"Instant must not be null\");\n  }\n  long instantMillis\u003dinstant.getMillis();\n  Chronology chrono\u003dinstant.getChronology();\n  long instantLocal\u003dinstantMillis + chrono.getZone().getOffset(instantMillis);\n  chrono\u003dselectChronology(chrono);\n  DateTimeParserBucket bucket\u003dnew DateTimeParserBucket(instantLocal,chrono,iLocale,iPivotYear,iDefaultYear);\n  int newPos\u003dparser.parseInto(bucket,text,position);\n  instant.setMillis(bucket.computeMillis(false,text));\n  if (iOffsetParsed \u0026\u0026 bucket.getZone() \u003d\u003d null) {\n    int parsedOffset\u003dbucket.getOffset();\n    DateTimeZone parsedZone\u003dDateTimeZone.forOffsetMillis(parsedOffset);\n    chrono\u003dchrono.withZone(parsedZone);\n  }\n  instant.setChronology(chrono);\n  return newPos;\n}\n\n",
    "fix": "/** \n * Parses a datetime from the given text, at the given position, saving the result into the fields of the given ReadWritableInstant. If the parse succeeds, the return value is the new text position. Note that the parse may succeed without fully reading the text and in this case those fields that were read will be set. \u003cp\u003e Only those fields present in the string will be changed in the specified instant. All other fields will remain unaltered. Thus if the string only contains a year and a month, then the day and time will be retained from the input instant. If this is not the behaviour you want, then reset the fields before calling this method, or use  {@link #parseDateTime(String)}or  {@link #parseMutableDateTime(String)}. \u003cp\u003e If it fails, the return value is negative, but the instant may still be modified. To determine the position where the parse failed, apply the one\u0027s complement operator (~) on the return value. \u003cp\u003e The parse will use the chronology of the instant.\n * @param instant  an instant that will be modified, not null\n * @param text  the text to parse\n * @param position  position to start parsing from\n * @return new position, negative value means parse failed -apply complement operator (~) to get position of failure\n * @throws UnsupportedOperationException if parsing is not supported\n * @throws IllegalArgumentException if the instant is null\n * @throws IllegalArgumentException if any field is out of range\n */\npublic int parseInto(ReadWritableInstant instant,String text,int position){\n  DateTimeParser parser\u003drequireParser();\n  if (instant \u003d\u003d null) {\n    throw new IllegalArgumentException(\"Instant must not be null\");\n  }\n  long instantMillis\u003dinstant.getMillis();\n  Chronology chrono\u003dinstant.getChronology();\n  long instantLocal\u003dinstantMillis + chrono.getZone().getOffset(instantMillis);\n  chrono\u003dselectChronology(chrono);\n  DateTimeParserBucket bucket\u003dnew DateTimeParserBucket(instantLocal,chrono,iLocale,iPivotYear,chrono.year().get(instantLocal));\n  int newPos\u003dparser.parseInto(bucket,text,position);\n  instant.setMillis(bucket.computeMillis(false,text));\n  if (iOffsetParsed \u0026\u0026 bucket.getZone() \u003d\u003d null) {\n    int parsedOffset\u003dbucket.getOffset();\n    DateTimeZone parsedZone\u003dDateTimeZone.forOffsetMillis(parsedOffset);\n    chrono\u003dchrono.withZone(parsedZone);\n  }\n  instant.setChronology(chrono);\n  return newPos;\n}\n\n",
    "original": "/** \n * Parses a datetime from the given text, at the given position, saving the result into the fields of the given ReadWritableInstant. If the parse succeeds, the return value is the new text position. Note that the parse may succeed without fully reading the text and in this case those fields that were read will be set. \u003cp\u003e Only those fields present in the string will be changed in the specified instant. All other fields will remain unaltered. Thus if the string only contains a year and a month, then the day and time will be retained from the input instant. If this is not the behaviour you want, then reset the fields before calling this method, or use  {@link #parseDateTime(String)}or  {@link #parseMutableDateTime(String)}. \u003cp\u003e If it fails, the return value is negative, but the instant may still be modified. To determine the position where the parse failed, apply the one\u0027s complement operator (~) on the return value. \u003cp\u003e The parse will use the chronology of the instant.\n * @param instant  an instant that will be modified, not null\n * @param text  the text to parse\n * @param position  position to start parsing from\n * @return new position, negative value means parse failed -apply complement operator (~) to get position of failure\n * @throws UnsupportedOperationException if parsing is not supported\n * @throws IllegalArgumentException if the instant is null\n * @throws IllegalArgumentException if any field is out of range\n */\npublic int parseInto(ReadWritableInstant instant,String text,int position){\n  DateTimeParser parser\u003drequireParser();\n  if (instant \u003d\u003d null) {\n    throw new IllegalArgumentException(\"Instant must not be null\");\n  }\n  long instantMillis\u003dinstant.getMillis();\n  Chronology chrono\u003dinstant.getChronology();\n  long instantLocal\u003dinstantMillis + chrono.getZone().getOffset(instantMillis);\n  chrono\u003dselectChronology(chrono);\n  DateTimeParserBucket bucket\u003dnew DateTimeParserBucket(instantLocal,chrono,iLocale,iPivotYear);\n  int newPos\u003dparser.parseInto(bucket,text,position);\n  instant.setMillis(bucket.computeMillis(false,text));\n  if (iOffsetParsed \u0026\u0026 bucket.getZone() \u003d\u003d null) {\n    int parsedOffset\u003dbucket.getOffset();\n    DateTimeZone parsedZone\u003dDateTimeZone.forOffsetMillis(parsedOffset);\n    chrono\u003dchrono.withZone(parsedZone);\n  }\n  instant.setChronology(chrono);\n  return newPos;\n}\n\n"
  },
  "Compress-3": {
    "buggy": "/** \n * Finishs writing the contents and closes this as well as the underlying stream.\n * @throws IOException on error\n */\npublic void finish() throws IOException {\n  closeArchiveEntry();\n  cdOffset\u003dwritten;\n  for (Iterator i\u003dentries.iterator(); i.hasNext(); ) {\n    writeCentralFileHeader((ZipArchiveEntry)i.next());\n  }\n  cdLength\u003dwritten - cdOffset;\n  writeCentralDirectoryEnd();\n  offsets.clear();\n  entries.clear();\n}\n\n/** \n * Begins writing a new CPIO file entry and positions the stream to the start of the entry data. Closes the current entry if still active. The current time will be used if the entry has no set modification time and the default header format will be used if no other format is specified in the entry.\n * @param entry the CPIO cpioEntry to be written\n * @throws IOException if an I/O error has occurred or if a CPIO file error has occurred\n * @throws ClassCastException if entry is not an instance of CpioArchiveEntry\n */\npublic void putArchiveEntry(ArchiveEntry entry) throws IOException {\n  CpioArchiveEntry e\u003d(CpioArchiveEntry)entry;\n  ensureOpen();\n  if (this.entry !\u003d null) {\n    closeArchiveEntry();\n  }\n  if (e.getTime() \u003d\u003d -1) {\n    e.setTime(System.currentTimeMillis());\n  }\n  final short format\u003de.getFormat();\n  if (format !\u003d this.entryFormat) {\n    throw new IOException(\"Header format: \" + format + \" does not match existing format: \"+ this.entryFormat);\n  }\n  if (this.names.put(e.getName(),e) !\u003d null) {\n    throw new IOException(\"duplicate entry: \" + e.getName());\n  }\n  writeHeader(e);\n  this.entry\u003de;\n  this.written\u003d0;\n}\n\n/** \n * Finishes writing the contents of the CPIO output stream without closing the underlying stream. Use this method when applying multiple filters in succession to the same output stream.\n * @throws IOException if an I/O exception has occurred or if a CPIO file error has occurred\n */\npublic void finish() throws IOException {\n  ensureOpen();\n  if (this.finished) {\n    return;\n  }\n  if (this.entry !\u003d null) {\n    closeArchiveEntry();\n  }\n  this.entry\u003dnew CpioArchiveEntry(this.entryFormat);\n  this.entry.setName(CPIO_TRAILER);\n  this.entry.setNumberOfLinks(1);\n  writeHeader(this.entry);\n  closeArchiveEntry();\n}\n\n/** \n * Put an entry on the output stream. This writes the entry\u0027s header record and positions the output stream for writing the contents of the entry. Once this method is called, the stream is ready for calls to write() to write the entry\u0027s contents. Once the contents are written, closeArchiveEntry() \u003cB\u003eMUST\u003c/B\u003e be called to ensure that all buffered data is completely written to the output stream.\n * @param archiveEntry The TarEntry to be written to the archive.\n * @throws IOException on error\n * @throws ClassCastException if archiveEntry is not an instance of TarArchiveEntry\n */\npublic void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n  TarArchiveEntry entry\u003d(TarArchiveEntry)archiveEntry;\n  if (entry.getName().length() \u003e\u003d TarConstants.NAMELEN) {\n    if (longFileMode \u003d\u003d LONGFILE_GNU) {\n      TarArchiveEntry longLinkEntry\u003dnew TarArchiveEntry(TarConstants.GNU_LONGLINK,TarConstants.LF_GNUTYPE_LONGNAME);\n      final byte[] nameBytes\u003dentry.getName().getBytes();\n      longLinkEntry.setSize(nameBytes.length + 1);\n      putArchiveEntry(longLinkEntry);\n      write(nameBytes);\n      write(0);\n      closeArchiveEntry();\n    }\n else     if (longFileMode !\u003d LONGFILE_TRUNCATE) {\n      throw new RuntimeException(\"file name \u0027\" + entry.getName() + \"\u0027 is too long ( \u003e \"+ TarConstants.NAMELEN+ \" bytes)\");\n    }\n  }\n  entry.writeEntryHeader(recordBuf);\n  buffer.writeRecord(recordBuf);\n  currBytes\u003d0;\n  if (entry.isDirectory()) {\n    currSize\u003d0;\n  }\n else {\n    currSize\u003dentry.getSize();\n  }\n  currName\u003dentry.getName();\n}\n\n/** \n * Ends the TAR archive without closing the underlying OutputStream. An archive consists of a series of file entries terminated by an end-of-archive entry, which consists of two 512 blocks of zero bytes.  POSIX.1 requires two EOF records, like some other implementations.\n * @throws IOException on error\n */\npublic void finish() throws IOException {\n  writeEOFRecord();\n  writeEOFRecord();\n}\n\npublic void finish() throws IOException {\n}\n\n",
    "fix": "public void closeArchiveEntry() throws IOException {\n  if (prevEntry !\u003d null \u0026\u0026 haveUnclosedEntry \u0026\u0026 (entryOffset % 2) !\u003d 0) {\n    out.write(\u0027\\n\u0027);\n    archiveOffset++;\n  }\n  haveUnclosedEntry\u003dfalse;\n}\n\n/** \n * Ends the TAR archive without closing the underlying OutputStream. An archive consists of a series of file entries terminated by an end-of-archive entry, which consists of two 512 blocks of zero bytes.  POSIX.1 requires two EOF records, like some other implementations.\n * @throws IOException on error\n */\npublic void finish() throws IOException {\n  if (haveUnclosedEntry) {\n    throw new IOException(\"This archives contains unclosed entries.\");\n  }\n  writeEOFRecord();\n  writeEOFRecord();\n}\n\n/** \n * Construct the cpio output stream. The format for this CPIO stream is the \"new\" format\n * @param out The cpio stream\n */\npublic CpioArchiveOutputStream(final OutputStream out){\n  this(out,FORMAT_NEW);\n}\n\nprivate void writeOldAsciiEntry(final CpioArchiveEntry entry) throws IOException {\n  writeAsciiLong(entry.getDevice(),6,8);\n  writeAsciiLong(entry.getInode(),6,8);\n  writeAsciiLong(entry.getMode(),6,8);\n  writeAsciiLong(entry.getUID(),6,8);\n  writeAsciiLong(entry.getGID(),6,8);\n  writeAsciiLong(entry.getNumberOfLinks(),6,8);\n  writeAsciiLong(entry.getRemoteDevice(),6,8);\n  writeAsciiLong(entry.getTime(),11,8);\n  writeAsciiLong(entry.getName().length() + 1,6,8);\n  writeAsciiLong(entry.getSize(),11,8);\n  writeCString(entry.getName());\n}\n\npublic void finish() throws IOException {\n  if (haveUnclosedEntry) {\n    throw new IOException(\"This archives contains unclosed entries.\");\n  }\n}\n\n/** \n * Finishs writing the contents and closes this as well as the underlying stream.\n * @throws IOException on error\n */\npublic void finish() throws IOException {\n  if (entry !\u003d null) {\n    throw new IOException(\"This archives contains unclosed entries.\");\n  }\n  cdOffset\u003dwritten;\n  for (Iterator i\u003dentries.iterator(); i.hasNext(); ) {\n    writeCentralFileHeader((ZipArchiveEntry)i.next());\n  }\n  cdLength\u003dwritten - cdOffset;\n  writeCentralDirectoryEnd();\n  offsets.clear();\n  entries.clear();\n}\n\n/** \n * Finishes writing the contents of the CPIO output stream without closing the underlying stream. Use this method when applying multiple filters in succession to the same output stream.\n * @throws IOException if an I/O exception has occurred or if a CPIO file error has occurred\n */\npublic void finish() throws IOException {\n  ensureOpen();\n  if (this.finished) {\n    return;\n  }\n  if (this.entry !\u003d null) {\n    throw new IOException(\"This archives contains unclosed entries.\");\n  }\n  this.entry\u003dnew CpioArchiveEntry(this.entryFormat);\n  this.entry.setName(CPIO_TRAILER);\n  this.entry.setNumberOfLinks(1);\n  writeHeader(this.entry);\n  closeArchiveEntry();\n}\n\n/** \n * Closes the CPIO output stream as well as the stream being filtered.\n * @throws IOException if an I/O error has occurred or if a CPIO file error has occurred\n */\npublic void close() throws IOException {\n  if (!this.closed) {\n    this.finish();\n    out.close();\n    this.closed\u003dtrue;\n  }\n}\n\n/** \n * Whether to create Unicode Extra Fields. \u003cp\u003eDefaults to NEVER.\u003c/p\u003e\n */\npublic void setCreateUnicodeExtraFields(UnicodeExtraFieldPolicy b){\n  createUnicodeExtraFields\u003db;\n}\n\n/** \n * Close an entry. This method MUST be called for all file entries that contain data. The reason is that we must buffer data written to the stream in order to satisfy the buffer\u0027s record based writes. Thus, there may be data fragments still being assembled that must be written to the output stream before this entry is closed and the next entry written.\n * @throws IOException on error\n */\npublic void closeArchiveEntry() throws IOException {\n  if (assemLen \u003e 0) {\n    for (int i\u003dassemLen; i \u003c assemBuf.length; ++i) {\n      assemBuf[i]\u003d0;\n    }\n    buffer.writeRecord(assemBuf);\n    currBytes+\u003dassemLen;\n    assemLen\u003d0;\n  }\n  if (currBytes \u003c currSize) {\n    throw new IOException(\"entry \u0027\" + currName + \"\u0027 closed at \u0027\"+ currBytes+ \"\u0027 before the \u0027\"+ currSize+ \"\u0027 bytes specified in the header were written\");\n  }\n  haveUnclosedEntry\u003dfalse;\n}\n\n/** \n * Begins writing a new CPIO file entry and positions the stream to the start of the entry data. Closes the current entry if still active. The current time will be used if the entry has no set modification time and the default header format will be used if no other format is specified in the entry.\n * @param entry the CPIO cpioEntry to be written\n * @throws IOException if an I/O error has occurred or if a CPIO file error has occurred\n * @throws ClassCastException if entry is not an instance of CpioArchiveEntry\n */\npublic void putArchiveEntry(ArchiveEntry entry) throws IOException {\n  CpioArchiveEntry e\u003d(CpioArchiveEntry)entry;\n  ensureOpen();\n  if (this.entry !\u003d null) {\n    closeArchiveEntry();\n  }\n  if (e.getTime() \u003d\u003d -1) {\n    e.setTime(System.currentTimeMillis());\n  }\n  final short format\u003de.getFormat();\n  if (format !\u003d this.entryFormat) {\n    throw new IOException(\"Header format: \" + format + \" does not match existing format: \"+ this.entryFormat);\n  }\n  if (this.names.put(e.getName(),e) !\u003d null) {\n    throw new IOException(\"duplicate entry: \" + e.getName());\n  }\n  writeHeader(e);\n  this.entry\u003de;\n  this.written\u003d0;\n}\n\nprivate void writeHeader(final CpioArchiveEntry e) throws IOException {\nswitch (e.getFormat()) {\ncase FORMAT_NEW:\n    out.write(ArchiveUtils.toAsciiBytes(MAGIC_NEW));\n  writeNewEntry(e);\nbreak;\ncase FORMAT_NEW_CRC:\nout.write(ArchiveUtils.toAsciiBytes(MAGIC_NEW_CRC));\nwriteNewEntry(e);\nbreak;\ncase FORMAT_OLD_ASCII:\nout.write(ArchiveUtils.toAsciiBytes(MAGIC_OLD_ASCII));\nwriteOldAsciiEntry(e);\nbreak;\ncase FORMAT_OLD_BINARY:\nboolean swapHalfWord\u003dtrue;\nwriteBinaryLong(MAGIC_OLD_BINARY,2,swapHalfWord);\nwriteOldBinaryEntry(e,swapHalfWord);\nbreak;\n}\n}\n\npublic void close() throws IOException {\n  out.close();\n  prevEntry\u003dnull;\n}\n\n/** \n * Put an entry on the output stream. This writes the entry\u0027s header record and positions the output stream for writing the contents of the entry. Once this method is called, the stream is ready for calls to write() to write the entry\u0027s contents. Once the contents are written, closeArchiveEntry() \u003cB\u003eMUST\u003c/B\u003e be called to ensure that all buffered data is completely written to the output stream.\n * @param archiveEntry The TarEntry to be written to the archive.\n * @throws IOException on error\n * @throws ClassCastException if archiveEntry is not an instance of TarArchiveEntry\n */\npublic void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n  TarArchiveEntry entry\u003d(TarArchiveEntry)archiveEntry;\n  if (entry.getName().length() \u003e\u003d TarConstants.NAMELEN) {\n    if (longFileMode \u003d\u003d LONGFILE_GNU) {\n      TarArchiveEntry longLinkEntry\u003dnew TarArchiveEntry(TarConstants.GNU_LONGLINK,TarConstants.LF_GNUTYPE_LONGNAME);\n      final byte[] nameBytes\u003dentry.getName().getBytes();\n      longLinkEntry.setSize(nameBytes.length + 1);\n      putArchiveEntry(longLinkEntry);\n      write(nameBytes);\n      write(0);\n      closeArchiveEntry();\n    }\n else     if (longFileMode !\u003d LONGFILE_TRUNCATE) {\n      throw new RuntimeException(\"file name \u0027\" + entry.getName() + \"\u0027 is too long ( \u003e \"+ TarConstants.NAMELEN+ \" bytes)\");\n    }\n  }\n  entry.writeEntryHeader(recordBuf);\n  buffer.writeRecord(recordBuf);\n  currBytes\u003d0;\n  if (entry.isDirectory()) {\n    currSize\u003d0;\n  }\n else {\n    currSize\u003dentry.getSize();\n  }\n  currName\u003dentry.getName();\n  haveUnclosedEntry\u003dtrue;\n}\n\nprivate long writeEntryHeader(final ArArchiveEntry pEntry) throws IOException {\n  long offset\u003d0;\n  final String n\u003dpEntry.getName();\n  if (n.length() \u003e 16) {\n    throw new IOException(\"filename too long, \u003e 16 chars: \" + n);\n  }\n  offset+\u003dwrite(n);\n  offset\u003dfill(offset,16,\u0027 \u0027);\n  final String m\u003d\"\" + (pEntry.getLastModified() / 1000);\n  if (m.length() \u003e 12) {\n    throw new IOException(\"modified too long\");\n  }\n  offset+\u003dwrite(m);\n  offset\u003dfill(offset,28,\u0027 \u0027);\n  final String u\u003d\"\" + pEntry.getUserId();\n  if (u.length() \u003e 6) {\n    throw new IOException(\"userid too long\");\n  }\n  offset+\u003dwrite(u);\n  offset\u003dfill(offset,34,\u0027 \u0027);\n  final String g\u003d\"\" + pEntry.getGroupId();\n  if (g.length() \u003e 6) {\n    throw new IOException(\"groupid too long\");\n  }\n  offset+\u003dwrite(g);\n  offset\u003dfill(offset,40,\u0027 \u0027);\n  final String fm\u003d\"\" + Integer.toString(pEntry.getMode(),8);\n  if (fm.length() \u003e 8) {\n    throw new IOException(\"filemode too long\");\n  }\n  offset+\u003dwrite(fm);\n  offset\u003dfill(offset,48,\u0027 \u0027);\n  final String s\u003d\"\" + pEntry.getLength();\n  if (s.length() \u003e 10) {\n    throw new IOException(\"size too long\");\n  }\n  offset+\u003dwrite(s);\n  offset\u003dfill(offset,58,\u0027 \u0027);\n  offset+\u003dwrite(ArArchiveEntry.TRAILER);\n  return offset;\n}\n\n",
    "original": "public void putArchiveEntry(final ArchiveEntry pEntry) throws IOException {\n  ArArchiveEntry pArEntry\u003d(ArArchiveEntry)pEntry;\n  if (prevEntry \u003d\u003d null) {\n    archiveOffset+\u003dwriteArchiveHeader();\n  }\n else {\n    if (prevEntry.getLength() !\u003d entryOffset) {\n      throw new IOException(\"length does not match entry (\" + prevEntry.getLength() + \" !\u003d \"+ entryOffset);\n    }\n    closeArchiveEntry();\n  }\n  prevEntry\u003dpArEntry;\n  archiveOffset+\u003dwriteEntryHeader(pArEntry);\n  entryOffset\u003d0;\n  haveUnclosedEntry\u003dtrue;\n}\n\n"
  },
  "Compress-6": {
    "buggy": "public boolean equals(Object obj){\n  if (this \u003d\u003d obj) {\n    return true;\n  }\n  if (obj \u003d\u003d null || getClass() !\u003d obj.getClass()) {\n    return false;\n  }\n  ZipArchiveEntry other\u003d(ZipArchiveEntry)obj;\n  if (name \u003d\u003d null) {\n    if (other.name !\u003d null) {\n      return false;\n    }\n  }\n else   if (!name.equals(other.name)) {\n    return false;\n  }\n  return true;\n}\n\n",
    "fix": "public boolean equals(Object obj){\n  if (this \u003d\u003d obj) {\n    return true;\n  }\n  if (obj \u003d\u003d null || getClass() !\u003d obj.getClass()) {\n    return false;\n  }\n  ZipArchiveEntry other\u003d(ZipArchiveEntry)obj;\n  String myName\u003dgetName();\n  String otherName\u003dother.getName();\n  if (myName \u003d\u003d null) {\n    if (otherName !\u003d null) {\n      return false;\n    }\n  }\n else   if (!myName.equals(otherName)) {\n    return false;\n  }\n  return true;\n}\n\n",
    "original": ""
  },
  "Compress-1": {
    "buggy": "/** \n * Closes the CPIO output stream as well as the stream being filtered.\n * @throws IOException if an I/O error has occurred or if a CPIO file error hasoccurred\n */\npublic void close() throws IOException {\n  if (!this.closed) {\n    super.close();\n    this.closed\u003dtrue;\n  }\n}\n\n",
    "fix": "/** \n * Closes the CPIO output stream as well as the stream being filtered.\n * @throws IOException if an I/O error has occurred or if a CPIO file error hasoccurred\n */\npublic void close() throws IOException {\n  if (!this.closed) {\n    this.finish();\n    super.close();\n    this.closed\u003dtrue;\n  }\n}\n\n",
    "original": ""
  },
  "Closure-114": {
    "buggy": "public void visit(NodeTraversal t,Node n,Node parent){\n  if (!t.inGlobalScope()) {\n    return;\n  }\n  if (n.getType() \u003d\u003d Token.ASSIGN) {\n    Node nameNode\u003dn.getFirstChild();\n    NameInformation ns\u003dcreateNameInformation(t,nameNode,n);\n    if (ns !\u003d null) {\n      if (parent.getType() \u003d\u003d Token.FOR \u0026\u0026 !NodeUtil.isForIn(parent)) {\n        if (parent.getFirstChild().getNext() !\u003d n) {\n          recordDepScope(n,ns);\n        }\n else {\n          recordDepScope(nameNode,ns);\n        }\n      }\n else {\n        recordDepScope(n,ns);\n      }\n    }\n  }\n else   if (NodeUtil.isVarDeclaration(n)) {\n    NameInformation ns\u003dcreateNameInformation(t,n,parent);\n    recordDepScope(n,ns);\n  }\n else   if (NodeUtil.isFunctionDeclaration(n)) {\n    NameInformation ns\u003dcreateNameInformation(t,n.getFirstChild(),n);\n    recordDepScope(n,ns);\n  }\n else   if (NodeUtil.isExprCall(n)) {\n    Node callNode\u003dn.getFirstChild();\n    Node nameNode\u003dcallNode.getFirstChild();\n    NameInformation ns\u003dcreateNameInformation(t,nameNode,callNode);\n    if (ns !\u003d null \u0026\u0026 ns.onlyAffectsClassDef) {\n      recordDepScope(n,ns);\n    }\n  }\n}\n\n",
    "fix": "public void visit(NodeTraversal t,Node n,Node parent){\n  if (!t.inGlobalScope()) {\n    return;\n  }\n  if (n.getType() \u003d\u003d Token.ASSIGN) {\n    Node nameNode\u003dn.getFirstChild();\n    NameInformation ns\u003dcreateNameInformation(t,nameNode,n);\n    if (ns !\u003d null) {\n      if (parent.getType() \u003d\u003d Token.FOR \u0026\u0026 !NodeUtil.isForIn(parent)) {\n        if (parent.getFirstChild().getNext() !\u003d n) {\n          recordDepScope(n,ns);\n        }\n else         if (!(parent.getType() \u003d\u003d Token.CALL \u0026\u0026 parent.getFirstChild() \u003d\u003d n)) {\n          recordDepScope(nameNode,ns);\n        }\n      }\n else {\n        recordDepScope(n,ns);\n      }\n    }\n  }\n else   if (NodeUtil.isVarDeclaration(n)) {\n    NameInformation ns\u003dcreateNameInformation(t,n,parent);\n    recordDepScope(n,ns);\n  }\n else   if (NodeUtil.isFunctionDeclaration(n)) {\n    NameInformation ns\u003dcreateNameInformation(t,n.getFirstChild(),n);\n    recordDepScope(n,ns);\n  }\n else   if (NodeUtil.isExprCall(n)) {\n    Node callNode\u003dn.getFirstChild();\n    Node nameNode\u003dcallNode.getFirstChild();\n    NameInformation ns\u003dcreateNameInformation(t,nameNode,callNode);\n    if (ns !\u003d null \u0026\u0026 ns.onlyAffectsClassDef) {\n      recordDepScope(n,ns);\n    }\n  }\n}\n\n",
    "original": "public void visit(NodeTraversal t,Node n,Node parent){\n  if (!t.inGlobalScope()) {\n    return;\n  }\n  if (n.getType() \u003d\u003d Token.ASSIGN) {\n    Node nameNode\u003dn.getFirstChild();\n    NameInformation ns\u003dcreateNameInformation(t,nameNode,n);\n    if (ns !\u003d null) {\n      if (parent.getType() \u003d\u003d Token.FOR \u0026\u0026 !NodeUtil.isForIn(parent)) {\n        if (parent.getFirstChild().getNext() !\u003d n) {\n          recordDepScope(n,ns);\n        }\n else {\n          recordDepScope(nameNode,ns);\n        }\n      }\n else {\n        recordDepScope(parent,ns);\n      }\n    }\n  }\n else   if (NodeUtil.isVarDeclaration(n)) {\n    NameInformation ns\u003dcreateNameInformation(t,n,parent);\n    recordDepScope(n,ns);\n  }\n else   if (NodeUtil.isFunctionDeclaration(n)) {\n    NameInformation ns\u003dcreateNameInformation(t,n.getFirstChild(),n);\n    recordDepScope(n,ns);\n  }\n else   if (NodeUtil.isExprCall(n)) {\n    Node callNode\u003dn.getFirstChild();\n    Node nameNode\u003dcallNode.getFirstChild();\n    NameInformation ns\u003dcreateNameInformation(t,nameNode,callNode);\n    if (ns !\u003d null \u0026\u0026 ns.onlyAffectsClassDef) {\n      recordDepScope(n,ns);\n    }\n  }\n}\n\n"
  },
  "Closure-60": {
    "buggy": "",
    "fix": "/** \n * Gets the boolean value of a node that represents a literal. This method effectively emulates the \u003ccode\u003eBoolean()\u003c/code\u003e JavaScript cast function.\n */\nstatic TernaryValue getBooleanValue(Node n){\nswitch (n.getType()) {\ncase Token.STRING:\n    return TernaryValue.forBoolean(n.getString().length() \u003e 0);\ncase Token.NUMBER:\n  return TernaryValue.forBoolean(n.getDouble() !\u003d 0);\ncase Token.NULL:\ncase Token.FALSE:\nreturn TernaryValue.FALSE;\ncase Token.VOID:\nif (!mayHaveSideEffects(n.getFirstChild())) {\nreturn TernaryValue.FALSE;\n}\nbreak;\ncase Token.NAME:\nString name\u003dn.getString();\nif (\"undefined\".equals(name) || \"NaN\".equals(name)) {\nreturn TernaryValue.FALSE;\n}\n else if (\"Infinity\".equals(name)) {\nreturn TernaryValue.TRUE;\n}\nbreak;\ncase Token.TRUE:\ncase Token.ARRAYLIT:\ncase Token.OBJECTLIT:\ncase Token.REGEXP:\nreturn TernaryValue.TRUE;\n}\nreturn TernaryValue.UNKNOWN;\n}\n\n!org.eclipse.jdt.core.dom.MethodDeclaration@7d24f1ef\n",
    "original": ""
  },
  "Closure-61": {
    "buggy": "/** \n * Returns true if calls to this function have side effects.\n * @param callNode The call node to inspected.\n * @param compiler A compiler object to provide program state changingcontext information. Can be null.\n */\nstatic boolean functionCallHasSideEffects(Node callNode,@Nullable AbstractCompiler compiler){\n  if (callNode.getType() !\u003d Token.CALL) {\n    throw new IllegalStateException(\"Expected CALL node, got \" + Token.name(callNode.getType()));\n  }\n  if (callNode.isNoSideEffectsCall()) {\n    return false;\n  }\n  Node nameNode\u003dcallNode.getFirstChild();\n  if (nameNode.getType() \u003d\u003d Token.NAME) {\n    String name\u003dnameNode.getString();\n    if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n      return false;\n    }\n  }\n else   if (nameNode.getType() \u003d\u003d Token.GETPROP) {\n    if (callNode.hasOneChild() \u0026\u0026 OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(nameNode.getLastChild().getString())) {\n      return false;\n    }\n    if (callNode.isOnlyModifiesThisCall() \u0026\u0026 evaluatesToLocalValue(nameNode.getFirstChild())) {\n      return false;\n    }\n    if (compiler !\u003d null \u0026\u0026 !compiler.hasRegExpGlobalReferences()) {\n      if (nameNode.getFirstChild().getType() \u003d\u003d Token.REGEXP \u0026\u0026 REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n        return false;\n      }\n else       if (nameNode.getFirstChild().getType() \u003d\u003d Token.STRING \u0026\u0026 STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n        Node param\u003dnameNode.getNext();\n        if (param !\u003d null \u0026\u0026 (param.getType() \u003d\u003d Token.STRING || param.getType() \u003d\u003d Token.REGEXP))         return false;\n      }\n    }\n  }\n  return true;\n}\n\n",
    "fix": "/** \n * Returns true if calls to this function have side effects.\n * @param callNode The call node to inspected.\n * @param compiler A compiler object to provide program state changingcontext information. Can be null.\n */\nstatic boolean functionCallHasSideEffects(Node callNode,@Nullable AbstractCompiler compiler){\n  if (callNode.getType() !\u003d Token.CALL) {\n    throw new IllegalStateException(\"Expected CALL node, got \" + Token.name(callNode.getType()));\n  }\n  if (callNode.isNoSideEffectsCall()) {\n    return false;\n  }\n  Node nameNode\u003dcallNode.getFirstChild();\n  if (nameNode.getType() \u003d\u003d Token.NAME) {\n    String name\u003dnameNode.getString();\n    if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n      return false;\n    }\n  }\n else   if (nameNode.getType() \u003d\u003d Token.GETPROP) {\n    if (callNode.hasOneChild() \u0026\u0026 OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(nameNode.getLastChild().getString())) {\n      return false;\n    }\n    if (callNode.isOnlyModifiesThisCall() \u0026\u0026 evaluatesToLocalValue(nameNode.getFirstChild())) {\n      return false;\n    }\n    if (nameNode.getFirstChild().getType() \u003d\u003d Token.NAME) {\n      String namespaceName\u003dnameNode.getFirstChild().getString();\n      if (namespaceName.equals(\"Math\")) {\n        return false;\n      }\n    }\n    if (compiler !\u003d null \u0026\u0026 !compiler.hasRegExpGlobalReferences()) {\n      if (nameNode.getFirstChild().getType() \u003d\u003d Token.REGEXP \u0026\u0026 REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n        return false;\n      }\n else       if (nameNode.getFirstChild().getType() \u003d\u003d Token.STRING \u0026\u0026 STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n        Node param\u003dnameNode.getNext();\n        if (param !\u003d null \u0026\u0026 (param.getType() \u003d\u003d Token.STRING || param.getType() \u003d\u003d Token.REGEXP))         return false;\n      }\n    }\n  }\n  return true;\n}\n\n",
    "original": "/** \n * Returns true if calls to this function have side effects.\n * @param callNode The call node to inspected.\n * @param compiler A compiler object to provide program state changingcontext information. Can be null.\n */\nstatic boolean functionCallHasSideEffects(Node callNode,@Nullable AbstractCompiler compiler){\n  if (callNode.getType() !\u003d Token.CALL) {\n    throw new IllegalStateException(\"Expected CALL node, got \" + Token.name(callNode.getType()));\n  }\n  if (callNode.isNoSideEffectsCall()) {\n    return false;\n  }\n  Node nameNode\u003dcallNode.getFirstChild();\n  if (nameNode.getType() \u003d\u003d Token.NAME) {\n    String name\u003dnameNode.getString();\n    if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n      return false;\n    }\n  }\n else   if (nameNode.getType() \u003d\u003d Token.GETPROP) {\n    if (callNode.hasOneChild() \u0026\u0026 OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(nameNode.getLastChild().getString())) {\n      return false;\n    }\n    if (callNode.isOnlyModifiesThisCall() \u0026\u0026 evaluatesToLocalValue(nameNode.getFirstChild())) {\n      return false;\n    }\n    if (nameNode.getFirstChild().getType() \u003d\u003d Token.NAME) {\n      String namespaceName\u003dnameNode.getFirstChild().getString();\n      if (namespaceName.equals(\"Math\")) {\n        return false;\n      }\n    }\n    if (compiler !\u003d null \u0026\u0026 !compiler.hasRegExpGlobalReferences()) {\n      if (nameNode.getFirstChild().getType() \u003d\u003d Token.REGEXP \u0026\u0026 REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n        return false;\n      }\n else       if (nameNode.getFirstChild().getType() \u003d\u003d Token.STRING \u0026\u0026 STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n        Node param\u003dnameNode.getNext();\n        if (param !\u003d null \u0026\u0026 (param.getType() \u003d\u003d Token.STRING || param.getType() \u003d\u003d Token.REGEXP))         return false;\n      }\n    }\n  }\n  return true;\n}\n\n"
  },
  "Closure-121": {
    "buggy": "boolean isDeclaration(){\n  return DECLARATION_PARENTS.contains(parent.getType()) || parent.getType() \u003d\u003d Token.LP \u0026\u0026 grandparent.getType() \u003d\u003d Token.FUNCTION;\n}\n\nNode getNameNode(){\n  return nameNode;\n}\n\n/** \n * Remove the given VAR declaration.\n */\nprivate void removeDeclaration(Reference declaration){\n  Node varNode\u003ddeclaration.getParent();\n  varNode.removeChild(declaration.getNameNode());\n  if (!varNode.hasChildren()) {\n    Preconditions.checkState(varNode.getType() \u003d\u003d Token.VAR);\n    Node grandparent\u003ddeclaration.getGrandparent();\n    NodeUtil.removeChild(grandparent,varNode);\n  }\n  compiler.reportCodeChange();\n}\n\n/** \n * Determines if the variable for this reference collection is \"well-defined.\" A variable is well-defined if we can prove at compile-time that it\u0027s assigned a value before it\u0027s used. Notice that if this function returns false, this doesn\u0027t imply that the variable is used before it\u0027s assigned. It just means that we don\u0027t have enough information to make a definitive judgement.\n */\nprotected boolean isWellDefined(){\n  int size\u003dreferences.size();\n  if (size \u003d\u003d 0) {\n    return false;\n  }\n  Reference init\u003dgetInitializingReference();\n  if (init \u003d\u003d null) {\n    return false;\n  }\n  Preconditions.checkState(references.get(0).isDeclaration());\n  BasicBlock initBlock\u003dinit.getBasicBlock();\n  for (int i\u003d1; i \u003c size; i++) {\n    if (!initBlock.provablyExecutesBefore(references.get(i).getBasicBlock())) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/** \n * Determines whether the given variable is declared as a constant and may be inlined.\n */\nprivate boolean isInlineableDeclaredConstant(Var var,ReferenceCollection refInfo){\n  if (!identifyConstants.apply(var)) {\n    return false;\n  }\n  if (!refInfo.isAssignedOnce()) {\n    return false;\n  }\n  Reference init\u003drefInfo.getInitializingReferenceForConstants();\n  if (init \u003d\u003d null) {\n    return false;\n  }\n  Node value\u003dinit.getAssignedValue();\n  if (value \u003d\u003d null) {\n    return false;\n  }\n  if (!NodeUtil.isImmutableValue(value)) {\n    return false;\n  }\n  return value.getType() !\u003d Token.STRING || isStringWorthInlining(var,refInfo.references);\n}\n\n/** \n * @return Whether\n */\nprivate boolean isValidInitialization(Reference initialization){\n  if (initialization \u003d\u003d null) {\n    return false;\n  }\n else   if (initialization.isDeclaration()) {\n    return initialization.getNameNode().getFirstChild() !\u003d null;\n  }\n else {\n    Node parent\u003dinitialization.getParent();\n    Preconditions.checkState(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d initialization.getNameNode());\n    return true;\n  }\n}\n\n/** \n * @return true if the provided reference and declaration can be safelyinlined according to our criteria\n */\nprivate boolean canInline(Reference declaration,Reference initialization,Reference reference){\n  if (!isValidDeclaration(declaration) || !isValidInitialization(initialization) || !isValidReference(reference)) {\n    return false;\n  }\n  if (declaration !\u003d initialization \u0026\u0026 initialization.getGrandparent().getType() !\u003d Token.EXPR_RESULT) {\n    return false;\n  }\n  if (declaration.getBasicBlock() !\u003d initialization.getBasicBlock() || declaration.getBasicBlock() !\u003d reference.getBasicBlock()) {\n    return false;\n  }\n  Node value\u003dinitialization.getAssignedValue();\n  Preconditions.checkState(value !\u003d null);\n  if (value.getType() \u003d\u003d Token.GETPROP \u0026\u0026 reference.getParent().getType() \u003d\u003d Token.CALL \u0026\u0026 reference.getParent().getFirstChild() \u003d\u003d reference.getNameNode()) {\n    return false;\n  }\n  return canMoveAggressively(value) || canMoveModerately(initialization,reference);\n}\n\n/** \n * @return Whether the variable is only assigned a value once.\n */\nboolean isAssignedOnce(){\n  boolean assigned\u003dfalse;\n  int size\u003dreferences.size();\n  for (int i\u003d0; i \u003c size; i++) {\n    Reference ref\u003dreferences.get(i);\n    if (ref.isLvalue() || ref.isInitializingDeclaration()) {\n      if (!assigned) {\n        assigned\u003dtrue;\n      }\n else {\n        return false;\n      }\n    }\n  }\n  return assigned;\n}\n\n/** \n * @return true if the reference is a candidate for inlining\n */\nprivate boolean isValidReference(Reference reference){\n  return !reference.isDeclaration() \u0026\u0026 !reference.isLvalue();\n}\n\nprivate void inlineNonConstants(Var v,ReferenceCollection referenceInfo){\n  int refCount\u003dreferenceInfo.references.size();\n  Reference declaration\u003dreferenceInfo.references.get(0);\n  Reference init\u003dreferenceInfo.getInitializingReference();\n  int firstRefAfterInit\u003d(declaration \u003d\u003d init) ? 2 : 3;\n  if (refCount \u003e 1 \u0026\u0026 isImmutableAndWellDefinedVariable(v,referenceInfo)) {\n    Node value\u003dinit.getAssignedValue();\n    Preconditions.checkNotNull(value);\n    inlineWellDefinedVariable(v,value,referenceInfo.references);\n    staleVars.add(v);\n  }\n else   if (refCount \u003d\u003d firstRefAfterInit) {\n    Reference reference\u003dreferenceInfo.references.get(firstRefAfterInit - 1);\n    if (canInline(declaration,init,reference)) {\n      inline(v,declaration,init,reference);\n      staleVars.add(v);\n    }\n  }\n else   if (declaration !\u003d init \u0026\u0026 refCount \u003d\u003d 2) {\n    if (isValidDeclaration(declaration) \u0026\u0026 isValidInitialization(init)) {\n      Node value\u003dinit.getAssignedValue();\n      Preconditions.checkNotNull(value);\n      inlineWellDefinedVariable(v,value,referenceInfo.references);\n      staleVars.add(v);\n    }\n  }\n  if (!staleVars.contains(v) \u0026\u0026 referenceInfo.isWellDefined() \u0026\u0026 referenceInfo.isAssignedOnce()) {\n    List\u003cReference\u003e refs\u003dreferenceInfo.references;\n    for (int i\u003d1; i \u003c refs.size(); i++) {\n      Node nameNode\u003drefs.get(i).getNameNode();\n      if (aliasCandidates.containsKey(nameNode)) {\n        AliasCandidate candidate\u003daliasCandidates.get(nameNode);\n        if (!staleVars.contains(candidate.alias)) {\n          Reference aliasInit;\n          aliasInit\u003dcandidate.refInfo.getInitializingReference();\n          Node value\u003daliasInit.getAssignedValue();\n          Preconditions.checkNotNull(value);\n          inlineWellDefinedVariable(candidate.alias,value,candidate.refInfo.references);\n          staleVars.add(candidate.alias);\n        }\n      }\n    }\n  }\n}\n\n/** \n * Compute whether the given string is worth inlining.\n */\nprivate boolean isStringWorthInlining(Var var,List\u003cReference\u003e refs){\n  if (!inlineAllStrings \u0026\u0026 !var.isDefine()) {\n    int len\u003dvar.getInitialValue().getString().length() + \"\u0027\u0027\".length();\n    int noInlineBytes\u003d\"var xx\u003d;\".length() + len + 4 * (refs.size() - 1);\n    int inlineBytes\u003d(len - 1) * (refs.size() - 1);\n    return noInlineBytes \u003e\u003d inlineBytes;\n  }\n  return true;\n}\n\n/** \n * @return For an assignment or variable declaration return the assignedvalue, otherwise null.\n */\nNode getAssignedValue(){\n  return NodeUtil.getAssignedValue(getNameNode());\n}\n\n",
    "fix": "/** \n * @return For an assignment or variable declaration return the assignedvalue, otherwise null.\n */\nNode getAssignedValue(){\n  return NodeUtil.getAssignedValue(getNameNode());\n}\n\n/** \n * Determines whether the given variable is declared as a constant and may be inlined.\n */\nprivate boolean isInlineableDeclaredConstant(Var var,ReferenceCollection refInfo){\n  if (!identifyConstants.apply(var)) {\n    return false;\n  }\n  if (!refInfo.isAssignedOnce()) {\n    return false;\n  }\n  Reference init\u003drefInfo.getInitializingReferenceForConstants();\n  if (init \u003d\u003d null) {\n    return false;\n  }\n  Node value\u003dinit.getAssignedValue();\n  if (value \u003d\u003d null) {\n    return false;\n  }\n  if (!NodeUtil.isImmutableValue(value)) {\n    return false;\n  }\n  return value.getType() !\u003d Token.STRING || isStringWorthInlining(var,refInfo.references);\n}\n\n/** \n * @return Whether the variable is only assigned a value once for itslifetime.\n */\nboolean isOnlyAssignmentSameScopeAsDeclaration(){\n  Reference ref\u003dgetOneAndOnlyAssignment();\n  Preconditions.checkNotNull(ref);\n  for (BasicBlock block\u003dref.getBasicBlock(); block !\u003d null; block\u003dblock.getParent()) {\n    if (block.isFunction) {\n      if (ref.getSymbol().scope !\u003d ref.scope) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/** \n * @return true if the provided reference and declaration can be safelyinlined according to our criteria\n */\nprivate boolean canInline(Reference declaration,Reference initialization,Reference reference){\n  if (!isValidDeclaration(declaration) || !isValidInitialization(initialization) || !isValidReference(reference)) {\n    return false;\n  }\n  if (declaration !\u003d initialization \u0026\u0026 initialization.getGrandparent().getType() !\u003d Token.EXPR_RESULT) {\n    return false;\n  }\n  if (declaration.getBasicBlock() !\u003d initialization.getBasicBlock() || declaration.getBasicBlock() !\u003d reference.getBasicBlock()) {\n    return false;\n  }\n  Node value\u003dinitialization.getAssignedValue();\n  Preconditions.checkState(value !\u003d null);\n  if (value.getType() \u003d\u003d Token.GETPROP \u0026\u0026 reference.getParent().getType() \u003d\u003d Token.CALL \u0026\u0026 reference.getParent().getFirstChild() \u003d\u003d reference.getNameNode()) {\n    return false;\n  }\n  return canMoveAggressively(value) || canMoveModerately(initialization,reference);\n}\n\n/** \n * Remove the given VAR declaration.\n */\nprivate void removeDeclaration(Reference declaration){\n  Node varNode\u003ddeclaration.getParent();\n  varNode.removeChild(declaration.getNameNode());\n  if (!varNode.hasChildren()) {\n    Preconditions.checkState(varNode.getType() \u003d\u003d Token.VAR);\n    Node grandparent\u003ddeclaration.getGrandparent();\n    NodeUtil.removeChild(grandparent,varNode);\n  }\n  compiler.reportCodeChange();\n}\n\n/** \n * @return Whether\n */\nprivate boolean isValidInitialization(Reference initialization){\n  if (initialization \u003d\u003d null) {\n    return false;\n  }\n else   if (initialization.isDeclaration()) {\n    return initialization.getNameNode().getFirstChild() !\u003d null;\n  }\n else {\n    Node parent\u003dinitialization.getParent();\n    Preconditions.checkState(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d initialization.getNameNode());\n    return true;\n  }\n}\n\n/** \n * Creates a new block.\n * @param parent The containing block.\n * @param root The root node of the block.\n */\nBasicBlock(BasicBlock parent,Node root){\n  this.parent\u003dparent;\n  this.mayBeHoisted\u003d(root.getType() \u003d\u003d Token.FUNCTION) \u0026\u0026 !NodeUtil.isFunctionAnonymous(root);\n  this.isFunction\u003droot.getType() \u003d\u003d Token.FUNCTION;\n}\n\n/** \n * @return true if the reference is a candidate for inlining\n */\nprivate boolean isValidReference(Reference reference){\n  return !reference.isDeclaration() \u0026\u0026 !reference.isLvalue();\n}\n\nprivate void inlineNonConstants(Var v,ReferenceCollection referenceInfo){\n  int refCount\u003dreferenceInfo.references.size();\n  Reference declaration\u003dreferenceInfo.references.get(0);\n  Reference init\u003dreferenceInfo.getInitializingReference();\n  int firstRefAfterInit\u003d(declaration \u003d\u003d init) ? 2 : 3;\n  if (refCount \u003e 1 \u0026\u0026 isImmutableAndWellDefinedVariable(v,referenceInfo)) {\n    Node value\u003dinit.getAssignedValue();\n    Preconditions.checkNotNull(value);\n    inlineWellDefinedVariable(v,value,referenceInfo.references);\n    staleVars.add(v);\n  }\n else   if (refCount \u003d\u003d firstRefAfterInit) {\n    Reference reference\u003dreferenceInfo.references.get(firstRefAfterInit - 1);\n    if (canInline(declaration,init,reference)) {\n      inline(v,declaration,init,reference);\n      staleVars.add(v);\n    }\n  }\n else   if (declaration !\u003d init \u0026\u0026 refCount \u003d\u003d 2) {\n    if (isValidDeclaration(declaration) \u0026\u0026 isValidInitialization(init)) {\n      Node value\u003dinit.getAssignedValue();\n      Preconditions.checkNotNull(value);\n      inlineWellDefinedVariable(v,value,referenceInfo.references);\n      staleVars.add(v);\n    }\n  }\n  if (!staleVars.contains(v) \u0026\u0026 referenceInfo.isWellDefined() \u0026\u0026 referenceInfo.isAssignedOnce()\u0026\u0026 (isInlineableDeclaredConstant(v,referenceInfo) || referenceInfo.isOnlyAssignmentSameScopeAsDeclaration())) {\n    List\u003cReference\u003e refs\u003dreferenceInfo.references;\n    for (int i\u003d1; i \u003c refs.size(); i++) {\n      Node nameNode\u003drefs.get(i).getNameNode();\n      if (aliasCandidates.containsKey(nameNode)) {\n        AliasCandidate candidate\u003daliasCandidates.get(nameNode);\n        if (!staleVars.contains(candidate.alias)) {\n          Reference aliasInit;\n          aliasInit\u003dcandidate.refInfo.getInitializingReference();\n          Node value\u003daliasInit.getAssignedValue();\n          Preconditions.checkNotNull(value);\n          inlineWellDefinedVariable(candidate.alias,value,candidate.refInfo.references);\n          staleVars.add(candidate.alias);\n        }\n      }\n    }\n  }\n}\n\n/** \n * Replace the given reference with the given value node.\n * @param v The variable that\u0027s referenced.\n * @param ref The reference to replace.\n * @param value The node tree to replace it with. This tree should be safeto re-parent.\n */\nprivate void inlineValue(Var v,Reference ref,Node value){\n  Node parent\u003dref.getParent();\n  if (ref.isSimpleAssignmentToName()) {\n    ref.getGrandparent().replaceChild(parent,value);\n  }\n else {\n    ref.getParent().replaceChild(ref.getNameNode(),value);\n  }\n  blacklistVarReferencesInTree(value,v.scope);\n  compiler.reportCodeChange();\n}\n\npublic Var getSymbol(){\n  return scope.getVar(nameNode.getString());\n}\n\n/** \n * Determines if the variable for this reference collection is \"well-defined.\" A variable is well-defined if we can prove at compile-time that it\u0027s assigned a value before it\u0027s used. Notice that if this function returns false, this doesn\u0027t imply that the variable is used before it\u0027s assigned. It just means that we don\u0027t have enough information to make a definitive judgement.\n */\nprotected boolean isWellDefined(){\n  int size\u003dreferences.size();\n  if (size \u003d\u003d 0) {\n    return false;\n  }\n  Reference init\u003dgetInitializingReference();\n  if (init \u003d\u003d null) {\n    return false;\n  }\n  Preconditions.checkState(references.get(0).isDeclaration());\n  BasicBlock initBlock\u003dinit.getBasicBlock();\n  for (int i\u003d1; i \u003c size; i++) {\n    if (!initBlock.provablyExecutesBefore(references.get(i).getBasicBlock())) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/** \n * @return Whether the variable is only assigned a value once.\n */\nboolean isAssignedOnce(){\n  boolean assigned\u003dfalse;\n  int size\u003dreferences.size();\n  for (int i\u003d0; i \u003c size; i++) {\n    Reference ref\u003dreferences.get(i);\n    if (ref.isLvalue() || ref.isInitializingDeclaration()) {\n      if (!assigned) {\n        assigned\u003dtrue;\n      }\n else {\n        return false;\n      }\n    }\n  }\n  return assigned;\n}\n\n/** \n * @return The one and only assignment. Returns if there are 0 or 2+assignments.\n */\nprivate Reference getOneAndOnlyAssignment(){\n  Reference assignment\u003dnull;\n  int size\u003dreferences.size();\n  for (int i\u003d0; i \u003c size; i++) {\n    Reference ref\u003dreferences.get(i);\n    if (ref.isLvalue() || ref.isInitializingDeclaration()) {\n      if (assignment \u003d\u003d null) {\n        assignment\u003dref;\n      }\n else {\n        return null;\n      }\n    }\n  }\n  return assignment;\n}\n\n",
    "original": "/** \n * Determines if the variable for this reference collection is \"well-defined.\" A variable is well-defined if we can prove at compile-time that it\u0027s assigned a value before it\u0027s used. Notice that if this function returns false, this doesn\u0027t imply that the variable is used before it\u0027s assigned. It just means that we don\u0027t have enough information to make a definitive judgement.\n */\nprotected boolean isWellDefined(){\n  int size\u003dreferences.size();\n  if (size \u003d\u003d 0) {\n    return false;\n  }\n  Reference decl\u003dreferences.get(0);\n  if (!decl.isInitializingDeclaration()) {\n    return false;\n  }\n  BasicBlock declBlock\u003ddecl.getBasicBlock();\n  for (int i\u003d1; i \u003c size; i++) {\n    if (!declBlock.provablyExecutesBefore(references.get(i).getBasicBlock())) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/** \n * Determines whether the given variable is declared as a constant and may be inlined.\n */\nprivate boolean isInlineableDeclaredConstant(Var var,List\u003cReference\u003e refs){\n  if (!identifyConstants.apply(var)) {\n    return false;\n  }\n  return var.getInitialValue().getType() !\u003d Token.STRING || isStringWorthInlining(var,refs);\n}\n\n/** \n * Compute whether the given string is worth inlining.\n */\nprivate boolean isStringWorthInlining(Var var,List\u003cReference\u003e refs){\n  if (!inlineAllStrings \u0026\u0026 !var.isDefine()) {\n    int len\u003dvar.getInitialValue().getString().length() + \"\u0027\u0027\".length();\n    int noInlineBytes\u003d\"var xx\u003d;\".length() + len + 4 * (refs.size() - 1);\n    int inlineBytes\u003d(len - 1) * (refs.size() - 1);\n    return noInlineBytes \u003e\u003d inlineBytes;\n  }\n  return true;\n}\n\n/** \n * @return true if the reference is a candidate for inlining\n */\nprivate boolean isValidReference(Reference reference){\n  return !reference.isDeclaration() \u0026\u0026 !reference.isLvalue();\n}\n\nprivate void inlineNonConstants(Scope scope,Var v,ReferenceCollection referenceInfo){\n  if (referenceInfo.references.size() \u003e\u003d 2 \u0026\u0026 isImmutableAndWellDefinedVariable(v,referenceInfo)) {\n    inlineWellDefinedVariable(v,referenceInfo.references);\n    staleVars.add(v);\n  }\n else   if (referenceInfo.references.size() \u003d\u003d 2) {\n    Reference declaration\u003dreferenceInfo.references.get(0);\n    Reference reference\u003dreferenceInfo.references.get(1);\n    if (canInline(declaration,reference)) {\n      blacklistVarReferencesInTree(declaration.getNameNode().getFirstChild(),scope);\n      inline(v,declaration,reference);\n      staleVars.add(v);\n    }\n  }\n  if (!staleVars.contains(v) \u0026\u0026 referenceInfo.isWellDefined() \u0026\u0026 referenceInfo.isNeverReassigned()) {\n    List\u003cReference\u003e refs\u003dreferenceInfo.references;\n    for (int i\u003d1; i \u003c refs.size(); i++) {\n      Node nameNode\u003drefs.get(i).getNameNode();\n      if (aliasCandidates.containsKey(nameNode)) {\n        AliasCandidate candidate\u003daliasCandidates.get(nameNode);\n        if (!staleVars.contains(candidate.alias)) {\n          inlineWellDefinedVariable(candidate.alias,candidate.refInfo.references);\n          staleVars.add(candidate.alias);\n        }\n      }\n    }\n  }\n}\n\nNode getNameNode(){\n  return nameNode;\n}\n\n/** \n * Remove the given VAR declaration.\n */\nprivate void removeDeclaration(Reference declaration){\n  Node varNode\u003ddeclaration.getParent();\n  varNode.removeChild(declaration.getNameNode());\n  if (!varNode.hasChildren()) {\n    Preconditions.checkState(varNode.getType() \u003d\u003d Token.VAR);\n    Node grandparent\u003ddeclaration.getGrandparent();\n    NodeUtil.removeChild(grandparent,varNode);\n  }\n  compiler.reportCodeChange();\n}\n\n/** \n * @return true if the provided reference and declaration can be safelyinlined according to our criteria\n */\nprivate boolean canInline(Reference declaration,Reference reference){\n  if (!isValidDeclaration(declaration) || !isValidReference(reference)) {\n    return false;\n  }\n  if (declaration.getBasicBlock() !\u003d reference.getBasicBlock()) {\n    return false;\n  }\n  if (declaration.getNameNode().getFirstChild().getType() \u003d\u003d Token.GETPROP \u0026\u0026 reference.getParent().getType() \u003d\u003d Token.CALL) {\n    return false;\n  }\n  return canMoveAggressively(declaration) || canMoveModerately(declaration,reference);\n}\n\nboolean isDeclaration(){\n  return DECLARATION_PARENTS.contains(parent.getType()) || parent.getType() \u003d\u003d Token.LP \u0026\u0026 grandparent.getType() \u003d\u003d Token.FUNCTION;\n}\n\n"
  },
  "Closure-64": {
    "buggy": "/** \n * Writes out js code from a root node. If printing input delimiters, this method will attach a comment to the start of the text indicating which input the output derived from. If there were any preserve annotations within the root\u0027s source, they will also be printed in a block comment at the beginning of the output.\n */\npublic void toSource(final CodeBuilder cb,final int inputSeqNum,final Node root){\n  runInCompilerThread(new Callable\u003cVoid\u003e(){\n    public Void call() throws Exception {\n      if (options.printInputDelimiter) {\n        if ((cb.getLength() \u003e 0) \u0026\u0026 !cb.endsWith(\"\\n\")) {\n          cb.append(\"\\n\");\n        }\n        Preconditions.checkState(root.getType() \u003d\u003d Token.SCRIPT);\n        String delimiter\u003doptions.inputDelimiter;\n        String sourceName\u003d(String)root.getProp(Node.SOURCENAME_PROP);\n        Preconditions.checkState(sourceName !\u003d null);\n        Preconditions.checkState(!sourceName.isEmpty());\n        delimiter\u003ddelimiter.replaceAll(\"%name%\",sourceName).replaceAll(\"%num%\",String.valueOf(inputSeqNum));\n        cb.append(delimiter).append(\"\\n\");\n      }\n      if (root.getJSDocInfo() !\u003d null \u0026\u0026 root.getJSDocInfo().getLicense() !\u003d null) {\n        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n      }\n      if (options.sourceMapOutputPath !\u003d null) {\n        sourceMap.setStartingPosition(cb.getLineIndex(),cb.getColumnIndex());\n      }\n      String code\u003dtoSource(root,sourceMap);\n      if (!code.isEmpty()) {\n        cb.append(code);\n        int length\u003dcode.length();\n        char lastChar\u003dcode.charAt(length - 1);\n        char secondLastChar\u003dlength \u003e\u003d 2 ? code.charAt(length - 2) : \u0027\\0\u0027;\n        boolean hasSemiColon\u003dlastChar \u003d\u003d \u0027;\u0027 || (lastChar \u003d\u003d \u0027\\n\u0027 \u0026\u0026 secondLastChar \u003d\u003d \u0027;\u0027);\n        if (!hasSemiColon) {\n          cb.append(\";\");\n        }\n      }\n      return null;\n    }\n  }\n);\n}\n\n",
    "fix": "/** \n * Generates JavaScript source code for an AST.\n */\nprivate String toSource(Node n,SourceMap sourceMap,boolean firstOutput){\n  CodePrinter.Builder builder\u003dnew CodePrinter.Builder(n);\n  builder.setPrettyPrint(options.prettyPrint);\n  builder.setLineBreak(options.lineBreak);\n  builder.setSourceMap(sourceMap);\n  builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\n  builder.setTagAsStrict(firstOutput \u0026\u0026 options.getLanguageOut() \u003d\u003d LanguageMode.ECMASCRIPT5_STRICT);\n  Charset charset\u003doptions.outputCharset !\u003d null ? Charset.forName(options.outputCharset) : null;\n  builder.setOutputCharset(charset);\n  return builder.build();\n}\n\n/** \n * Writes out js code from a root node. If printing input delimiters, this method will attach a comment to the start of the text indicating which input the output derived from. If there were any preserve annotations within the root\u0027s source, they will also be printed in a block comment at the beginning of the output.\n */\npublic void toSource(final CodeBuilder cb,final int inputSeqNum,final Node root){\n  runInCompilerThread(new Callable\u003cVoid\u003e(){\n    public Void call() throws Exception {\n      if (options.printInputDelimiter) {\n        if ((cb.getLength() \u003e 0) \u0026\u0026 !cb.endsWith(\"\\n\")) {\n          cb.append(\"\\n\");\n        }\n        Preconditions.checkState(root.getType() \u003d\u003d Token.SCRIPT);\n        String delimiter\u003doptions.inputDelimiter;\n        String sourceName\u003d(String)root.getProp(Node.SOURCENAME_PROP);\n        Preconditions.checkState(sourceName !\u003d null);\n        Preconditions.checkState(!sourceName.isEmpty());\n        delimiter\u003ddelimiter.replaceAll(\"%name%\",sourceName).replaceAll(\"%num%\",String.valueOf(inputSeqNum));\n        cb.append(delimiter).append(\"\\n\");\n      }\n      if (root.getJSDocInfo() !\u003d null \u0026\u0026 root.getJSDocInfo().getLicense() !\u003d null) {\n        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n      }\n      if (options.sourceMapOutputPath !\u003d null) {\n        sourceMap.setStartingPosition(cb.getLineIndex(),cb.getColumnIndex());\n      }\n      String code\u003dtoSource(root,sourceMap,inputSeqNum \u003d\u003d 0);\n      if (!code.isEmpty()) {\n        cb.append(code);\n        int length\u003dcode.length();\n        char lastChar\u003dcode.charAt(length - 1);\n        char secondLastChar\u003dlength \u003e\u003d 2 ? code.charAt(length - 2) : \u0027\\0\u0027;\n        boolean hasSemiColon\u003dlastChar \u003d\u003d \u0027;\u0027 || (lastChar \u003d\u003d \u0027\\n\u0027 \u0026\u0026 secondLastChar \u003d\u003d \u0027;\u0027);\n        if (!hasSemiColon) {\n          cb.append(\";\");\n        }\n      }\n      return null;\n    }\n  }\n);\n}\n\n/** \n * Generates JavaScript source code for an AST, doesn\u0027t generate source map info.\n */\n@Override String toSource(Node n){\n  initCompilerOptionsIfTesting();\n  return toSource(n,null,true);\n}\n\n",
    "original": "/** \n * Converts a tree to js code\n */\nprivate static String toSource(Node root,Format outputFormat,boolean lineBreak,int lineLengthThreshold,SourceMap sourceMap,SourceMap.DetailLevel sourceMapDetailLevel,Charset outputCharset){\n  Preconditions.checkState(sourceMapDetailLevel !\u003d null);\n  boolean createSourceMap\u003d(sourceMap !\u003d null);\n  MappedCodePrinter mcp\u003doutputFormat \u003d\u003d Format.COMPACT ? new CompactCodePrinter(lineBreak,lineLengthThreshold,createSourceMap,sourceMapDetailLevel) : new PrettyCodePrinter(lineLengthThreshold,createSourceMap,sourceMapDetailLevel);\n  CodeGenerator cg\u003doutputFormat \u003d\u003d Format.TYPED ? new TypedCodeGenerator(mcp,outputCharset) : new CodeGenerator(mcp,outputCharset);\n  cg.add(root);\n  mcp.endFile();\n  String code\u003dmcp.getCode();\n  if (createSourceMap) {\n    mcp.generateSourceMap(sourceMap);\n  }\n  return code;\n}\n\n"
  },
  "Codec-8": {
    "buggy": "/** \n * Default constructor:  lineLength is 76, and the lineSeparator is CRLF when encoding, and all forms can be decoded.\n */\nBase64(){\n  this(CHUNK_SIZE,CHUNK_SEPARATOR);\n}\n\n/** \n * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n * @param binaryData Array containing binary data to encode.\n * @param isChunked if \u003ccode\u003etrue\u003c/code\u003e this encoder will chunk the base64 output into 76 character blocks\n * @return Base64-encoded data.\n * @throws IllegalArgumentException Thrown when the input array needs an output array bigger than  {@link Integer#MAX_VALUE}\n */\npublic static byte[] encodeBase64(byte[] binaryData,boolean isChunked){\n  if (binaryData \u003d\u003d null || binaryData.length \u003d\u003d 0) {\n    return binaryData;\n  }\n  Base64 b64\u003disChunked ? new Base64() : new Base64(0);\n  long len\u003d(binaryData.length * 4) / 3;\n  long mod\u003dlen % 4;\n  if (mod !\u003d 0) {\n    len+\u003d4 - mod;\n  }\n  if (isChunked) {\n    len+\u003d(1 + (len / CHUNK_SIZE)) * CHUNK_SEPARATOR.length;\n  }\n  if (len \u003e Integer.MAX_VALUE) {\n    throw new IllegalArgumentException(\"Input array too big, output array would be bigger than Integer.MAX_VALUE\u003d\" + Integer.MAX_VALUE);\n  }\n  byte[] buf\u003dnew byte[(int)len];\n  b64.setInitialBuffer(buf,0,buf.length);\n  b64.encode(binaryData,0,binaryData.length);\n  b64.encode(binaryData,0,-1);\n  if (b64.buf !\u003d buf) {\n    b64.readResults(buf,0,buf.length);\n  }\n  return buf;\n}\n\n/** \n * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail bytes.  Returns how many bytes were actually extracted.\n * @param b      byte[] array to extract the buffered data into.\n * @param bPos   position in byte[] array to start extraction at.\n * @param bAvail amount of bytes we\u0027re allowed to extract.  We may extractfewer (if fewer are available).\n * @return The number of bytes successfully extracted into the providedbyte[] array.\n */\nint readResults(byte[] b,int bPos,int bAvail){\n  if (buf !\u003d null) {\n    int len\u003dMath.min(avail(),bAvail);\n    if (buf !\u003d b) {\n      System.arraycopy(buf,readPos,b,bPos,len);\n      readPos+\u003dlen;\n      if (readPos \u003e\u003d pos) {\n        buf\u003dnull;\n      }\n    }\n else {\n      buf\u003dnull;\n    }\n    return len;\n  }\n else {\n    return eof ? -1 : 0;\n  }\n}\n\n/** \n * Decodes Base64 data into octects\n * @param base64Data Byte array containing Base64 data\n * @return Array containing decoded data.\n */\npublic static byte[] decodeBase64(byte[] base64Data){\n  if (base64Data \u003d\u003d null || base64Data.length \u003d\u003d 0) {\n    return base64Data;\n  }\n  Base64 b64\u003dnew Base64();\n  long len\u003d(base64Data.length * 3) / 4;\n  byte[] buf\u003dnew byte[(int)len];\n  b64.setInitialBuffer(buf,0,buf.length);\n  b64.decode(base64Data,0,base64Data.length);\n  b64.decode(base64Data,0,-1);\n  byte[] result\u003dnew byte[b64.pos];\n  b64.readResults(result,0,result.length);\n  return result;\n}\n\n/** \n * \u003cp\u003e Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice:  once with the data to encode, and once with inAvail set to \"-1\" to alert encoder that EOF has been reached, so flush last remaining bytes (if not multiple of 3). \u003c/p\u003e\u003cp\u003e Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach. http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/ \u003c/p\u003e\n * @param in byte[] array of binary data to base64 encode.\n * @param inPos Position to start reading data from.\n * @param inAvail Amount of bytes available from input for encoding.\n */\nvoid encode(byte[] in,int inPos,int inAvail){\n  if (eof) {\n    return;\n  }\n  if (inAvail \u003c 0) {\n    eof\u003dtrue;\n    if (buf \u003d\u003d null || buf.length - pos \u003c encodeSize) {\n      resizeBuf();\n    }\nswitch (modulus) {\ncase 1:\n      buf[pos++]\u003dintToBase64[(x \u003e\u003e 2) \u0026 0x3f];\n    buf[pos++]\u003dintToBase64[(x \u003c\u003c 4) \u0026 0x3f];\n  buf[pos++]\u003dPAD;\nbuf[pos++]\u003dPAD;\nbreak;\ncase 2:\nbuf[pos++]\u003dintToBase64[(x \u003e\u003e 10) \u0026 0x3f];\nbuf[pos++]\u003dintToBase64[(x \u003e\u003e 4) \u0026 0x3f];\nbuf[pos++]\u003dintToBase64[(x \u003c\u003c 2) \u0026 0x3f];\nbuf[pos++]\u003dPAD;\nbreak;\n}\nif (lineLength \u003e 0) {\nSystem.arraycopy(lineSeparator,0,buf,pos,lineSeparator.length);\npos+\u003dlineSeparator.length;\n}\n}\n else {\nfor (int i\u003d0; i \u003c inAvail; i++) {\nif (buf \u003d\u003d null || buf.length - pos \u003c encodeSize) {\nresizeBuf();\n}\nmodulus\u003d(++modulus) % 3;\nint b\u003din[inPos++];\nif (b \u003c 0) {\nb+\u003d256;\n}\nx\u003d(x \u003c\u003c 8) + b;\nif (0 \u003d\u003d modulus) {\nbuf[pos++]\u003dintToBase64[(x \u003e\u003e 18) \u0026 0x3f];\nbuf[pos++]\u003dintToBase64[(x \u003e\u003e 12) \u0026 0x3f];\nbuf[pos++]\u003dintToBase64[(x \u003e\u003e 6) \u0026 0x3f];\nbuf[pos++]\u003dintToBase64[x \u0026 0x3f];\ncurrentLinePos+\u003d4;\nif (lineLength \u003e 0 \u0026\u0026 lineLength \u003c\u003d currentLinePos) {\nSystem.arraycopy(lineSeparator,0,buf,pos,lineSeparator.length);\npos+\u003dlineSeparator.length;\ncurrentLinePos\u003d0;\n}\n}\n}\n}\n}\n\n",
    "fix": "/** \n * \u003cp\u003e Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice:  once with the data to encode, and once with inAvail set to \"-1\" to alert encoder that EOF has been reached, so flush last remaining bytes (if not multiple of 3). \u003c/p\u003e\u003cp\u003e Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach. http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/ \u003c/p\u003e\n * @param in byte[] array of binary data to base64 encode.\n * @param inPos Position to start reading data from.\n * @param inAvail Amount of bytes available from input for encoding.\n */\nvoid encode(byte[] in,int inPos,int inAvail){\n  if (eof) {\n    return;\n  }\n  if (inAvail \u003c 0) {\n    eof\u003dtrue;\n    if (buf \u003d\u003d null || buf.length - pos \u003c encodeSize) {\n      resizeBuf();\n    }\nswitch (modulus) {\ncase 1:\n      buf[pos++]\u003dintToBase64[(x \u003e\u003e 2) \u0026 0x3f];\n    buf[pos++]\u003dintToBase64[(x \u003c\u003c 4) \u0026 0x3f];\n  buf[pos++]\u003dPAD;\nbuf[pos++]\u003dPAD;\nbreak;\ncase 2:\nbuf[pos++]\u003dintToBase64[(x \u003e\u003e 10) \u0026 0x3f];\nbuf[pos++]\u003dintToBase64[(x \u003e\u003e 4) \u0026 0x3f];\nbuf[pos++]\u003dintToBase64[(x \u003c\u003c 2) \u0026 0x3f];\nbuf[pos++]\u003dPAD;\nbreak;\n}\nbyte b\u003dlineSeparator[lineSeparator.length - 1];\nif (lineLength \u003e 0 \u0026\u0026 pos \u003e 0 \u0026\u0026 buf[pos - 1] !\u003d b) {\nSystem.arraycopy(lineSeparator,0,buf,pos,lineSeparator.length);\npos+\u003dlineSeparator.length;\n}\n}\n else {\nfor (int i\u003d0; i \u003c inAvail; i++) {\nif (buf \u003d\u003d null || buf.length - pos \u003c encodeSize) {\nresizeBuf();\n}\nmodulus\u003d(++modulus) % 3;\nint b\u003din[inPos++];\nif (b \u003c 0) {\nb+\u003d256;\n}\nx\u003d(x \u003c\u003c 8) + b;\nif (0 \u003d\u003d modulus) {\nbuf[pos++]\u003dintToBase64[(x \u003e\u003e 18) \u0026 0x3f];\nbuf[pos++]\u003dintToBase64[(x \u003e\u003e 12) \u0026 0x3f];\nbuf[pos++]\u003dintToBase64[(x \u003e\u003e 6) \u0026 0x3f];\nbuf[pos++]\u003dintToBase64[x \u0026 0x3f];\ncurrentLinePos+\u003d4;\nif (lineLength \u003e 0 \u0026\u0026 lineLength \u003c\u003d currentLinePos) {\nSystem.arraycopy(lineSeparator,0,buf,pos,lineSeparator.length);\npos+\u003dlineSeparator.length;\ncurrentLinePos\u003d0;\n}\n}\n}\n}\n}\n\n/** \n * Attempts to read \u003ccode\u003elen\u003c/code\u003e bytes into the specified \u003ccode\u003eb\u003c/code\u003e array starting at \u003ccode\u003eoffset\u003c/code\u003e from this InputStream.\n * @throws IOException if an I/O error occurs.\n */\npublic int read(byte b[],int offset,int len) throws IOException {\n  if (b \u003d\u003d null) {\n    throw new NullPointerException();\n  }\n else   if (offset \u003c 0 || len \u003c 0 || offset + len \u003c 0) {\n    throw new IndexOutOfBoundsException();\n  }\n else   if (offset \u003e b.length || offset + len \u003e b.length) {\n    throw new IndexOutOfBoundsException();\n  }\n else   if (len \u003d\u003d 0) {\n    return 0;\n  }\n else {\n    if (!base64.hasData()) {\n      byte[] buf\u003dnew byte[doEncode ? 4096 : 8192];\n      int c\u003din.read(buf);\n      if (doEncode) {\n        base64.encode(buf,0,c);\n      }\n else {\n        base64.decode(buf,0,c);\n      }\n    }\n    return base64.readResults(b,offset,len);\n  }\n}\n\n/** \n * Resets this Base64 object to its initial newly constructed state.\n */\nprivate void reset(){\n  buf\u003dnull;\n  pos\u003d0;\n  readPos\u003d0;\n  currentLinePos\u003d0;\n  modulus\u003d0;\n  eof\u003dfalse;\n}\n\n/** \n * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail bytes.  Returns how many bytes were actually extracted.\n * @param b      byte[] array to extract the buffered data into.\n * @param bPos   position in byte[] array to start extraction at.\n * @param bAvail amount of bytes we\u0027re allowed to extract.  We may extractfewer (if fewer are available).\n * @return The number of bytes successfully extracted into the providedbyte[] array.\n */\nint readResults(byte[] b,int bPos,int bAvail){\n  if (buf !\u003d null) {\n    int len\u003dMath.min(avail(),bAvail);\n    System.arraycopy(buf,readPos,b,bPos,len);\n    readPos+\u003dlen;\n    if (readPos \u003e\u003d pos) {\n      buf\u003dnull;\n    }\n    return len;\n  }\n else {\n    return eof ? -1 : 0;\n  }\n}\n\n/** \n * Decodes Base64 data into octects\n * @param base64Data Byte array containing Base64 data\n * @return Array containing decoded data.\n */\npublic static byte[] decodeBase64(byte[] base64Data){\n  if (base64Data \u003d\u003d null || base64Data.length \u003d\u003d 0) {\n    return base64Data;\n  }\n  Base64 b64\u003dnew Base64();\n  b64.reset();\n  b64.decode(base64Data,0,base64Data.length);\n  b64.decode(base64Data,0,-1);\n  byte[] result\u003dnew byte[b64.pos];\n  b64.readResults(result,0,result.length);\n  return result;\n}\n\n/** \n * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n * @param binaryData Array containing binary data to encode.\n * @param isChunked if \u003ccode\u003etrue\u003c/code\u003e this encoder will chunk the base64 output into 76 character blocks\n * @return Base64-encoded data.\n * @throws IllegalArgumentException Thrown when the input array needs an output array bigger than  {@link Integer#MAX_VALUE}\n */\npublic static byte[] encodeBase64(byte[] binaryData,boolean isChunked){\n  if (binaryData \u003d\u003d null || binaryData.length \u003d\u003d 0) {\n    return binaryData;\n  }\n  Base64 b64\u003disChunked ? new Base64() : new Base64(0);\n  b64.reset();\n  long len\u003d(binaryData.length * 4) / 3;\n  long mod\u003dlen % 4;\n  if (mod !\u003d 0) {\n    len+\u003d4 - mod;\n  }\n  if (isChunked) {\n    len+\u003d(1 + (len / CHUNK_SIZE)) * CHUNK_SEPARATOR.length;\n  }\n  if (len \u003e Integer.MAX_VALUE) {\n    throw new IllegalArgumentException(\"Input array too big, output array would be bigger than Integer.MAX_VALUE\u003d\" + Integer.MAX_VALUE);\n  }\n  b64.encode(binaryData,0,binaryData.length);\n  b64.encode(binaryData,0,-1);\n  byte[] buf\u003dnew byte[b64.pos - b64.readPos];\n  b64.readResults(buf,0,buf.length);\n  return buf;\n}\n\n",
    "original": "/** \n * Decodes Base64 data into octects\n * @param base64Data Byte array containing Base64 data\n * @return Array containing decoded data.\n */\npublic static byte[] decodeBase64(byte[] base64Data){\n  base64Data\u003ddiscardNonBase64(base64Data);\n  if (base64Data.length \u003d\u003d 0) {\n    return new byte[0];\n  }\n  int numberQuadruple\u003dbase64Data.length / FOURBYTE;\n  byte decodedData[]\u003dnull;\n  byte b1\u003d0, b2\u003d0, b3\u003d0, b4\u003d0, marker0\u003d0, marker1\u003d0;\n  int encodedIndex\u003d0;\n  int dataIndex\u003d0;\n{\n    int lastData\u003dbase64Data.length;\n    while (base64Data[lastData - 1] \u003d\u003d PAD) {\n      if (--lastData \u003d\u003d 0) {\n        return new byte[0];\n      }\n    }\n    decodedData\u003dnew byte[lastData - numberQuadruple];\n  }\n  for (int i\u003d0; i \u003c numberQuadruple; i++) {\n    dataIndex\u003di * 4;\n    marker0\u003dbase64Data[dataIndex + 2];\n    marker1\u003dbase64Data[dataIndex + 3];\n    b1\u003dbase64Alphabet[base64Data[dataIndex]];\n    b2\u003dbase64Alphabet[base64Data[dataIndex + 1]];\n    if (marker0 !\u003d PAD \u0026\u0026 marker1 !\u003d PAD) {\n      b3\u003dbase64Alphabet[marker0];\n      b4\u003dbase64Alphabet[marker1];\n      decodedData[encodedIndex]\u003d(byte)(b1 \u003c\u003c 2 | b2 \u003e\u003e 4);\n      decodedData[encodedIndex + 1]\u003d(byte)(((b2 \u0026 0xf) \u003c\u003c 4) | ((b3 \u003e\u003e 2) \u0026 0xf));\n      decodedData[encodedIndex + 2]\u003d(byte)(b3 \u003c\u003c 6 | b4);\n    }\n else     if (marker0 \u003d\u003d PAD) {\n      decodedData[encodedIndex]\u003d(byte)(b1 \u003c\u003c 2 | b2 \u003e\u003e 4);\n    }\n else     if (marker1 \u003d\u003d PAD) {\n      b3\u003dbase64Alphabet[marker0];\n      decodedData[encodedIndex]\u003d(byte)(b1 \u003c\u003c 2 | b2 \u003e\u003e 4);\n      decodedData[encodedIndex + 1]\u003d(byte)(((b2 \u0026 0xf) \u003c\u003c 4) | ((b3 \u003e\u003e 2) \u0026 0xf));\n    }\n    encodedIndex+\u003d3;\n  }\n  return decodedData;\n}\n\n/** \n * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n * @param binaryData Array containing binary data to encode.\n * @param isChunked if \u003ccode\u003etrue\u003c/code\u003e this encoder will chunk the base64 output into 76 character blocks\n * @return Base64-encoded data.\n * @throws IllegalArgumentException Thrown when the input array needs an output array bigger than  {@link Integer#MAX_VALUE}\n */\npublic static byte[] encodeBase64(byte[] binaryData,boolean isChunked){\n  long binaryDataLength\u003dbinaryData.length;\n  long lengthDataBits\u003dbinaryDataLength * EIGHTBIT;\n  long fewerThan24bits\u003dlengthDataBits % TWENTYFOURBITGROUP;\n  long tripletCount\u003dlengthDataBits / TWENTYFOURBITGROUP;\n  long encodedDataLengthLong\u003d0;\n  int chunckCount\u003d0;\n  if (fewerThan24bits !\u003d 0) {\n    encodedDataLengthLong\u003d(tripletCount + 1) * 4;\n  }\n else {\n    encodedDataLengthLong\u003dtripletCount * 4;\n  }\n  if (isChunked) {\n    chunckCount\u003d(CHUNK_SEPARATOR.length \u003d\u003d 0 ? 0 : (int)Math.ceil((float)encodedDataLengthLong / CHUNK_SIZE));\n    encodedDataLengthLong+\u003dchunckCount * CHUNK_SEPARATOR.length;\n  }\n  if (encodedDataLengthLong \u003e Integer.MAX_VALUE) {\n    throw new IllegalArgumentException(\"Input array too big, output array would be bigger than Integer.MAX_VALUE\u003d\" + Integer.MAX_VALUE);\n  }\n  int encodedDataLength\u003d(int)encodedDataLengthLong;\n  byte encodedData[]\u003dnew byte[encodedDataLength];\n  byte k\u003d0, l\u003d0, b1\u003d0, b2\u003d0, b3\u003d0;\n  int encodedIndex\u003d0;\n  int dataIndex\u003d0;\n  int i\u003d0;\n  int nextSeparatorIndex\u003dCHUNK_SIZE;\n  int chunksSoFar\u003d0;\n  for (i\u003d0; i \u003c tripletCount; i++) {\n    dataIndex\u003di * 3;\n    b1\u003dbinaryData[dataIndex];\n    b2\u003dbinaryData[dataIndex + 1];\n    b3\u003dbinaryData[dataIndex + 2];\n    l\u003d(byte)(b2 \u0026 0x0f);\n    k\u003d(byte)(b1 \u0026 0x03);\n    byte val1\u003d((b1 \u0026 SIGN) \u003d\u003d 0) ? (byte)(b1 \u003e\u003e 2) : (byte)((b1) \u003e\u003e 2 ^ 0xc0);\n    byte val2\u003d((b2 \u0026 SIGN) \u003d\u003d 0) ? (byte)(b2 \u003e\u003e 4) : (byte)((b2) \u003e\u003e 4 ^ 0xf0);\n    byte val3\u003d((b3 \u0026 SIGN) \u003d\u003d 0) ? (byte)(b3 \u003e\u003e 6) : (byte)((b3) \u003e\u003e 6 ^ 0xfc);\n    encodedData[encodedIndex]\u003dlookUpBase64Alphabet[val1];\n    encodedData[encodedIndex + 1]\u003dlookUpBase64Alphabet[val2 | (k \u003c\u003c 4)];\n    encodedData[encodedIndex + 2]\u003dlookUpBase64Alphabet[(l \u003c\u003c 2) | val3];\n    encodedData[encodedIndex + 3]\u003dlookUpBase64Alphabet[b3 \u0026 0x3f];\n    encodedIndex+\u003d4;\n    if (isChunked) {\n      if (encodedIndex \u003d\u003d nextSeparatorIndex) {\n        System.arraycopy(CHUNK_SEPARATOR,0,encodedData,encodedIndex,CHUNK_SEPARATOR.length);\n        chunksSoFar++;\n        nextSeparatorIndex\u003d(CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n        encodedIndex+\u003dCHUNK_SEPARATOR.length;\n      }\n    }\n  }\n  dataIndex\u003di * 3;\n  if (fewerThan24bits \u003d\u003d EIGHTBIT) {\n    b1\u003dbinaryData[dataIndex];\n    k\u003d(byte)(b1 \u0026 0x03);\n    byte val1\u003d((b1 \u0026 SIGN) \u003d\u003d 0) ? (byte)(b1 \u003e\u003e 2) : (byte)((b1) \u003e\u003e 2 ^ 0xc0);\n    encodedData[encodedIndex]\u003dlookUpBase64Alphabet[val1];\n    encodedData[encodedIndex + 1]\u003dlookUpBase64Alphabet[k \u003c\u003c 4];\n    encodedData[encodedIndex + 2]\u003dPAD;\n    encodedData[encodedIndex + 3]\u003dPAD;\n  }\n else   if (fewerThan24bits \u003d\u003d SIXTEENBIT) {\n    b1\u003dbinaryData[dataIndex];\n    b2\u003dbinaryData[dataIndex + 1];\n    l\u003d(byte)(b2 \u0026 0x0f);\n    k\u003d(byte)(b1 \u0026 0x03);\n    byte val1\u003d((b1 \u0026 SIGN) \u003d\u003d 0) ? (byte)(b1 \u003e\u003e 2) : (byte)((b1) \u003e\u003e 2 ^ 0xc0);\n    byte val2\u003d((b2 \u0026 SIGN) \u003d\u003d 0) ? (byte)(b2 \u003e\u003e 4) : (byte)((b2) \u003e\u003e 4 ^ 0xf0);\n    encodedData[encodedIndex]\u003dlookUpBase64Alphabet[val1];\n    encodedData[encodedIndex + 1]\u003dlookUpBase64Alphabet[val2 | (k \u003c\u003c 4)];\n    encodedData[encodedIndex + 2]\u003dlookUpBase64Alphabet[l \u003c\u003c 2];\n    encodedData[encodedIndex + 3]\u003dPAD;\n  }\n  if (isChunked) {\n    if (chunksSoFar \u003c chunckCount) {\n      System.arraycopy(CHUNK_SEPARATOR,0,encodedData,encodedDataLength - CHUNK_SEPARATOR.length,CHUNK_SEPARATOR.length);\n    }\n  }\n  return encodedData;\n}\n\n"
  },
  "Jsoup-79": {
    "buggy": "@Override protected List\u003cNode\u003e ensureChildNodes(){\n  throw new UnsupportedOperationException(\"Leaf Nodes do not have child nodes.\");\n}\n\n",
    "fix": "@Override protected List\u003cNode\u003e ensureChildNodes(){\n  return EmptyNodes;\n}\n\n",
    "original": "protected void ensureChildNodes(){\n  if (childNodes \u003d\u003d EMPTY_NODES) {\n    childNodes\u003dnew NodeList(4);\n  }\n}\n\n"
  }
}